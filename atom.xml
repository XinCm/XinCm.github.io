<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>XinCm</title>
  
  <subtitle>嘿嘿嘿</subtitle>
  <link href="http://example.com/atom.xml" rel="self"/>
  
  <link href="http://example.com/"/>
  <updated>2024-01-04T07:52:33.941Z</updated>
  <id>http://example.com/</id>
  
  <author>
    <name>lx</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>android 下device.mk</title>
    <link href="http://example.com/2024/01/04/device.mk/"/>
    <id>http://example.com/2024/01/04/device.mk/</id>
    <published>2024-01-04T07:52:33.921Z</published>
    <updated>2024-01-04T07:52:33.941Z</updated>
    
    <content type="html"><![CDATA[<h3 id="device-mk在Android中用于定义特定设备或特定产品的编译、链接、打包"><a href="#device-mk在Android中用于定义特定设备或特定产品的编译、链接、打包" class="headerlink" title="device.mk在Android中用于定义特定设备或特定产品的编译、链接、打包"></a><code>device.mk</code>在Android中用于定义特定设备或特定产品的<code>编译、链接、打包</code></h3><p><strong>.mk和.bp文件语法不同，举例均为mk语法，bp均有替代语法</strong></p><p>常见使用方法：</p><h3 id="1-需要编译某一模块时，在device-mk或者-mk中添加："><a href="#1-需要编译某一模块时，在device-mk或者-mk中添加：" class="headerlink" title="1. 需要编译某一模块时，在device.mk或者&lt;product_name&gt;.mk中添加："></a>1. 需要编译某一模块时，在<code>device.mk</code>或者<code>&lt;product_name&gt;.mk</code>中添加：</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">PRODUCT_PACKAGES += \</span><br><span class="line">    MyApp\</span><br></pre></td></tr></table></figure><h3 id="2-添加Android-propty："><a href="#2-添加Android-propty：" class="headerlink" title="2. 添加Android propty："></a>2. 添加Android propty：</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">PRODUCT_PROPERTY_OVERRIDES += \</span><br><span class="line">    wifi.interface=wlan0 \</span><br></pre></td></tr></table></figure><h3 id="3-添加其他mk-bp文件："><a href="#3-添加其他mk-bp文件：" class="headerlink" title="3. 添加其他mk&#x2F;bp文件："></a>3. 添加其他mk&#x2F;bp文件：</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$(call inherit-product, device/commom/xxx/new_add.mk)</span><br></pre></td></tr></table></figure><h3 id="4-拷贝文件"><a href="#4-拷贝文件" class="headerlink" title="4. 拷贝文件"></a>4. 拷贝文件</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">PRODUCT_COPY_FILES += \</span><br><span class="line">    device/&lt;company-name&gt;/&lt;device-name&gt;/etc/permissions/privapp-permissions-R.xml:system_ext/etc/permissions/privapp-permissions-R.xml \</span><br></pre></td></tr></table></figure><h3 id="5-添加编译log"><a href="#5-添加编译log" class="headerlink" title="5. 添加编译log"></a>5. 添加编译log</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$(warning <span class="string">&quot;[TEST] call here&quot;</span>)</span><br></pre></td></tr></table></figure><h3 id="6-使其他模块不编入系统："><a href="#6-使其他模块不编入系统：" class="headerlink" title="6. 使其他模块不编入系统："></a>6. 使其他模块不编入系统：</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">LOCAL_OVERRIDES_PACKAGES := AlarmClock</span><br></pre></td></tr></table></figure><p>参考：</p><p><a href="https://source.android.com/docs/setup/create/new-device?hl=zh-cn">https://source.android.com/docs/setup/create/new-device?hl=zh-cn</a></p><hr>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;device-mk在Android中用于定义特定设备或特定产品的编译、链接、打包&quot;&gt;&lt;a href=&quot;#device-mk在Android中用于定义特定设备或特定产品的编译、链接、打包&quot; class=&quot;headerlink&quot; title=&quot;device.mk在An</summary>
      
    
    
    
    <category term="Android技术" scheme="http://example.com/categories/Android%E6%8A%80%E6%9C%AF/"/>
    
    
  </entry>
  
  <entry>
    <title>Treble Hal</title>
    <link href="http://example.com/2024/01/03/HAL_Project_Treble/"/>
    <id>http://example.com/2024/01/03/HAL_Project_Treble/</id>
    <published>2024-01-03T06:01:22.112Z</published>
    <updated>2024-01-03T06:01:22.112Z</updated>
    
    <content type="html"><![CDATA[<h1 id="ANDROID-HAL-Project-Treble"><a href="#ANDROID-HAL-Project-Treble" class="headerlink" title="ANDROID HAL- Project Treble"></a>ANDROID HAL- <strong>Project Treble</strong></h1><h2 id="1-HAL至今有四种架构"><a href="#1-HAL至今有四种架构" class="headerlink" title="1. HAL至今有四种架构"></a>1. HAL至今有四种架构</h2><blockquote><ul><li>Treble Project 之前使用的实现架构,使用传统 HAL 和旧版 HAL</li><li>直通式（passthrough mode）：Framework 和 HAL 层工作在同一个进程当中</li><li>绑定式（binderized mode）：直通式 HAL binder 化，变为绑定式 HAL。Framework 和 HAL 层工作在不同的进程，之间通过 Binder 进行 IPC</li><li>纯绑定式 ：相对于<strong>绑定式</strong>来说，绑定式 HAL 中并不包含直通式 HAL，因此称为纯绑定式</li></ul></blockquote><span id="more"></span><p>根据谷歌要求，出厂时就搭载 8.0 的设备，除了谷歌规定的 <a href="mailto:&#97;&#x6e;&#x64;&#x72;&#x6f;&#105;&#x64;&#46;&#x68;&#x61;&#x72;&#x64;&#x77;&#x61;&#x72;&#101;&#x2e;&#x67;&#114;&#97;&#x70;&#x68;&#x69;&#x63;&#x73;&#46;&#x6d;&#x61;&#112;&#x70;&#x65;&#x72;&#x40;&#x31;&#46;&#x30;">&#97;&#x6e;&#x64;&#x72;&#x6f;&#105;&#x64;&#46;&#x68;&#x61;&#x72;&#x64;&#x77;&#x61;&#x72;&#101;&#x2e;&#x67;&#114;&#97;&#x70;&#x68;&#x69;&#x63;&#x73;&#46;&#x6d;&#x61;&#112;&#x70;&#x65;&#x72;&#x40;&#x31;&#46;&#x30;</a> 和 <a href="mailto:&#97;&#x6e;&#100;&#x72;&#x6f;&#105;&#100;&#46;&#x68;&#97;&#x72;&#100;&#x77;&#x61;&#114;&#101;&#x2e;&#114;&#x65;&#110;&#100;&#101;&#x72;&#115;&#x63;&#114;&#105;&#112;&#x74;&#x40;&#49;&#46;&#48;">&#97;&#x6e;&#100;&#x72;&#x6f;&#105;&#100;&#46;&#x68;&#97;&#x72;&#100;&#x77;&#x61;&#114;&#101;&#x2e;&#114;&#x65;&#110;&#100;&#101;&#x72;&#115;&#x63;&#114;&#105;&#112;&#x74;&#x40;&#49;&#46;&#48;</a> 需使用 ②直通模式，其它 HAL 只能采用 绑定式 和 纯绑定式 模式的实现架构。</p><hr><h2 id="2-绑定式"><a href="#2-绑定式" class="headerlink" title="2. 绑定式"></a>2. 绑定式</h2><ul><li><p>绑定式hal 在直通式的基础上，添加 service 进程，修改 transport 类型为 hwbinder</p></li><li><p>service 的注册使用的是 <a href="https://android.googlesource.com/platform/hardware/interfaces/+/refs/tags/android-8.1.0_r65/graphics/composer/2.1/default/service.cpp#43">defaultPassthroughServiceImplementation()</a> 方法</p></li><li><p><code>*-impl.so</code> 库文件通过 <code>HIDL_FETCH_I***</code> 方法来加载传统 HAL(一般硬件厂家提供so共享库)</p></li><li><p>厂商的实现都在 service 中</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">impl.so:</span><br><span class="line">            cc_library_shared &#123;</span><br><span class="line">                name: &quot;android.hardware.gnss@1.0-impl&quot;,</span><br><span class="line">                    ...</span><br><span class="line">                srcs: [...],</span><br><span class="line">                shared_libs: [...],</span><br><span class="line">            &#125;</span><br><span class="line">service:</span><br><span class="line">            cc_binary &#123;</span><br><span class="line">                name: &quot;android.hardware.gnss@1.0-service&quot;,</span><br><span class="line">                    ...</span><br><span class="line">                srcs: [&quot;service.cpp&quot;],</span><br><span class="line">                shared_libs: [...],</span><br><span class="line">            &#125;</span><br></pre></td></tr></table></figure></li></ul><hr><h2 id="3-纯绑定式"><a href="#3-纯绑定式" class="headerlink" title="3. 纯绑定式"></a>3. 纯绑定式</h2><ul><li>service 的注册方法都是 <code>registerAsService()</code>，在 manifest.xml 中的 transport 类型为 hwbinder</li><li>**不再单独编译 <code>*-impl.so</code>**，而是全编译进 service 中。</li></ul>   <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">cc_binary &#123;</span><br><span class="line">    name: &quot;android.hardware.gnss@2.0-service&quot;,</span><br><span class="line">...</span><br><span class="line">    srcs: [</span><br><span class="line">    &quot;service.cpp&quot;,</span><br><span class="line">        &quot;GnssConfiguration.cpp&quot;,</span><br><span class="line">... </span><br><span class="line">    ],</span><br><span class="line">    shared_libs: [...],</span><br><span class="line">    static_libs: [...],</span><br></pre></td></tr></table></figure><hr><p><strong>参考：</strong> </p><p><a href="https://blog.omitol.com/2018/11/09/android-treble-hidl/">https://blog.omitol.com/2018/11/09/android-treble-hidl/</a></p><p><a href="https://source.android.google.cn/docs/core/architecture/hidl?hl=zh-cn">HIDL  | Android 开源项目  | Android Open Source Project (google.cn)</a></p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;ANDROID-HAL-Project-Treble&quot;&gt;&lt;a href=&quot;#ANDROID-HAL-Project-Treble&quot; class=&quot;headerlink&quot; title=&quot;ANDROID HAL- Project Treble&quot;&gt;&lt;/a&gt;ANDROID HAL- &lt;strong&gt;Project Treble&lt;/strong&gt;&lt;/h1&gt;&lt;h2 id=&quot;1-HAL至今有四种架构&quot;&gt;&lt;a href=&quot;#1-HAL至今有四种架构&quot; class=&quot;headerlink&quot; title=&quot;1. HAL至今有四种架构&quot;&gt;&lt;/a&gt;1. HAL至今有四种架构&lt;/h2&gt;&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;Treble Project 之前使用的实现架构,使用传统 HAL 和旧版 HAL&lt;/li&gt;
&lt;li&gt;直通式（passthrough mode）：Framework 和 HAL 层工作在同一个进程当中&lt;/li&gt;
&lt;li&gt;绑定式（binderized mode）：直通式 HAL binder 化，变为绑定式 HAL。Framework 和 HAL 层工作在不同的进程，之间通过 Binder 进行 IPC&lt;/li&gt;
&lt;li&gt;纯绑定式 ：相对于&lt;strong&gt;绑定式&lt;/strong&gt;来说，绑定式 HAL 中并不包含直通式 HAL，因此称为纯绑定式&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    <category term="Android技术" scheme="http://example.com/categories/Android%E6%8A%80%E6%9C%AF/"/>
    
    
  </entry>
  
  <entry>
    <title>GIT</title>
    <link href="http://example.com/2024/01/02/git/"/>
    <id>http://example.com/2024/01/02/git/</id>
    <published>2024-01-02T11:33:43.996Z</published>
    <updated>2024-01-02T11:33:43.996Z</updated>
    
    <content type="html"><![CDATA[<h1 id="GIT"><a href="#GIT" class="headerlink" title="GIT"></a>GIT</h1><hr><h3 id="git-amend"><a href="#git-amend" class="headerlink" title="git  amend"></a>git  amend</h3><ul><li>修改上次的 commit  提交</li><li>直接覆盖上次的commit,生成新的commit ID</li><li>保留上次commit的修改，将新修改合并到上次的commit</li></ul><blockquote><p>git add<br>git commit –amend</p></blockquote><span id="more"></span><hr><h3 id="git-clean"><a href="#git-clean" class="headerlink" title="git clean"></a>git clean</h3><p>从工作目录中删除未被版本控制的文件或目录。它通常用于清理工作目录，删除一些生成的或不必要的文件，以确保工作目录的状态是干净的。</p><blockquote><p>git clean -n      显示 将要 删除的 文件 和  目录<br>git clean -f　　删除当前目录下所有没有track过的文件. 他不会删除.gitignore文件里面指定的文件夹和文件, 不管这些文件有没有被track过.<br>git clean -df     删除当前目录下没有被track过的文件和文件夹<br>git clean -xfd   删除当前目录下所有没有track过的文件. 不管他是否是.gitignore文件里面指定的文件夹和文件.</p></blockquote><hr><h1 id="REPO"><a href="#REPO" class="headerlink" title="REPO"></a>REPO</h1><hr><hr><h3 id="repo-start"><a href="#repo-start" class="headerlink" title="repo start"></a>repo start</h3><p>repo start  <branch-name> [–all] [–rebase | –detach | –current-branch] [projects…]<br>为所有模块创建一个分支</p><blockquote><p><code>&lt;branch-name&gt;</code>: 要创建的新分支的名称。<br><code>--all</code>: 为所有项目创建分支。<br><code>--rebase</code>: 使用 rebase 方式创建分支（默认方式）。<br><code>--detach</code>: 创建一个分离头的分支。<br><code>--current-branch</code>: 在当前分支上工作，不切换到新分支。<br><code>projects...</code>: 要在其上创建新分支的项目（可选）。</p></blockquote><hr><h3 id="repo-status"><a href="#repo-status" class="headerlink" title="repo status"></a>repo status</h3><p>显示 project 中每个仓库的状态，并打印仓库名称。</p><hr><h3 id="repo-forall-c"><a href="#repo-forall-c" class="headerlink" title="repo forall -c"></a>repo forall -c</h3><p>遍历所有的git仓库，并在每个仓库执行-c所指定的命令（被执行的命令不限于git命令，而是任何被系统支持的命令，比如：ls 、 pwd 、cp 等 。</p><blockquote><p>ex :<br>    <strong>repo forall -c ‘git reset –hard &amp;&amp; git clean -fdx’</strong><br>    这个命令会对 Repo 管理的每个 Git 仓库执行两个命令：<br>    <code>git reset --hard</code>：将所有本地修改的文件丢弃，将 HEAD 恢复到最近的一次提交状态。<br>    <code>git clean -fdx</code>：删除所有未被 Git 跟踪的文件，包括构建产物、临时文件等。</p></blockquote>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;GIT&quot;&gt;&lt;a href=&quot;#GIT&quot; class=&quot;headerlink&quot; title=&quot;GIT&quot;&gt;&lt;/a&gt;GIT&lt;/h1&gt;&lt;hr&gt;
&lt;h3 id=&quot;git-amend&quot;&gt;&lt;a href=&quot;#git-amend&quot; class=&quot;headerlink&quot; title=&quot;git  amend&quot;&gt;&lt;/a&gt;git  amend&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;修改上次的 commit  提交&lt;/li&gt;
&lt;li&gt;直接覆盖上次的commit,生成新的commit ID&lt;/li&gt;
&lt;li&gt;保留上次commit的修改，将新修改合并到上次的commit&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;git add&lt;br&gt;git commit –amend&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    <category term="开发工具" scheme="http://example.com/categories/%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7/"/>
    
    
  </entry>
  
  <entry>
    <title>Android-vintf</title>
    <link href="http://example.com/2024/01/02/VINTF/"/>
    <id>http://example.com/2024/01/02/VINTF/</id>
    <published>2024-01-02T09:26:21.055Z</published>
    <updated>2024-01-02T09:26:21.055Z</updated>
    
    <content type="html"><![CDATA[<h1 id="VINTF"><a href="#VINTF" class="headerlink" title="VINTF"></a>VINTF</h1><p><a href="https://source.android.com/docs/core/architecture?hl=zh-cn">https://source.android.com/docs/core/architecture?hl=zh-cn</a></p><blockquote><p>Vendor Interface Object的缩写，即厂商接口对象。<br>android 8.0分离system和<a href="https://www.zhihu.com/search?q=vendor&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra=%7B%22sourceType%22:%22article%22,%22sourceId%22:%22661008492%22%7D">vendor</a>分区的机制之一，用来检查system和vendor依赖是否匹配。</p></blockquote><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>主要有<strong>两对 manifest 和 matrix</strong>，这两对清单和矩阵必须在 OTA 时进行协调，以确保设备可以获取与设备功能兼容的框架更新。Manifest 和 Matrix 在OTA升级前会进行匹配检查，以确保framework和device是兼容的。总的来说，manifest是提供端，matrix是需求端。</p><span id="more"></span> <p><img src="/images/VINTF/%E6%80%BB%E4%BD%93%E6%A1%86%E6%9E%B6.png"></p><blockquote><p><strong>设备清单</strong>描述了设备可以为框架提供的静态组件。<br><strong>框架兼容性矩阵</strong>描述了 Android 框架预期从给定设备中获取的内容。</p></blockquote><blockquote><p><strong>框架清单</strong>描述了框架可以为设备提供的高级层服务。<br><strong>设备兼容性矩阵</strong>描述了供应商映像需要框架提供的服务，此矩阵的组成在设备开发期间由开发者手动确定。</p></blockquote><ul><li><p><strong>Manifest 描述了提供给对方的feature（Provider）</strong></p></li><li><p><strong>Matrix 描述了需要对方提供的feature（Requirement）</strong></p><hr></li></ul><h2 id="Manifest"><a href="#Manifest" class="headerlink" title="Manifest"></a>Manifest</h2><p><strong>主要介绍设备清单（由设备提供）包含供应商清单和 ODM 清单。</strong></p><p><strong>Framework manifest文件是由Google手动生成的</strong></p><ul><li>在aosp源码的路径: <code>system/libhidl/manifest.xml</code></li><li>在设备上的路径: <code>/system/manifest.xml</code></li></ul><p><strong>Device manifest文件是和设备，硬件相关的</strong></p><ul><li>在aosp源码路径: <code>device/$&#123;VENDOR&#125;/$&#123;DEVICE&#125;/manifest.xml</code></li><li>在设备的路径: <code>/vendor/manifest.xml</code></li></ul><h3 id="Manifest-Fragment"><a href="#Manifest-Fragment" class="headerlink" title="Manifest Fragment"></a>Manifest Fragment</h3><p>在您的 <code>Android.bp</code> 或 <code>Android.mk</code> 文件中，将 <code>vintf_fragments</code> 添加到任意模块。例如，您可以修改实现了 HAL 的模块 (<code>my.package.foo@1.0-service-bar</code>)。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">... &#123;</span><br><span class="line">    ...</span><br><span class="line">    vintf_fragments: [&quot;manifest_foo.xml&quot;],</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">LOCAL_MODULE := ...</span><br><span class="line">LOCAL_VINTF_FRAGMENTS := manifest_foo.xml</span><br></pre></td></tr></table></figure><p>在名为 <code>manifest_foo.xml</code> 的文件中，为此模块创建清单。在构建时，此清单会添加到设备中。在此处添加条目与在设备的主清单中添加条目相同。这样，客户端就可以使用该接口，并允许 VTS 识别设备上的 HAL 实现。此清单会执行常规清单执行的任何操作。</p><p><strong>本质上，除了常规路径manifest，还会收集各处单独的device_manifest</strong></p><h3 id="example"><a href="#example" class="headerlink" title="example"></a>example</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- Comments, Legal notices, etc. here --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">manifest</span> <span class="attr">version</span>=<span class="string">&quot;1.0&quot;</span> <span class="attr">type</span>=<span class="string">&quot;framework&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">hal</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">name</span>&gt;</span>android.hidl.allocator<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">transport</span>&gt;</span>hwbinder<span class="tag">&lt;/<span class="name">transport</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">interface</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">name</span>&gt;</span>IAllocator<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">instance</span>&gt;</span>ashmem<span class="tag">&lt;/<span class="name">instance</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">interface</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">hal</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">hal</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">name</span>&gt;</span>android.hidl.memory<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">transport</span> <span class="attr">arch</span>=<span class="string">&quot;32+64&quot;</span>&gt;</span>passthrough<span class="tag">&lt;/<span class="name">transport</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">interface</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">name</span>&gt;</span>IMapper<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">instance</span>&gt;</span>ashmem<span class="tag">&lt;/<span class="name">instance</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">interface</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">hal</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">hal</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">name</span>&gt;</span>android.hidl.manager<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">transport</span>&gt;</span>hwbinder<span class="tag">&lt;/<span class="name">transport</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">interface</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">name</span>&gt;</span>IServiceManager<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">instance</span>&gt;</span>default<span class="tag">&lt;/<span class="name">instance</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">interface</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">hal</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">hal</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">name</span>&gt;</span>android.frameworks.sensorservice<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">transport</span>&gt;</span>hwbinder<span class="tag">&lt;/<span class="name">transport</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">interface</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">name</span>&gt;</span>ISensorManager<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">instance</span>&gt;</span>default<span class="tag">&lt;/<span class="name">instance</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">interface</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">hal</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">hal</span> <span class="attr">max-level</span>=<span class="string">&quot;5&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">name</span>&gt;</span>android.frameworks.schedulerservice<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">transport</span>&gt;</span>hwbinder<span class="tag">&lt;/<span class="name">transport</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">interface</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">name</span>&gt;</span>ISchedulingPolicyService<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">instance</span>&gt;</span>default<span class="tag">&lt;/<span class="name">instance</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">interface</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">hal</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">vendor-ndk</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>27<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">vendor-ndk</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">system-sdk</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>27<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">system-sdk</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">manifest</span>&gt;</span></span><br></pre></td></tr></table></figure><hr><h2 id="Matrix"><a href="#Matrix" class="headerlink" title="Matrix"></a>Matrix</h2><p><a href="https://source.android.google.cn/docs/core/architecture/vintf/comp-matrices?hl=zh-cn">兼容性矩阵  | Android 开源项目  | Android Open Source Project (google.cn)</a></p><p>Framework compatibility matrix描述的是framework对 device的需求，这个matrix文件是和Android Framework Image（system.img）关联的，Framework compatibility matrix的这些需要被device manifest支持。</p><p><strong>Device compatibility matrix描述了device对framework的需求。</strong></p><h3 id="example-1"><a href="#example-1" class="headerlink" title="example"></a>example</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- Comments, Legal notices, etc. here --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">compatibility-matrix</span> <span class="attr">version</span>=<span class="string">&quot;1.0&quot;</span> <span class="attr">type</span>=<span class="string">&quot;framework&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">hal</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">name</span>&gt;</span>vendor.foo.camera<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">interface</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">name</span>&gt;</span>IBetterCamera<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">instance</span>&gt;</span>default<span class="tag">&lt;/<span class="name">instance</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">interface</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">hal</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">compatibility-matrix</span>&gt;</span></span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;VINTF&quot;&gt;&lt;a href=&quot;#VINTF&quot; class=&quot;headerlink&quot; title=&quot;VINTF&quot;&gt;&lt;/a&gt;VINTF&lt;/h1&gt;&lt;p&gt;&lt;a href=&quot;https://source.android.com/docs/core/architecture?hl=zh-cn&quot;&gt;https://source.android.com/docs/core/architecture?hl=zh-cn&lt;/a&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Vendor Interface Object的缩写，即厂商接口对象。&lt;br&gt;android 8.0分离system和&lt;a href=&quot;https://www.zhihu.com/search?q=vendor&amp;search_source=Entity&amp;hybrid_search_source=Entity&amp;hybrid_search_extra=%7B%22sourceType%22:%22article%22,%22sourceId%22:%22661008492%22%7D&quot;&gt;vendor&lt;/a&gt;分区的机制之一，用来检查system和vendor依赖是否匹配。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h2&gt;&lt;p&gt;主要有&lt;strong&gt;两对 manifest 和 matrix&lt;/strong&gt;，这两对清单和矩阵必须在 OTA 时进行协调，以确保设备可以获取与设备功能兼容的框架更新。Manifest 和 Matrix 在OTA升级前会进行匹配检查，以确保framework和device是兼容的。总的来说，manifest是提供端，matrix是需求端。&lt;/p&gt;</summary>
    
    
    
    <category term="Android技术" scheme="http://example.com/categories/Android%E6%8A%80%E6%9C%AF/"/>
    
    
  </entry>
  
  <entry>
    <title>C++的参数传递</title>
    <link href="http://example.com/2023/12/08/C++%E7%9A%84%E5%8F%82%E6%95%B0%E4%BC%A0%E9%80%92/"/>
    <id>http://example.com/2023/12/08/C++%E7%9A%84%E5%8F%82%E6%95%B0%E4%BC%A0%E9%80%92/</id>
    <published>2023-12-08T09:46:02.251Z</published>
    <updated>2023-12-08T09:46:02.251Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>C++的参数传递</p><ul><li>值传递</li><li>指针传递</li><li>引用传递</li></ul></blockquote><span id="more"></span><h2 id="值传递"><a href="#值传递" class="headerlink" title="值传递"></a>值传递</h2><p>​当初始化一个非引用类型的变量时，初始值被<strong>拷贝</strong>给变量，对此变量的操作不会影响初始值。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a = <span class="number">0</span>;  <span class="comment">// a为初始变量</span></span><br><span class="line"><span class="type">int</span> b = a;  <span class="comment">// b是a的值的副本</span></span><br><span class="line">b = <span class="number">10</span>;   <span class="comment">// b值的修改不会改变a的初始值</span></span><br></pre></td></tr></table></figure><h2 id="指针形参"><a href="#指针形参" class="headerlink" title="指针形参"></a>指针形参</h2><p>​当执行指针拷贝时，行为和普通值传递一样，拷贝的是指针的值，拷贝之后，两个指针是不同的指针</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">change</span><span class="params">(<span class="type">int</span> *ptr)</span></span>&#123;</span><br><span class="line">    *ptr = <span class="number">100</span>;<span class="comment">//改变了ptr所指的对象的值</span></span><br><span class="line">      ptr = <span class="number">100</span>;<span class="comment">//只改变了ptr的局部拷贝，实参的值未改变</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> num = <span class="number">40</span>;</span><br><span class="line"><span class="built_in">change</span>(&amp;num); <span class="comment">//改变了num的值而非地址</span></span><br><span class="line"><span class="built_in">print</span>(num);  <span class="comment">// 伪代码，输出 num = 100</span></span><br></pre></td></tr></table></figure><p><strong>C中常常使用指针类型的形参访问函数外部的对象，在C++中建议用引用类型替代指针类型</strong></p><h2 id="引用传递"><a href="#引用传递" class="headerlink" title="引用传递"></a>引用传递</h2><p>​<strong>引用</strong>可以等价看作为对象起了一个别名，声明符号为**&amp;a**</p><blockquote><p>​int num &#x3D; 100;<br>​int &amp;ref &#x3D; num; &#x2F;&#x2F; ref 指向 num, 是 num 的另一个名字<br>​int &mmm;     &#x2F;&#x2F; <strong>报错，引用必须被初始化</strong></p></blockquote><p>一般在初始化变量时，初始值会被拷贝到新建对象中。而在定义引用时，程序把引用和初始值进行了<strong>绑定</strong>，而非拷贝初始值，所以引用必须被初始化。</p><p><strong>牢记：引用即别名</strong></p><p>引用本身不是一个对象，所以不能定义引用的引用，即：</p><blockquote><p>int a &#x3D; 1;<br>int &amp;ref_1 &#x3D; a;   &#x2F;&#x2F; 正确初始化引用<br>int &amp;ref_2 &#x3D; ref_1 &#x2F;&#x2F; <strong>错误：不能定义引用的引用</strong> </p></blockquote><p>在函数中使用引用传递：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">change</span><span class="params">(<span class="type">int</span> &amp;i)</span></span>&#123;<span class="comment">//此处的 int &amp;i 意思是接收一个int对象的引用，而非取地址</span></span><br><span class="line">    i = <span class="number">100</span>;<span class="comment">// 可理解为 &amp;i = j;标准的初始化引用,i仅仅是j的一个别称</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> j = <span class="number">5</span>;</span><br><span class="line"><span class="built_in">change</span>(j);<span class="comment">// j 采用传引用方式，值将被改变</span></span><br><span class="line"><span class="built_in">print</span>(j);   <span class="comment">// j = 100</span></span><br></pre></td></tr></table></figure><p>使用引用传递的好处：</p><ol><li><p>避免拷贝<br>当对象比较大时，直接拷贝对象比较低效，有些类型(如IO)根本不支持拷贝操作，此时只能引用</p></li><li><p>返回额外信息<br>C++中一个函数只能返回一个值，引用形参可以为我们返回多个值提供途径</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">test_a</span><span class="params">(<span class="type">int</span> a)</span></span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">return</span> x;   <span class="comment">//不使用引用时，只能返回一个x   </span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test_b</span><span class="params">(<span class="type">int</span> &amp;a)</span></span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">return</span> x;  <span class="comment">//使用引用时，除了x， 改变引用a的值同时会改变实参，相当于返回了另一个值</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h2 id="引用与指针的区别"><a href="#引用与指针的区别" class="headerlink" title="引用与指针的区别"></a>引用与指针的区别</h2><ol><li><p>形式上：</p><ul><li><p>指针本质上是一个存放地址的变量，是逻辑上独立的对象，可以被改变；</p></li><li><p>引用逻辑上不独立，只是一个别名，初始化后不可被改变，只能依附于同一个变量</p></li></ul></li><li><p>传递方式上：</p><ul><li>指针传递参数本质上还是<strong>值传递</strong>，它所传递的是个地址，在传递过程中会在栈上开辟空间，存放由主函数放进来的实参的值，从而成为实参的一个副本。值传递的特点是对任何形参做的任何操作都作为局部变量进行，不会印象实参。</li><li>引用传递过程中，形参虽然也作为局部变量在栈上开辟空间，但此时存放的是实参的地址，对形参做的操作都可以看做间接寻址。</li></ul></li><li><p>编译角度：<br>程序在编译时分别将指针和引用添加到符号表上，符号表上记录的是变量名及变量所对应地址。指针变量在符号表上对应的地址值为指针变量的地址值，而引用在符号表上对应的地址值为引用对象的地址值。符号表生成后就不会再改，因此指针可以改变其指向的对象（指针变量中的值可以改），而引用对象则不能修改。</p></li></ol>]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;C++的参数传递&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;值传递&lt;/li&gt;
&lt;li&gt;指针传递&lt;/li&gt;
&lt;li&gt;引用传递&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    <category term="C++" scheme="http://example.com/categories/C/"/>
    
    
  </entry>
  
  <entry>
    <title>LEETCODE 7. 整数反转</title>
    <link href="http://example.com/2023/12/08/LEETCODE-7.%E6%95%B4%E6%95%B0%E5%8F%8D%E8%BD%AC/"/>
    <id>http://example.com/2023/12/08/LEETCODE-7.%E6%95%B4%E6%95%B0%E5%8F%8D%E8%BD%AC/</id>
    <published>2023-12-08T09:46:02.251Z</published>
    <updated>2023-12-08T09:46:02.251Z</updated>
    
    <content type="html"><![CDATA[<p>给你一个 32 位的有符号整数 <code>x</code> ，返回将 <code>x</code> 中的数字部分反转后的结果。</p><p>如果反转后整数超过 32 位的有符号整数的范围 <code>[−2^31, 2^31 − 1]</code> ，就返回 0。</p><p><strong>假设环境不允许存储 64 位整数（有符号或无符号）。</strong></p><span id="more"></span><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">e.g.</span><br><span class="line">输入：x = <span class="number">123</span></span><br><span class="line">输出：<span class="number">321</span></span><br><span class="line">    </span><br><span class="line">输入：x = <span class="number">-123</span></span><br><span class="line">输出：<span class="number">-321</span></span><br><span class="line">    </span><br><span class="line">输入：x = <span class="number">120</span></span><br><span class="line">输出：<span class="number">21</span></span><br><span class="line">    </span><br><span class="line">输入：x = <span class="number">0</span></span><br><span class="line">输出：<span class="number">0</span></span><br></pre></td></tr></table></figure><hr><p>该题逐步分析</p><p>解决思路：直接计算即可</p><ol><li><p>处理边界条件： 数据范围是否超出int32  【−2^31, 2^31 − 1】</p></li><li><p>当x在边界内，反转后数字有可能超出边界，所以需要实时判断</p></li><li><p>对于负数不用额外单独处理,与正数的计算流程一样：</p></li></ol><blockquote><p> -12%10&#x3D; -2<br> -12 &#x2F;10 &#x3D; -1</p><p> rev &#x3D; -2*10 + (-1) &#x3D; -21</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">reverse</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> rev = <span class="number">0</span>;  <span class="comment">//反转后数字</span></span><br><span class="line">        <span class="type">int</span> digist = <span class="number">0</span>; <span class="comment">//POP的x结尾数字</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(x != <span class="number">0</span>)&#123;</span><br><span class="line"></span><br><span class="line">            digist = x % <span class="number">10</span>;</span><br><span class="line">            x /= <span class="number">10</span>;</span><br><span class="line">            </span><br><span class="line"> <span class="comment">// 检查溢出</span></span><br><span class="line">            <span class="keyword">if</span>(rev &gt; INT_MAX/<span class="number">10</span> || (rev == INT_MAX/<span class="number">10</span> &amp;&amp; digist &gt; <span class="number">7</span>)) <span class="keyword">return</span> <span class="number">0</span>;  <span class="comment">//INT_MAX 的个位是7</span></span><br><span class="line">            <span class="keyword">if</span>(rev &lt; INT_MIN/<span class="number">10</span> || (rev == INT_MIN/<span class="number">10</span> &amp;&amp; digist&lt; <span class="number">-8</span>)) <span class="keyword">return</span> <span class="number">0</span>;  <span class="comment">//INT_MIN 的个位是-8</span></span><br><span class="line"></span><br><span class="line">            rev = rev*<span class="number">10</span>+digist;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> rev;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;给你一个 32 位的有符号整数 &lt;code&gt;x&lt;/code&gt; ，返回将 &lt;code&gt;x&lt;/code&gt; 中的数字部分反转后的结果。&lt;/p&gt;
&lt;p&gt;如果反转后整数超过 32 位的有符号整数的范围 &lt;code&gt;[−2^31, 2^31 − 1]&lt;/code&gt; ，就返回 0。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;假设环境不允许存储 64 位整数（有符号或无符号）。&lt;/strong&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="LeetCode" scheme="http://example.com/categories/LeetCode/"/>
    
    
  </entry>
  
  <entry>
    <title>LEETCODE 5. 最长回文子串</title>
    <link href="http://example.com/2023/12/04/LEETCODE-5.%E6%9C%80%E9%95%BF%E5%9B%9E%E6%96%87%E5%AD%90%E4%B8%B2/"/>
    <id>http://example.com/2023/12/04/LEETCODE-5.%E6%9C%80%E9%95%BF%E5%9B%9E%E6%96%87%E5%AD%90%E4%B8%B2/</id>
    <published>2023-12-04T06:18:51.207Z</published>
    <updated>2023-12-04T06:18:51.207Z</updated>
    
    <content type="html"><![CDATA[<h2 id="LEETCODE-5-最长回文子串"><a href="#LEETCODE-5-最长回文子串" class="headerlink" title="LEETCODE 5.  最长回文子串"></a>LEETCODE 5.  最长回文子串</h2><p>给你一个字符串 <code>s</code>，找到 <code>s</code> 中最长的回文子串。<br>如果字符串的反序与原始字符串相同，则该字符串称为回文字符串。</p><span id="more"></span><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">e.g.</span><br><span class="line">输入：s = <span class="string">&quot;babad&quot;</span></span><br><span class="line">输出：<span class="string">&quot;bab&quot;</span></span><br><span class="line">解释：<span class="string">&quot;aba&quot;</span> 同样是符合题意的答案。</span><br><span class="line">    </span><br><span class="line">输入：s = <span class="string">&quot;cbbd&quot;</span></span><br><span class="line">输出：<span class="string">&quot;bb&quot;</span></span><br></pre></td></tr></table></figure><hr><p>该题逐步分析</p><p>解决思路：动态规划（此题非最优解，主要了解动态规划思想）</p><p>1、状态定义：定义数组dp[ i ] [ j ]: 代表 从字符串中索引 从i 到 j 是否为回文串，若是设为true，否则false</p><p>2、状态转移： 若要确定dp[ i ] [ j ]是回文串，则需要满足</p><ul><li><p>s[ i ] &#x3D; s[ j ]</p></li><li><p>s[i+1] &#x3D; s[j-1]  </p><p>即最终状态转移方程： <em>P</em>(<em>i</em>,<em>j</em>)&#x3D;<em>P</em>(<em>i</em>+1,<em>j</em>−1)∧(<em>Si</em>&#x3D;&#x3D;<em>Sj</em>)</p><p><em>（思想方法类似于科学归纳法）</em></p></li></ul><p>3、边界条件初始化： 单独处理长度为 1 和 2 的字符串</p><ul><li><p>len &#x3D; 1: dp[ i ] [ i ] &#x3D; true</p></li><li><p>len &#x3D; 2 : if  s[ i ] &#x3D; s[ i+1 ]  ; then dp[ i ] [ i+1 ] &#x3D; true</p></li></ul><p>4、 返回值维护: 维护最长回文字串的起始位置和长度</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">string <span class="title">longestPalindrome</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span>  n = s.<span class="built_in">size</span>();</span><br><span class="line">        <span class="type">int</span> maxLen = <span class="number">1</span>;     <span class="comment">//最长字串的长度</span></span><br><span class="line">        <span class="type">int</span> begin = <span class="number">0</span>;  <span class="comment">//最长字串的起始位置</span></span><br><span class="line">        <span class="keyword">if</span>(n&lt;<span class="number">2</span>) <span class="keyword">return</span> s;   <span class="comment">//当字符串长度为1或0时，一定是回文子串</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//动态规划：创建一个二维数组来存储已经计算过的子问题的解</span></span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">dp</span>(n, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(n));      <span class="comment">// dp[i][j] 表示 s[i..j] 是否是回文串</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">            dp[i][i] = <span class="literal">true</span>;   <span class="comment">//单独处理L=1的子串，每个长度为1的字串都是回文串</span></span><br><span class="line">            <span class="keyword">if</span>(i&lt;n<span class="number">-1</span> &amp;&amp; s[i]==s[i+<span class="number">1</span>])&#123;    <span class="comment">//单独处理L=2的子串</span></span><br><span class="line">                dp[i][i+<span class="number">1</span>]=<span class="literal">true</span>;</span><br><span class="line">                maxLen = <span class="number">2</span>;</span><br><span class="line">                begin = i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//递推开始</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> L=<span class="number">3</span>;L&lt;=n;L++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">                <span class="type">int</span> j = L+i<span class="number">-1</span>;     <span class="comment">// j-i+1 = L</span></span><br><span class="line">                <span class="keyword">if</span>(j&gt;=n)    <span class="keyword">break</span>;  <span class="comment">//右边越界</span></span><br><span class="line">            </span><br><span class="line">                <span class="keyword">if</span>(s[i] != s[j])    dp[i][j] = <span class="literal">false</span>;</span><br><span class="line">                <span class="keyword">else</span>&#123;</span><br><span class="line">                    dp[i][j] = dp[i+<span class="number">1</span>][j<span class="number">-1</span>];</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(dp[i][j] &amp;&amp; j-i+<span class="number">1</span> &gt;= maxLen)&#123;</span><br><span class="line">                    maxLen = j-i+<span class="number">1</span>;</span><br><span class="line">                    begin = i;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span>  s.<span class="built_in">substr</span>(begin,maxLen);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;LEETCODE-5-最长回文子串&quot;&gt;&lt;a href=&quot;#LEETCODE-5-最长回文子串&quot; class=&quot;headerlink&quot; title=&quot;LEETCODE 5.  最长回文子串&quot;&gt;&lt;/a&gt;LEETCODE 5.  最长回文子串&lt;/h2&gt;&lt;p&gt;给你一个字符串 &lt;code&gt;s&lt;/code&gt;，找到 &lt;code&gt;s&lt;/code&gt; 中最长的回文子串。&lt;br&gt;如果字符串的反序与原始字符串相同，则该字符串称为回文字符串。&lt;/p&gt;</summary>
    
    
    
    <category term="LeetCode" scheme="http://example.com/categories/LeetCode/"/>
    
    
  </entry>
  
  <entry>
    <title>BootChart使用手顺</title>
    <link href="http://example.com/2023/12/01/bootchart%E4%BD%BF%E7%94%A8%E6%89%8B%E9%A1%BA/"/>
    <id>http://example.com/2023/12/01/bootchart%E4%BD%BF%E7%94%A8%E6%89%8B%E9%A1%BA/</id>
    <published>2023-12-01T06:02:04.070Z</published>
    <updated>2023-12-01T06:02:04.070Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>BootChart是用于linux启动过程性能分析的开源软件工具，它可以在内核装载后就开始运行，记录各个程序启动占用的时间、CPU以及硬盘读写，直到系统启动完成为止。</p></blockquote><span id="more"></span><h2 id="STEP1"><a href="#STEP1" class="headerlink" title="STEP1"></a>STEP1</h2><p>kernel config中打开以下四个配置：</p><blockquote><p>CONFIG_PROC_FS&#x3D;y<br>CONFIG_SCHEDSTATS&#x3D;y<br>CONFIG_SCHED_DEBUG&#x3D;y<br>CONFIG_LATENCYTOP&#x3D;y</p></blockquote><h2 id="STEP2"><a href="#STEP2" class="headerlink" title="STEP2"></a>STEP2</h2><p>bootchart工程编译生成两个产物：</p><blockquote><p>bootchartd: 放在目录&#x2F;sbin下<br>bootchartd.conf :放在目录&#x2F;etc下</p></blockquote><h2 id="STEP3"><a href="#STEP3" class="headerlink" title="STEP3"></a>STEP3</h2><p>修改uboot cmdline中，init&#x3D;bootchartd</p><h2 id="STEP4"><a href="#STEP4" class="headerlink" title="STEP4"></a>STEP4</h2><p>重启机器，在&#x2F;var&#x2F;log 目录下生成 .svg 文件   </p><p><em>注意事项</em>:<br><em>1、若系统开启selinux,需要考虑权限问题，不确定是否有影响可以先关闭selinux查看svg文件是否正常生成</em></p><p><em>2、必须保证&#x2F;var目录有可写权限，一般嵌入式系统默认rootfs是ro,需修改其权限</em></p><p><em>3、若无法在系统命令行对cmdline修改，需要在step3中源码修改完cmdline后，单独烧录uboot。顺序必须为先将两个产物放入对应目录，再修改cmdline, 否则会导致init 查找不到&#x2F;sbin&#x2F;bootchard 导致crash</em></p>]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;BootChart是用于linux启动过程性能分析的开源软件工具，它可以在内核装载后就开始运行，记录各个程序启动占用的时间、CPU以及硬盘读写，直到系统启动完成为止。&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    <category term="开发工具" scheme="http://example.com/categories/%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7/"/>
    
    
  </entry>
  
  <entry>
    <title>GDB 常用手顺</title>
    <link href="http://example.com/2023/12/01/GDB%20%E5%B8%B8%E7%94%A8%E6%89%8B%E9%A1%BA/"/>
    <id>http://example.com/2023/12/01/GDB%20%E5%B8%B8%E7%94%A8%E6%89%8B%E9%A1%BA/</id>
    <published>2023-12-01T06:02:04.070Z</published>
    <updated>2023-12-01T06:02:04.070Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>GDB usage</p></blockquote><span id="more"></span><h2 id="GDB-常用手顺"><a href="#GDB-常用手顺" class="headerlink" title="GDB 常用手顺"></a>GDB 常用手顺</h2><ol><li><h3 id="编译程序-gcc-编译时-加上-g-调试选项"><a href="#编译程序-gcc-编译时-加上-g-调试选项" class="headerlink" title="编译程序, gcc 编译时 加上-g 调试选项"></a>编译程序, gcc 编译时 加上-g 调试选项</h3><blockquote><p>gcc -g  main.c -o main.o</p></blockquote></li><li><h3 id="启动gdb"><a href="#启动gdb" class="headerlink" title="启动gdb"></a>启动gdb</h3><blockquote><p>gdb main.o</p></blockquote></li><li><h3 id="设置断点"><a href="#设置断点" class="headerlink" title="设置断点"></a>设置断点</h3><blockquote><p>(gdb) break main </p><p>&#x2F;&#x2F; 这会在 <code>main</code> 函数的开始处设置一个断点。也可以在特定的行号或函数上设置断点。</p></blockquote></li><li><h3 id="启动程序"><a href="#启动程序" class="headerlink" title="启动程序"></a>启动程序</h3><blockquote><p>(gdb) run</p><p>&#x2F;&#x2F;程序将开始执行并在达到第一个断点时停止。</p></blockquote></li><li><h3 id="单步执行和检查"><a href="#单步执行和检查" class="headerlink" title="单步执行和检查"></a>单步执行和检查</h3><blockquote><ul><li><code>next</code>（或 <code>n</code>）：执行下一行代码，但不进入函数内部。</li><li><code>step</code>（或 <code>s</code>）：执行下一行代码，如果是函数则进入函数内部。</li><li><code>print</code>（或 <code>p</code>）：打印变量的值或表达式的结果。</li><li><code>info locals</code>：显示当前函数的局部变量。</li><li><code>info args</code>：显示当前函数的参数。</li></ul></blockquote></li><li><h3 id="继续执行"><a href="#继续执行" class="headerlink" title="继续执行"></a>继续执行</h3><p>如果您想继续执行到下一个断点，使用：</p><blockquote><p>(gdb) continue</p></blockquote></li><li><h3 id="退出GDB"><a href="#退出GDB" class="headerlink" title="退出GDB"></a>退出GDB</h3><blockquote><p>(gdb) quit </p></blockquote></li><li><h3 id="常用指令"><a href="#常用指令" class="headerlink" title="常用指令"></a>常用指令</h3><blockquote><p>run：简记为 r ，其作用是运行程序，当遇到断点后，程序会在断点处停止运行，等待用户输入下一步的命令。 </p><p>continue （简写c ）：继续执行，到下一个断点处（或运行结束） </p><p>next：（简写 n），单步跟踪程序，当遇到函数调用时，也不进入此函数体；此命令同 step 的主要区别是，step 遇到用户自定义的函数，将步进到函数中去运行，而 next 则直接调用函数，不会进入到函数体内。 </p><p>step （简写s）：单步调试如果有函数调用，则进入函数；与命令n不同，n是不进入调用的函数的 </p><p>until：当你厌倦了在一个循环体内单步跟踪时，这个命令可以运行程序直到退出循环体。 </p><p>until+行号： 运行至某行，不仅仅用来跳出循环 finish： 运行程序，直到当前函数完成返回，并打印函数返回时的堆栈地址及参数值等信息。</p><p>call 函数(参数)：调用程序中可见的函数，并传递“参数”，如：call gdb_test(55) quit：简记为 q ，退出gdb</p><hr><p>print a : 打印变量a的值</p><p>print &amp;a : 打印变量a的地址</p><p>watch 表达式：设置一个监视点，一旦被监视的“表达式”的值改变，gdb将强行终止正在被调试的程序。如： watch a</p><hr><p>list ：简记为 l ，其作用就是列出程序的源代码，默认每次显示10行。 </p><p>list 行号：将显示当前文件以“行号”为中心的前后10行代码，如：list 12 </p><p>list 函数名：将显示“函数名”所在函数的源代码，如：list main</p><p>list ：不带参数，将接着上一次 list 命令的，输出下边的内容</p><hr><p>break n （简写b n）:在第n行处设置断点 （可以带上代码路径和代码名称： b OAGUPDATE.cpp:578）</p><p>b fn1 if a＞b：条件断点设置 </p><p>break func（break缩写为b）：在函数func()的入口处设置断点，如：break cb_button </p><p>delete 断点号n：删除第n个断点 </p><p>disable 断点号n：暂停第n个断点 </p><p>enable 断点号n：开启第n个断点 </p><p>clear 行号n：清除第n行的断点 </p><p>info b （info breakpoints） ：显示当前程序的断点设置情况 </p><p>delete breakpoints：清除所有断点：</p></blockquote></li></ol>]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;GDB usage&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    <category term="开发工具" scheme="http://example.com/categories/%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7/"/>
    
    
  </entry>
  
  <entry>
    <title>D-Bus_介绍&amp;工具使用</title>
    <link href="http://example.com/2023/12/01/D-Bus%20%E4%BB%8B%E7%BB%8D&amp;%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8/"/>
    <id>http://example.com/2023/12/01/D-Bus%20%E4%BB%8B%E7%BB%8D&amp;%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8/</id>
    <published>2023-12-01T06:02:04.066Z</published>
    <updated>2023-12-01T06:02:04.070Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>DBUS，数据总线，是一个低延迟，低开销，高可用性的ipc机制。<br>在D-Bus中，“bus”是核心的概念，它是一个通道：不同的程序可以通过这个通道做些操作，比如方法调用、发送信号和监听特定的信号。在一台机器上总线守护有多个实例(instance)。这些总线之间都是相互独立的。</p></blockquote><span id="more"></span><h1 id="一、D-Bus简介"><a href="#一、D-Bus简介" class="headerlink" title="一、D-Bus简介"></a>一、D-Bus简介</h1><p><img src="/images/D-Bus_%E4%BB%8B%E7%BB%8D&%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8/1.png"></p><h2 id="1、D-Bus简介"><a href="#1、D-Bus简介" class="headerlink" title="1、D-Bus简介"></a>1、D-Bus简介</h2><p>D-Bus是Desktop Bus的缩写，是针对桌面环境优化的IPC(InterProcess Communication)机制，用于进程间的通信或进程与内核的通信。<br>D-Bus是为Linux系统开发的进程间通信（IPC）和远程过程调用（RPC）机制，使用统一的通信协议来代替现有的各种IPC解决方案。D-Bus允许系统级进程（如：打印机和硬件驱动服务）和普通用户进程进行通信。<br>D-Bus使用一个快速的二进制消息传递协议，D-Bus协议的低延迟和低消耗特点适用于同一台机器的通信。D-Bus的规范目前由freedesktop.org项目定义，可供所有团体使用。<br>D-Bus不和低层的IPC直接竞争，比如sockets，shared memory或message queues。低层IPC有自己的特点，和D-Bus并不冲突。<br>与其他重量级的进程间通信技术不同，D-Bus是非事务的。D-Bus使用了状态以及连接的概念，比UDP等底层消息传输协议更“聪明”。但另一方面，D-Bus传送的是离散消息，与TCP协议将数据看做“流”有所不同。D-Bus支持点对点的消息传递以及广播&#x2F;订阅式的通信。</p><h2 id="2、不同IPC通信方式比较"><a href="#2、不同IPC通信方式比较" class="headerlink" title="2、不同IPC通信方式比较"></a>2、不同IPC通信方式比较</h2><p><strong>不同IPC通信机制的特点如下：</strong></p><blockquote><p>A、CORBA是用于面向对象编程中复杂IPC的一个强大的解决方案。<br>B、Bonobo是一个只用于GNOME的解决方案，基于CORBA并依赖于GObject。<br>C、DCOP是一个较轻量级的IPC框架，功能较少，但可以很好地集成到KDE桌面环境中。<br>D、SOAP和XML-RPC设计用于Web服务，因而使用HTTP作为其传输协议。<br>E、D-BUS设计用于桌面应用程序和OS通信。</p></blockquote><h2 id="3、D-Bus特性"><a href="#3、D-Bus特性" class="headerlink" title="3、D-Bus特性"></a>3、D-Bus特性</h2><blockquote><p>A、D-BUS的协议是低延迟而且低开销的，设计小巧且高效，以便最小化传送时间。从设计上避免往返交互并允许异步操作。<br>B、协议是二进制的，而不是文本，排除序列化过程。<br>C、考虑了字节序问题。<br>D、易用性：按照消息而不是字节流来工作，并且自动地处理了许多困难的IPC问题，并且D-Bus库以可以封装的方式来设计，开发者可以使用框架里存在的对象&#x2F;类型系统，而不用学习一种新的专用于IPC的对象&#x2F;类型系统。<br>E、请求时启动服务以及安全策略。<br>F、支持多语言（C&#x2F;C++&#x2F;Java&#x2F;C#&#x2F;Python&#x2F;Ruby），多平台(Linux&#x2F;windows&#x2F;maemo)。<br>G、采用C语言，而不是C++。<br>H、由于基本上不用于internet上的IPC，因此对本地IPC进行了特别优化。<br>I、提供服务注册，理论上可以进行无限扩展。</p></blockquote><h1 id="二、D-Bus架构"><a href="#二、D-Bus架构" class="headerlink" title="二、D-Bus架构"></a>二、D-Bus架构</h1><h2 id="1、D-Bus架构简介"><a href="#1、D-Bus架构简介" class="headerlink" title="1、D-Bus架构简介"></a>1、D-Bus架构简介</h2><p><strong>D-Bus是按一定的层次结构实现的，总体上D-Bus分为三层：</strong><br>A、接口层——接口层由libdbus库提供，进程通过libdbus库使用D-Bus的能力。通过底层库的接口可以实现两个进程之间进行连接并发送消息。<br>B、总线层——由消息总线守护进程(message bus daemon )提供，消息总线守护进程是基于libdbus底层库的，可以路由消息。消息总线守护进程负责进程间的消息路由和传递，其中包括Linux内核和Linux桌面环境的消息传递。<br>C、封装层——封装层是一系列基于特定应用程序框架的Wrapper库，将D-Bus底层接口封装成方便用户使用的通用API。</p><blockquote><p>A、接口层——接口层由libdbus库提供，进程通过libdbus库使用D-Bus的能力。通过底层库的接口可以实现两个进程之间进行连接并发送消息。<br>B、总线层——由消息总线守护进程(message bus daemon )提供，消息总线守护进程是基于libdbus底层库的，可以路由消息。消息总线守护进程负责进程间的消息路由和传递，其中包括Linux内核和Linux桌面环境的消息传递。<br>C、封装层——封装层是一系列基于特定应用程序框架的Wrapper库，将D-Bus底层接口封装成方便用户使用的通用API。</p></blockquote><h2 id="2、D-Bus接口层"><a href="#2、D-Bus接口层" class="headerlink" title="2、D-Bus接口层"></a>2、D-Bus接口层</h2><p>libdbus只支持点对点的通信，即只支持一进程与另外的一个进程进行通信。通信是基于消息的，消息包含头部和消息体。<br>libdbus提供C语言的底层API，API是为了将D-Bus绑定到特定的对象或是语言而设计的，官方文档中建议不要在应用上直接使用D-Bus的底层接口，推荐使用D-Bus的绑定，如QtDBus、GDBus、dbus-c++等实现。</p><h2 id="3、D-Bus总线层"><a href="#3、D-Bus总线层" class="headerlink" title="3、D-Bus总线层"></a>3、D-Bus总线层</h2><p>D-Bus总线层由消息总线守护进程(message bus daemon )提供。消息总线守护进程是一个后台进程,是&#x2F;usr&#x2F;bin&#x2F;dbus-daemon的一个运行实例, 负责消息的转发，dbus-daemon运行时会调用libdus的库。应用程序调用特定的应用程序框架的Wrapper库与dbus-daemon进行通信。应用程序通过D-Bus与其它进程通信必须先建立到消息总线守护进程实例的连接。<br>最常见的基于dbus的程序也符合C&#x2F;S结构。比如开发两个程序A和B，其中A是客户端，B是服务端。假设A要调用B的一个函数func，那么实际的消息流动方向是：A告诉dbus-daemon请求要调用B的func函数，然后dbus-daemon去调用B的func函数，如果func有返回值的话，B会把返回值告诉dbus-daemon，然后dbus- daemon再把返回值告诉A。如果B进程还没有启动，则dbus-daemon会自动的先把B进程启动起来。<br>通常情况下，Linux会有两个dbus-daemon进程，一个属于system，一个属于session，在用户登录的时候由dbus-launch启动。<br>大多数普通程序，都是使用session的dbus-daemon，默认情况下，A就是将消息发给属于session的dbus-daemon。<br>dbus-daemon是有地址的，环境变量DBUS_SESSION_BUS_ADDRESS用于表示当前登录用户的session的dbus-daemon进程的地址，可以使用下面命令查看。</p><blockquote><p>zyb@zyb:~$ echo $DBUS_SESSION_BUS_ADDRESS<br>unix:abstract&#x3D;&#x2F;tmp&#x2F;dbus-7BEdWvxPGx</p></blockquote><p>当用户登录进桌面环境的时候，系统启动脚本会调用到dbus-launch来启动一个dbus-daemon进程，同时会把启动的dbus-daemon地址赋予环境变量DBUS_SESSION_BUS_ADDRESS。<br>一般情况下，不需要考虑DBUS_SESSION_BUS_ADDRESS，但某些时候，单独启动一个dbus-daemon有助于程序的调试。<br>利用dbus-daemon自启动机制运行的服务进程，都是后台进程，标准输出设备已经被重定向，如果B进程有一些调试用的打印信息输出，则很难直接查看。此时，可以单独启动一个dbus-daemon，让A和B都使用自己启动的dbus-daemon，此时，dbus-daemon能把B的打印信息显示出来。<br><strong>先在终端下启动一个dbus-daemon，命令如下形式如下：</strong></p><blockquote><p>zyb@zyb:~$ DBUS_VERBOSE&#x3D;1 dbus-daemon –session –print-address<br>unix:abstract&#x3D;&#x2F;tmp&#x2F;dbus-uA3iIEfO1Z,guid&#x3D;4c58483b0f9112cb98abd34062287954</p></blockquote><p>如此启动的dbus-daemon会前台执行，并且打印出地址。然后，在执行A程序的时候，设置环境变量DBUS_SESSION_BUS_ADDRESS为刚才得到的地址值。</p><blockquote><p>DBUS_SESSION_BUS_ADDRESS&#x3D;unix:abstract&#x3D;&#x2F;tmp&#x2F;dbus-uA3iIEfO1Z,guid&#x3D;4c58483b0f9112cb98abd34062287954 .&#x2F;A</p></blockquote><p>此时运行程序A和B，使用自己启动的dbus-daemon来转发消息，并且会把B的打印信息显示出来。<br>消息总线守护进程是一个特殊的进程，用于管理系统内的总线，可以将一个进程的消息路由给另外一个进程。如果有很多应用程序连接到消息总线守护进程的总线上，总线能把消息路由到对应的一个或多个进程中去。因此在总线层上，实现了点对点通信的支持，也实现了广播&#x2F;订阅通信方式。<br>在最底层，D-Bus只支持点对点的通信，一般使用本地套接字(AF_UNIX)在应用和消息总线守护进程之间通信。D-Bus的点对点是经过bus daemon抽象过的，由bus daemon来完成寻址和发送消息，因此每个应用不必关心要把消息发给哪个进程。</p><h3 id="D-Bus发送消息通常包含如下步骤："><a href="#D-Bus发送消息通常包含如下步骤：" class="headerlink" title="D-Bus发送消息通常包含如下步骤："></a>D-Bus发送消息通常包含如下步骤：</h3><blockquote><p>A、应用程序创建和发送消息给消息总线守护进程。<br>B、消息总线守护进程对收到的消息进行分发处理。<br>C、目标程序接收到消息，然后根据消息的种类，做不同的响应：确认、应答、忽略。</p></blockquote><p>总线是D-Bus的进程间通信机制，一个系统中通常存在多条总线，总线由D-Bus总线守护进程管理。<br>最重要的总线为系统总线（System Bus），Linux内核引导时，系统总线就已被装入内存。只有Linux内核、Linux桌面环境和权限较高的程序才能向系统总线写入消息，以此保障系统安全性，防止有恶意进程假冒Linux发送消息。<br>会话总线（Session Buses）由普通进程创建，可同时存在多条。会话总线属于某个进程私有，用于进程间传递消息。</p><h2 id="4、D-Bus封装层"><a href="#4、D-Bus封装层" class="headerlink" title="4、D-Bus封装层"></a>4、D-Bus封装层</h2><p>D-Bus封装层是将libdbus底层API绑定到特定的对象系统或是语言中，將不便使用的libdbus底层API封裝成可以在应用层使用的高級API，如libdbus-glib、libdbus-qt等。<br>D-Bus在很多不同的编程语言上都有其接口实现。不同语言的接口封装了D-Bus低级API，提供了更符合编程语言的语法结构。<br>实现D-Bus接口的语言正在逐渐增加。在C语言中，有最底层的API，但其实现及使用上非常复杂。C语言中另一个实用化的实现基于GLib。在Java、Perl、Python等都有D-Bus接口实现。</p><h1 id="三、D-Bus术语"><a href="#三、D-Bus术语" class="headerlink" title="三、D-Bus术语"></a>三、D-Bus术语</h1><h2 id="1、D-Bus术语简介"><a href="#1、D-Bus术语简介" class="headerlink" title="1、D-Bus术语简介"></a>1、D-Bus术语简介</h2><p>总线是消息总线守护进程(message bus daemon)的运行实例，每个总线都有一个地址，应用进程就是通过总线地址和相应的总线连接的。总线上的每一个连接都有一个连接名，连接名也称bus name。每个连接上有至少一个对象，通常有多个对象，对象使用对象路径唯一标识。对象要实现一个或多个接口，每个接口包含一组方法和信号。</p><h2 id="2、总线（Bus）"><a href="#2、总线（Bus）" class="headerlink" title="2、总线（Bus）"></a>2、总线（Bus）</h2><p>在D-Bus中，总线(bus)是核心的概念：不同的程序可以通过总线进行某些操作，比如方法调用、发送信号和监听特定的信号。总线通常有两种，系统总线(system bus)和会话总线(session bus)，系统总线通常只有一条，用户总线在用户登录时创建。<br>系统总线是一个持久的总线，在系统启动时就创建，供系统内核和后台进程使用，具有较高的安全性。系统总线最常用是发送系统消息，比如：插入一个新的存储设备、有新的网络连接等。<br>会话总线是在某个用户登录后启动，属于某个用户私有，是某用户的应用程序用来通话的通道。在很多嵌入式系统中，只有一个用户ID登录运行，因此只有一个会话总线。<br>一条消息总线就是一个消息路由器，是消息总线守护进程(message bus daemon)的一个实例。</p><h2 id="3、地址-Address"><a href="#3、地址-Address" class="headerlink" title="3、地址(Address)"></a>3、地址(Address)</h2><p>使用d-bus的应用程序既可以是server端也可以是client端，server端监听到来的连接，client端连接到server端，一旦连接建立，消息就可以流转。如果使用dbus daemon，所有的应用程序都是client端，dbus daemon监听所有的连接，应用程序初始化连接到dbus daemon。<br>每一条总线都有一个地址，进程通过总线的地址连接到总线上。一个D-Bus的地址是指server端用于监听，client端将要连接的地方，例如unix:path&#x3D;&#x2F;tmp&#x2F;abcedf标识server端将在路径&#x2F;tmp&#x2F;abcedf的UNIX domain socket监听，client端将要连接到这个地址。地址可以是指定的TCP&#x2F;IP socket或者其他在或者将在D-Bus协议中定义的传输方式。<br>如果使用bus daemon，libdbus将通过读取环境变量DBUS_SESSION_BUS_ADDRESS自动获取session bus damon的地址，通过检查一个指定的UNIX domain socket路径获取system bus的地址。<br>如果使用D-bus，但不是daemon，需要定义哪个应用是server端，哪个是client端，并定义一套机制用于认可server端的地址。</p><h2 id="4、连接名-Bus-Name"><a href="#4、连接名-Bus-Name" class="headerlink" title="4、连接名(Bus Name)"></a>4、连接名(Bus Name)</h2><p>总线上的每个连接都有一个或多个名字。当连接建立以后，D-Bus 服务会分配一个不可改变的连接名，称为唯一连接名(unique connection name)，唯一连接名即使在进程结束后也不会再被其他进程所使用。<br>唯一连接名以冒号开头，如“:34-907”。但唯一连接名总是临时分配，无法确定，也难以记忆，因此应用可以要求有另外一个名字公共名(well-known name)来对应唯一连接名。例如可以使用“com.mycompany”来映射“:34-907”。应用程序可能会要求拥有额外的公共名(well-known name)。例如，可以写一个规范来定义一个名字叫做 com.mycompany.TextEditor。协议可以指定自己拥有名字为com.mycompany.TextEditor的连接，一个路径为&#x2F;com&#x2F;mycompany&#x2F;TextFileManager的对象，对象拥有接口org.freedesktop.FileHandler。应用程序就可以发送消息到总线上的连接名字，对象和接口以执行方法调用。</p><p>连接名可以用于跟踪应用程序的生命周期。当应用退出（或者崩溃）时，与总线的连接将被OS内核关掉，总线将会发送通知，告诉剩余的应用程序。</p><h2 id="5、对象和对象路径-Object-and-Object-Path"><a href="#5、对象和对象路径-Object-and-Object-Path" class="headerlink" title="5、对象和对象路径(Object and Object Path)"></a>5、对象和对象路径(Object and Object Path)</h2><p>D-Bus的对象和面向对象语言中的对象含义是不同的，D-Bus的对象表示的是D-Bus通道中信息流向的端点。对象由客户进程创建，并在连接进程中保持不变。<br>所有使用D-BUS的应用程序都包含一些对象, 当经由一个D-BUS连接收到一条消息时，消息是被发往一个对象而不是整个应用程序。应用程序框架中定义了这样的对象，如GObject，QObject等，在D-Bus中称为原生对象（native object）。<br>对于底层的D-Bus协议，即libdbus API，并不理会原生对象，使用对象路径(object path)的概念。通过对象路径，高层API接口可以绑定到对象，允许远程应用指向对象。对象路径如同文件系统路径，例如一个对象可能叫做“&#x2F;org&#x2F;kde&#x2F;kspread&#x2F;sheets&#x2F;3&#x2F;cells&#x2F;4&#x2F;5”。<br>对象路径在全局（session或者system）是唯一的，用于消息的路由。</p><h2 id="6、接口（Interface）"><a href="#6、接口（Interface）" class="headerlink" title="6、接口（Interface）"></a>6、接口（Interface）</h2><p>每一个对象支持一个或者多个接口，接口是一组方法和信号的集和，接口定义一个对象实体的类型。D-Bus对接口的命名方式，类似org.freedesktop.Introspectable。开发人员通常使用编程语言名字作为接口名字。</p><h2 id="7、方法-Methods"><a href="#7、方法-Methods" class="headerlink" title="7、方法(Methods)"></a>7、方法(Methods)</h2><p>每一个对象有两类成员：方法和信号。方法是一段函数代码，带有输入和输出；信号是广播给所有兴趣的其他实体，信号可以带有数据payload。</p><p>客户向某对象发送一个请求，即对象被请求执行一个明确的、有名称的动作。如果客户请求执行一个目标对象未提供的方法，将会产生一个错误。方法的定义可以支持输入参数。对于每个请求，都有一个包含请求结果以及结果数据(输出参数)的响应返回给请求者。当请求无法完成时，响应中将包含异常信息，其中至少有异常名称以及错误信息。<br>大多数语言都将这些封装在自身的语言机制中，比如将参数包装进消息包，将异常信息转换成语言自身的异常等等。在这些实现中，向远程对象传递一个字符串参数就好像是在本地执行一个字符串参数的函数一样简单。此时不再需要数据类型转换、数据复制等繁琐工作，语言本身封装了一切底层实现。</p><h2 id="8、信号-Signals"><a href="#8、信号-Signals" class="headerlink" title="8、信号(Signals)"></a>8、信号(Signals)</h2><p>信号依然遵从面向对象概念，信号是从对象发出但没有特定目的地址的单向数据广播。客户进程可以预先注册其感兴趣的信号，如特定名称的信号或从某个对象发出的信号等。当对象发出信号后，所有订阅了该信号的客户进程将收到此信号的复本。接收端可能有多种情况出现，或者有一个客户进程，或者有多个客户进程，或者根本没有客户进程对这个信号感兴趣。对于信号来说没有响应消息，发出信号的对象不会知道是不是有客户进程在接收，有多少客户进程接收，以及从客户进程收到任何反馈。<br>信号可以有参数。<br>但信号是单向通信，因此不可能像方法一样具有输入输出参数。D-Bus允许客户进程通过参数比对过滤其需要的信号。<br>信号一般用来广播一些客户可能会感兴趣的事件，比如某个其它的客户进程与总线的连接断开等。这些信号来自总线对象，因此从信号中客户进程可以分辨断线是由于正常退出、被杀掉或者程序崩溃。</p><h2 id="9、代理-Proxies"><a href="#9、代理-Proxies" class="headerlink" title="9、代理(Proxies)"></a>9、代理(Proxies)</h2><p>代理对象用来表示其他的remote object。当触发了proxy对象的method时，将会在D-Bus上发送一个method_call的消息，并等待答复，根据答复返回。<br>总线上的对象一般通过代理来访问。总线上的对象位于客户进程以外，而客户可以调用本地接口与对象通信，此时，本地接口充当了代理的角色。当触发了代理对象的方法时，将会在D-Bus上发送一个method_call的消息，并等待答复返回，就象使用一个本地对象一样。<br>一些语言的代理支持“断线重连”。比如所连接的对象在某段时间里暂时断开了与总线的连接，代理会自动重连到相同的连接名并重新找到对象，程序甚至不会知道目标对象有段时间不可用。并不是所有的语言都支持这一特性，在GLib中的两种代理中的一种支持。<br>比如不用代理时的代码如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Message message = new Message(<span class="string">&quot;/remote/object/path&quot;</span>, <span class="string">&quot;MethodName&quot;</span>, arg1, arg2); </span><br><span class="line">Connection connection = getBusConnection();           </span><br><span class="line">connection.send(message);           </span><br><span class="line">Message reply = connection.waitForReply(message);           </span><br><span class="line"><span class="keyword">if</span> (reply.isError()) &#123;                         </span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;              </span><br><span class="line">     Object returnValue = reply.getReturnValue();           </span><br><span class="line"> &#125; </span><br></pre></td></tr></table></figure><p>采用代理时对应的代码则是：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Proxy proxy = new Proxy(getBusConnection(), <span class="string">&quot;/remote/object/path&quot;</span>);      </span><br><span class="line">Object returnValue = proxy.MethodName(arg1, arg2);</span><br></pre></td></tr></table></figure><h2 id="10、服务"><a href="#10、服务" class="headerlink" title="10、服务"></a>10、服务</h2><p>服务是 D-BUS 的最高层次抽象，服务的实现当前还在不断发展变化。应用程序可以通过一个总线来注册一个服务，如果成功，则应用程序就已经获得了服务。其他应用程序可以检查在总线上是否已经存在一个特定的服务，如果没有可以要求总线启动它。<br>当通过总线进行通信时，应用程序会获取服务名称。服务名称是应用程序如何选择同一总线上的其他应用程序的依据。服务名称由总线守护进程进行代理，用于将消息从一个应用程序路由到另一个应用程序。服务名称的类似概念是IP地址和主机名：计算机通常具有一个IP地址，并且根据其向网络提供的服务，可以具有与之相关联的一个或多个主机名。<br>另一方面，如果不使用总线，服务名称也不会使用。如果再将它与计算机网络进行比较，这将等同于点到点网络：因为对等方是已知的，所以不需要使用主机名来查找它或它的IP地址。<br>总线服务名称的格式实际上与主机名非常相似：它是字母和数字的点分隔序列。常见的做法是根据服务定义的组织的域名来命名自己的服务名称。例如，D-Bus服务由freedesktop.org定义，可以使用org.freedesktop.DBus服务名称在总线上找到它。</p><h1 id="四、消息和消息总线"><a href="#四、消息和消息总线" class="headerlink" title="四、消息和消息总线"></a>四、消息和消息总线</h1><h2 id="1、消息简介"><a href="#1、消息简介" class="headerlink" title="1、消息简介"></a>1、消息简介</h2><p>D-Bus通信机制是通过进程间发送消息实现的，最基本的D-Bus协议是一对一的通信协议。与socket通信不同，D-Bus是面向消息的协议。但如果使用高层的绑定接口，不会直接接触到D-Bus的消息。<br><strong>D-Bus 有四种类型的消息：</strong></p><blockquote><p>A、method_call方法调用<br>B、method_return方法返回<br>C、error错误<br>D、signal信号</p></blockquote><p>代理中的远程对象调用涉及到了消息总线以及method_call和method_return两类消息。<br>消息有消息头(header)和消息体(body)。消息头包含消息体的路由信息，消息体是净荷，通常包含的是参数。消息头通常包含发送进程的连接名(Bus Name)、方法或者信号名等等，其中有一字段是用于描述消息体中的参数的类型的，例如“i”标识32位整数，“ii”表示2个32位整数。</p><h2 id="2、调用method的流程"><a href="#2、调用method的流程" class="headerlink" title="2、调用method的流程"></a>2、调用method的流程</h2><p>进程A要调用进程B的一个method，进程A发送method_call消息到进程B，进程B回复method_return消息。在发送消息时，发送方会在消息中添加不同的序列号，同样，回复消息中也会含有序列号，以便对应。</p><p><strong>调用method的流程如下：</strong></p><blockquote><p>A、在发送method_call消息时，如果使用了代理，进程A要调用进程B的某方法，不用构造method_call消息，只需调用代理的本地方法，代理会自动生成method_call消息发送到消息总线上。<br>B、如果使用底层API，进程A需要构造一个method_call消息。method_call消息包含对应进程B的连接名、方法名、方法所需参数、进程B中的对象路径和进程B中声明此方法的接口。<br>C、将method_call消息发送到消息总线上。<br>D、信息总线检查消息头中的目的连接名，当找到一个进程与此连接名对应时发送消息到该进程。当找不到一个进程与此连接名对应时，返回给进程A一个error消息。<br>E、进程B解析消息，如果是采用底层API方式，则直接调用方法，然后发宋应答消息到消息总线。如果是D-BUs高级API接口，会先检测对象路径、接口、方法名称，然后把消息转换成对应的本地对象（如GObject，QT中的QObject等）的方法，调用本地对象方法后再将应答结果转换成应答消息发给消息总线。<br>F、消息总线接收到method_return消息，将把method_return消息直接发给发出调用消息的进程。<br>消息总线不会对总线上的消息进行重排序。如果发送了两条消息到同一个进程，将按照发送顺序接收到。接收进程不需要按照顺序发出应答消息，例如在多线程中处理这些消息，应答消息的发出是没有顺序的。消息都有一个序列号可以与应答消息进行配对。</p></blockquote><h2 id="3、发送signal的流程"><a href="#3、发送signal的流程" class="headerlink" title="3、发送signal的流程"></a>3、发送signal的流程</h2><p>发送信号是单向广播的，信号的发送者不知道对信号作响应的有哪些进程，所以信号发送是没有返回值的。信号接收者通过向消息总线注册匹配规则来表示对某信号感兴趣，而匹配规则通常包含信号的发出者和信号名。<br><strong>信号发送的流程如下：</strong></p><blockquote><p>A、当使用dbus底层接口时，信号需要应用进程自己创建和发送到消息总线；使用dbus高层API接口时，可以使用相关对象进行发送。信号消息包含有声明信号的接口名、信号名、所在进程对应的连接名和相关参数。<br>B、连接到消息总线上的进程如果对某个信号感兴趣，则注册相应的匹配规则。消息总线保持有匹配规则表。<br>C、消息总线根据匹配规则表，将信号发送到对信号感兴趣的进程。<br>D、每个进程收到信号后，如果使用dbus高级API接口，可以选择触发代理对象上的信号。如果使用dbus底层接口，需要检查发送者名称和信号名称，然后决定怎么做。</p></blockquote><h2 id="4、DBus工具"><a href="#4、DBus工具" class="headerlink" title="4、DBus工具"></a>4、DBus工具</h2><p>D-Bus提供了两个小工具：dbus-send 和dbus-monitor。可以用dbus-send发送消息，用dbus-monitor监视通道上流动的消息。</p><h3 id="dbus-send"><a href="#dbus-send" class="headerlink" title="dbus-send"></a>dbus-send</h3><p>用于发送一个消息到消息通道上，使用格式如下：</p><blockquote><p>dbus-send [–system | –session] –type&#x3D;TYPE –print-reply –dest&#x3D;连接名对象路径接口名.方法名参数类型:参数值参数类型:参数值<br>dbus-send –session –type&#x3D;method_call –print-reply –dest&#x3D;连接名对象路径接口名.方法名 参数类型:参数值 参数类型:参数值</p></blockquote><p>dbus-send支持的参数类型包括：string, int32, uint32, double, byte, boolean。</p><h3 id="dbus-monitor"><a href="#dbus-monitor" class="headerlink" title="dbus-monitor"></a>dbus-monitor</h3><p>用于打印消息通道上的消息，使用格式如下：</p><blockquote><p>dbus-monitor [–system | –session | –address ADDRESS] [–profile | –monitor] [watch expressions]<br>dbus-monitor “type&#x3D;’signal’, sender&#x3D;’org.gnome.TypingMonitor’, interface&#x3D;’org.gnome.TypingMonitor’”</p></blockquote><h2 id="5、消息总线上的方法和信号"><a href="#5、消息总线上的方法和信号" class="headerlink" title="5、消息总线上的方法和信号"></a>5、消息总线上的方法和信号</h2><p>消息总线是一个特殊的应用，主要关于消息总线上的方法和信号。</p><h3 id="A、Introspection"><a href="#A、Introspection" class="headerlink" title="A、Introspection"></a>A、Introspection</h3><blockquote><p>消息总线上有一个接口org.freedesktop.DBus.Introspectable，接口中声明了一个方法Introspect，不带参数，将返回一个XML string，XML字符串描述接口、方法、信号。</p></blockquote><h3 id="B、消息总线上的方法和信号"><a href="#B、消息总线上的方法和信号" class="headerlink" title="B、消息总线上的方法和信号"></a>B、消息总线上的方法和信号</h3><p>可以通过向名称为“org.freedesktop.DBus”的连接上的对象“&#x2F;”发送消息来调用消息总线提供的方法。消息总线对象支持标准接口”org.freedesktop.DBus.Introspectable”，可以调用org.freedesktop.DBus.Introspectable.Introspect方法查看消息总线对象支持的接口。</p><blockquote><p>dbus-send –session –type&#x3D;method_call –print-reply –dest&#x3D;org.freedesktop.DBus &#x2F; org.freedesktop.DBus.Introspectable.Introspect</p></blockquote><p>用户总线对象支持标准接口“org.freedesktop.DBus.Introspectable”和接口“org.freedesktop.DBus”。<br>接口“org.freedesktop.DBus”有18个方法和3个信号。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><span class="line">&lt;interface name=<span class="string">&quot;org.freedesktop.DBus&quot;</span>&gt;</span><br><span class="line">  &lt;method name=<span class="string">&quot;Hello&quot;</span>&gt;</span><br><span class="line">    &lt;arg direction=<span class="string">&quot;out&quot;</span> type=<span class="string">&quot;s&quot;</span>/&gt;</span><br><span class="line">  &lt;/method&gt;</span><br><span class="line">  &lt;method name=<span class="string">&quot;RequestName&quot;</span>&gt;</span><br><span class="line">    &lt;arg direction=<span class="string">&quot;in&quot;</span> type=<span class="string">&quot;s&quot;</span>/&gt;</span><br><span class="line">    &lt;arg direction=<span class="string">&quot;in&quot;</span> type=<span class="string">&quot;u&quot;</span>/&gt;</span><br><span class="line">    &lt;arg direction=<span class="string">&quot;out&quot;</span> type=<span class="string">&quot;u&quot;</span>/&gt;</span><br><span class="line">  &lt;/method&gt;</span><br><span class="line">  &lt;method name=<span class="string">&quot;ReleaseName&quot;</span>&gt;</span><br><span class="line">    &lt;arg direction=<span class="string">&quot;in&quot;</span> type=<span class="string">&quot;s&quot;</span>/&gt;</span><br><span class="line">    &lt;arg direction=<span class="string">&quot;out&quot;</span> type=<span class="string">&quot;u&quot;</span>/&gt;</span><br><span class="line">  &lt;/method&gt;</span><br><span class="line">  &lt;method name=<span class="string">&quot;StartServiceByName&quot;</span>&gt;</span><br><span class="line">    &lt;arg direction=<span class="string">&quot;in&quot;</span> type=<span class="string">&quot;s&quot;</span>/&gt;</span><br><span class="line">    &lt;arg direction=<span class="string">&quot;in&quot;</span> type=<span class="string">&quot;u&quot;</span>/&gt;</span><br><span class="line">    &lt;arg direction=<span class="string">&quot;out&quot;</span> type=<span class="string">&quot;u&quot;</span>/&gt;</span><br><span class="line">  &lt;/method&gt;</span><br><span class="line">  &lt;method name=<span class="string">&quot;UpdateActivationEnvironment&quot;</span>&gt;</span><br><span class="line">    &lt;arg direction=<span class="string">&quot;in&quot;</span> type=<span class="string">&quot;a&#123;ss&#125;&quot;</span>/&gt;</span><br><span class="line">  &lt;/method&gt;</span><br><span class="line">  &lt;method name=<span class="string">&quot;NameHasOwner&quot;</span>&gt;</span><br><span class="line">    &lt;arg direction=<span class="string">&quot;in&quot;</span> type=<span class="string">&quot;s&quot;</span>/&gt;</span><br><span class="line">    &lt;arg direction=<span class="string">&quot;out&quot;</span> type=<span class="string">&quot;b&quot;</span>/&gt;</span><br><span class="line">  &lt;/method&gt;</span><br><span class="line">  &lt;method name=<span class="string">&quot;ListNames&quot;</span>&gt;</span><br><span class="line">    &lt;arg direction=<span class="string">&quot;out&quot;</span> type=<span class="string">&quot;as&quot;</span>/&gt;</span><br><span class="line">  &lt;/method&gt;</span><br><span class="line">  &lt;method name=<span class="string">&quot;ListActivatableNames&quot;</span>&gt;</span><br><span class="line">    &lt;arg direction=<span class="string">&quot;out&quot;</span> type=<span class="string">&quot;as&quot;</span>/&gt;</span><br><span class="line">  &lt;/method&gt;</span><br><span class="line">  &lt;method name=<span class="string">&quot;AddMatch&quot;</span>&gt;</span><br><span class="line">    &lt;arg direction=<span class="string">&quot;in&quot;</span> type=<span class="string">&quot;s&quot;</span>/&gt;</span><br><span class="line">  &lt;/method&gt;</span><br><span class="line">  &lt;method name=<span class="string">&quot;RemoveMatch&quot;</span>&gt;</span><br><span class="line">    &lt;arg direction=<span class="string">&quot;in&quot;</span> type=<span class="string">&quot;s&quot;</span>/&gt;</span><br><span class="line">  &lt;/method&gt;</span><br><span class="line">  &lt;method name=<span class="string">&quot;GetNameOwner&quot;</span>&gt;</span><br><span class="line">    &lt;arg direction=<span class="string">&quot;in&quot;</span> type=<span class="string">&quot;s&quot;</span>/&gt;</span><br><span class="line">    &lt;arg direction=<span class="string">&quot;out&quot;</span> type=<span class="string">&quot;s&quot;</span>/&gt;</span><br><span class="line">  &lt;/method&gt;</span><br><span class="line">  &lt;method name=<span class="string">&quot;ListQueuedOwners&quot;</span>&gt;</span><br><span class="line">    &lt;arg direction=<span class="string">&quot;in&quot;</span> type=<span class="string">&quot;s&quot;</span>/&gt;</span><br><span class="line">    &lt;arg direction=<span class="string">&quot;out&quot;</span> type=<span class="string">&quot;as&quot;</span>/&gt;</span><br><span class="line">  &lt;/method&gt;</span><br><span class="line">  &lt;method name=<span class="string">&quot;GetConnectionUnixUser&quot;</span>&gt;</span><br><span class="line">    &lt;arg direction=<span class="string">&quot;in&quot;</span> type=<span class="string">&quot;s&quot;</span>/&gt;</span><br><span class="line">    &lt;arg direction=<span class="string">&quot;out&quot;</span> type=<span class="string">&quot;u&quot;</span>/&gt;</span><br><span class="line">  &lt;/method&gt;</span><br><span class="line">  &lt;method name=<span class="string">&quot;GetConnectionUnixProcessID&quot;</span>&gt;</span><br><span class="line">    &lt;arg direction=<span class="string">&quot;in&quot;</span> type=<span class="string">&quot;s&quot;</span>/&gt;</span><br><span class="line">    &lt;arg direction=<span class="string">&quot;out&quot;</span> type=<span class="string">&quot;u&quot;</span>/&gt;</span><br><span class="line">  &lt;/method&gt;</span><br><span class="line">  &lt;method name=<span class="string">&quot;GetAdtAuditSessionData&quot;</span>&gt;</span><br><span class="line">    &lt;arg direction=<span class="string">&quot;in&quot;</span> type=<span class="string">&quot;s&quot;</span>/&gt;</span><br><span class="line">    &lt;arg direction=<span class="string">&quot;out&quot;</span> type=<span class="string">&quot;ay&quot;</span>/&gt;</span><br><span class="line">  &lt;/method&gt;</span><br><span class="line">  &lt;method name=<span class="string">&quot;GetConnectionSELinuxSecurityContext&quot;</span>&gt;</span><br><span class="line">    &lt;arg direction=<span class="string">&quot;in&quot;</span> type=<span class="string">&quot;s&quot;</span>/&gt;</span><br><span class="line">    &lt;arg direction=<span class="string">&quot;out&quot;</span> type=<span class="string">&quot;ay&quot;</span>/&gt;</span><br><span class="line">  &lt;/method&gt;</span><br><span class="line">  &lt;method name=<span class="string">&quot;ReloadConfig&quot;</span>&gt;</span><br><span class="line">  &lt;/method&gt;</span><br><span class="line">  &lt;method name=<span class="string">&quot;GetId&quot;</span>&gt;</span><br><span class="line">    &lt;arg direction=<span class="string">&quot;out&quot;</span> type=<span class="string">&quot;s&quot;</span>/&gt;</span><br><span class="line">  &lt;/method&gt;</span><br><span class="line">  &lt;signal name=<span class="string">&quot;NameOwnerChanged&quot;</span>&gt;</span><br><span class="line">    &lt;arg type=<span class="string">&quot;s&quot;</span>/&gt;</span><br><span class="line">    &lt;arg type=<span class="string">&quot;s&quot;</span>/&gt;</span><br><span class="line">    &lt;arg type=<span class="string">&quot;s&quot;</span>/&gt;</span><br><span class="line">  &lt;/signal&gt;</span><br><span class="line">  &lt;signal name=<span class="string">&quot;NameLost&quot;</span>&gt;</span><br><span class="line">    &lt;arg type=<span class="string">&quot;s&quot;</span>/&gt;</span><br><span class="line">  &lt;/signal&gt;</span><br><span class="line">  &lt;signal name=<span class="string">&quot;NameAcquired&quot;</span>&gt;</span><br><span class="line">    &lt;arg type=<span class="string">&quot;s&quot;</span>/&gt;</span><br><span class="line">  &lt;/signal&gt;</span><br><span class="line">&lt;/interface&gt;</span><br><span class="line">&lt;interface name=<span class="string">&quot;org.freedesktop.DBus.Introspectable&quot;</span>&gt;</span><br><span class="line">  &lt;method name=<span class="string">&quot;Introspect&quot;</span>&gt;</span><br><span class="line">    &lt;arg direction=<span class="string">&quot;out&quot;</span> type=<span class="string">&quot;s&quot;</span>/&gt;</span><br><span class="line">  &lt;/method&gt;</span><br><span class="line">&lt;/interface&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;DBUS，数据总线，是一个低延迟，低开销，高可用性的ipc机制。&lt;br&gt;在D-Bus中，“bus”是核心的概念，它是一个通道：不同的程序可以通过这个通道做些操作，比如方法调用、发送信号和监听特定的信号。在一台机器上总线守护有多个实例(instance)。这些总线之间都是相互独立的。&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    <category term="开发工具" scheme="http://example.com/categories/%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7/"/>
    
    
  </entry>
  
  <entry>
    <title>Android Property参数简介</title>
    <link href="http://example.com/2023/11/30/ANDROID%20property%20%E5%8F%82%E6%95%B0%E7%AE%80%E4%BB%8B/"/>
    <id>http://example.com/2023/11/30/ANDROID%20property%20%E5%8F%82%E6%95%B0%E7%AE%80%E4%BB%8B/</id>
    <published>2023-11-30T09:27:44.013Z</published>
    <updated>2023-11-30T09:27:44.013Z</updated>
    
    <content type="html"><![CDATA[<p><a name="3060-1621846615933"></a>在系统初始化时，Android将分配一块共享内存来存储property。这是在“init”守护进程中完成的，其源代码位于：device&#x2F;system&#x2F;init。“init”守护进程将启动PropertyService。</p><p><a name="qpdj-1679278003424"></a>属性服务正在“init”守护进程中运行。每个想要设置属性的客户端都需要连接到属性服务并向属性服务发送消息。属性服务将在共享内存中更新&#x2F;创建属性。任何想要获取属性的客户端都可以直接从共享内存中读取属性。这提高了读取性能。</p><span id="more"></span><p><a name="bjnd-1679278020126"></a><a name="t53l-1679278020702"></a>属性服务启动后会从系统文件中读取默认的属性，并写入共享内存中，以下4个文件为按顺序读取：</p><p><a name="k6us-1679278038355"></a>&#x2F;default.prop</p><p><a name="4ogz-1679278038357"></a>&#x2F;system&#x2F;build.prop</p><p><a name="udfl-1679278038359"></a>&#x2F;system&#x2F;default.prop</p><p><a name="4xes-1679278038361"></a>&#x2F;data&#x2F;local.prop</p><p><a name="4uvm-1679278038363"></a>后读入的属性将覆盖前面读取的相同的属性。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> PROP\_PATH\_RAMDISK\_DEFAULT  <span class="string">&quot;/default.prop&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PROP\_PATH\_SYSTEM\_BUILD     <span class="string">&quot;/system/build.prop&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PROP\_PATH\_SYSTEM\_DEFAULT   <span class="string">&quot;/system/default.prop&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PROP\_PATH\_LOCAL\_OVERRIDE   <span class="string">&quot;/data/local.prop&quot;</span></span></span><br></pre></td></tr></table></figure><p><strong>设置属性，ro.开头的属性将不能被更改属性值，persist.开头的属性会被永久纪录，其他属性值在重新开机后均将被丢弃</strong></p><p><strong>加载永久属性时，会读入在目录&#x2F;data&#x2F;property下所有名字以persist.开头的文件内容，作为该名字对应的属性值。</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">property_set</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *name, <span class="type">const</span> <span class="type">char</span> *value)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(namelen &lt; <span class="number">1</span>) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"> </span><br><span class="line">    pi = (prop_info*) __system_property_find(name);</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">if</span>(pi != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">/* ro.* properties may NEVER be modified once set */</span></span><br><span class="line">        <span class="keyword">if</span>(!<span class="built_in">strncmp</span>(name, <span class="string">&quot;ro.&quot;</span>, <span class="number">3</span>)) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"> </span><br><span class="line">        pa = __system_property_area__;</span><br><span class="line">        update_prop_info(pi, value, valuelen);</span><br><span class="line">        pa-&gt;serial++;</span><br><span class="line">        __futex_wake(&amp;pa-&gt;serial, INT32_MAX);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        pa = __system_property_area__;</span><br><span class="line">        <span class="keyword">if</span>(pa-&gt;count == PA_COUNT_MAX) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"> </span><br><span class="line">        pi = pa_info_array + pa-&gt;count;</span><br><span class="line">        pi-&gt;serial = (valuelen &lt;&lt; <span class="number">24</span>);</span><br><span class="line">        <span class="built_in">memcpy</span>(pi-&gt;name, name, namelen + <span class="number">1</span>);</span><br><span class="line">        <span class="built_in">memcpy</span>(pi-&gt;value, value, valuelen + <span class="number">1</span>);</span><br><span class="line"> </span><br><span class="line">        pa-&gt;toc[pa-&gt;count] =</span><br><span class="line">            (namelen &lt;&lt; <span class="number">24</span>) | (((<span class="type">unsigned</span>) pi) - ((<span class="type">unsigned</span>) pa));</span><br><span class="line"> </span><br><span class="line">        pa-&gt;count++;</span><br><span class="line">        pa-&gt;serial++;</span><br><span class="line">        __futex_wake(&amp;pa-&gt;serial, INT32_MAX);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/* If name starts with &quot;net.&quot; treat as a DNS property. */</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">strncmp</span>(<span class="string">&quot;net.&quot;</span>, name, <span class="built_in">strlen</span>(<span class="string">&quot;net.&quot;</span>)) == <span class="number">0</span>)  &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">strcmp</span>(<span class="string">&quot;net.change&quot;</span>, name) == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">       <span class="comment">/*</span></span><br><span class="line"><span class="comment">        * The &#x27;net.change&#x27; property is a special property used track when any</span></span><br><span class="line"><span class="comment">        * &#x27;net.*&#x27; property name is updated. It is _ONLY_ updated here. Its value</span></span><br><span class="line"><span class="comment">        * contains the last updated &#x27;net.*&#x27; property.</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        property_set(<span class="string">&quot;net.change&quot;</span>, name);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (persistent_properties_loaded &amp;&amp;</span><br><span class="line">            <span class="built_in">strncmp</span>(<span class="string">&quot;persist.&quot;</span>, name, <span class="built_in">strlen</span>(<span class="string">&quot;persist.&quot;</span>)) == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * Don&#x27;t write properties to disk until after we have read all default properties</span></span><br><span class="line"><span class="comment">         * to prevent them from being overwritten by default values.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        write_persistent_property(name, value);</span><br><span class="line">    &#125;</span><br><span class="line">    property_changed(name, value);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;a name=&quot;3060-1621846615933&quot;&gt;&lt;/a&gt;在系统初始化时，Android将分配一块共享内存来存储property。这是在“init”守护进程中完成的，其源代码位于：device&amp;#x2F;system&amp;#x2F;init。“init”守护进程将启动PropertyService。&lt;/p&gt;
&lt;p&gt;&lt;a name=&quot;qpdj-1679278003424&quot;&gt;&lt;/a&gt;属性服务正在“init”守护进程中运行。每个想要设置属性的客户端都需要连接到属性服务并向属性服务发送消息。属性服务将在共享内存中更新&amp;#x2F;创建属性。任何想要获取属性的客户端都可以直接从共享内存中读取属性。这提高了读取性能。&lt;/p&gt;</summary>
    
    
    
    <category term="Android技术" scheme="http://example.com/categories/Android%E6%8A%80%E6%9C%AF/"/>
    
    
  </entry>
  
  <entry>
    <title>Makefile基本语法</title>
    <link href="http://example.com/2023/11/30/Makefile%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95/"/>
    <id>http://example.com/2023/11/30/Makefile%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95/</id>
    <published>2023-11-30T09:27:44.013Z</published>
    <updated>2023-11-30T09:27:44.013Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Makefile-通过-文件生成时间-来判断文件是否有被修改过-，-进而判断文件是否需要重新编译"><a href="#Makefile-通过-文件生成时间-来判断文件是否有被修改过-，-进而判断文件是否需要重新编译" class="headerlink" title="Makefile 通过 文件生成时间 来判断文件是否有被修改过 ， 进而判断文件是否需要重新编译"></a>Makefile 通过 文件生成时间 来判断文件是否有被修改过 ， 进而判断文件是否需要重新编译</h2><ol><li>如果工程没有被编译过，则所有C文件编译并被链接</li><li>若工程中某几个文件被修改，则单独编译这几个文件，并重新链接</li><li>若头文件.h 被修改</li></ol><span id="more"></span><p><img src="/images/Makefile%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95/1.png"></p><h1 id="Make-命令-执行流程："><a href="#Make-命令-执行流程：" class="headerlink" title="Make 命令 执行流程："></a>Make 命令 执行流程：</h1><ol><li>Make 会在当前目录下按顺序寻找GNUmakefile , makefile , Makefile</li><li>若未找到则报错，若找到 则把第一个目标作为最终目标</li><li>按照堆栈顺序，以此找到每一个目标文件，判断新旧，必要时重新生成目标文件，直到生成最终目标（可执行文件）</li><li>寻找过程中，若某个依赖不存在，则直接退出，报错</li><li>标号不会被关联到，必须通过命令行参数才能执行（如 clean）</li><li>若改变了源文件或头文件，相关联的目标文件都需要重新编译，直接输入make即可</li></ol><h1 id=""><a href="#" class="headerlink" title=""></a></h1><p>.PHONY:<br>表示伪目标，如clean,用.PHONY声明后，以后有了真的clean编译命令，也不会发生错误。（伪目标clean是清空，make clean ，需要命令行输入命令执行; 编译命令clean 是如main.c 一样的）</p><h2 id="Makefile-书写简化："><a href="#Makefile-书写简化：" class="headerlink" title="Makefile 书写简化："></a>Makefile 书写简化：</h2><ol><li>相同部分用引用代替<br><img src="/images/Makefile%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95/2.png"></li><li>所有文件共同依赖的文件单独列出<br><img src="/images/Makefile%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95/3.png"></li><li>其他目标文件只列出个性依赖<br><img src="/images/Makefile%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95/4.png"></li></ol><h2 id="Makefile-设计方法"><a href="#Makefile-设计方法" class="headerlink" title="Makefile  设计方法"></a>Makefile  设计方法</h2><ol><li>隐含规则<br>2.生成多个文件</li><li>Makefile嵌套</li><li>使用变量</li><li>使用函数</li></ol><h4 id="1-隐含规则（当-make-r-则禁止使用任何隐含规则）"><a href="#1-隐含规则（当-make-r-则禁止使用任何隐含规则）" class="headerlink" title="1. 隐含规则（当 make -r 则禁止使用任何隐含规则）"></a>1. 隐含规则（当 make -r 则禁止使用任何隐含规则）</h4><p><img src="/images/Makefile%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95/5.png"><br>（例）自动扩展<br>如<br>main. : main.o  foo.o<br>cc -o foo foo.o bar.o<br>main依赖于foo.o,但是我们没有写foo.c生成foo.o  此时make会自动利用语法帮我们生成foo.o</p><h4 id="2-同时生成多个可执行文件"><a href="#2-同时生成多个可执行文件" class="headerlink" title="2. 同时生成多个可执行文件"></a>2. 同时生成多个可执行文件</h4><p><img src="/images/Makefile%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95/6.png"><br>这样可同时生成 P1 P2 P3三个可执行程序<br>（ 当makefile 命令出错时，make 会直接中断返回，在命令前加上- ，则当这条命令报错时，可以让make忽略，继续执行下面的命令）</p><h4 id="3-Makefile-嵌套执行"><a href="#3-Makefile-嵌套执行" class="headerlink" title="3.    Makefile 嵌套执行"></a>3.    Makefile 嵌套执行</h4><p><img src="/images/Makefile%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95/7.png"><br><img src="/images/Makefile%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95/8.png"><br>@代表执行时“静悄悄”，不输出执行信息</p><h4 id="4-使用变量"><a href="#4-使用变量" class="headerlink" title="4. 使用变量"></a>4. 使用变量</h4><p>Makefile中可以使用变量，类似于C语言中的宏，但值可以修改<br>变量大小写敏感<br>变量名 不应包含 ：# &#x3D; 或者空格<br>使用变量时用$(var)的形式</p><h3 id="变量的两种方式："><a href="#变量的两种方式：" class="headerlink" title="变量的两种方式："></a>变量的两种方式：</h3><h4 id="（1）-递归展开变量"><a href="#（1）-递归展开变量" class="headerlink" title="（1） 递归展开变量"></a>（1） 递归展开变量</h4><p>使用“&#x3D;”表示，可先使用，后定义<br>（弊病：有可能递归定义，造成无限展开）</p><h4 id="（2）-简单展开变量"><a href="#（2）-简单展开变量" class="headerlink" title="（2） 简单展开变量"></a>（2） 简单展开变量</h4><p>使用“：&#x3D;”表示，须先定义，再使用<br>（：&#x3D; 作用为 取当前赋值的上一个如：<br>a &#x3D; 3<br>b &#x3D; a<br>a &#x3D; 4<br>则输出b的值为3<br>）</p><h4 id="（3）系统环境变量"><a href="#（3）系统环境变量" class="headerlink" title="（3）系统环境变量"></a>（3）系统环境变量</h4><p><img src="/images/Makefile%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95/9.png"></p><h4 id="（4）-自动化变量"><a href="#（4）-自动化变量" class="headerlink" title="（4） 自动化变量"></a>（4） 自动化变量</h4><p><img src="/images/Makefile%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95/10.png"></p><h4 id="（5）-预定义变量"><a href="#（5）-预定义变量" class="headerlink" title="（5） 预定义变量"></a>（5） 预定义变量</h4><p><img src="/images/Makefile%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95/11.png"></p><h4 id="（6）函数"><a href="#（6）函数" class="headerlink" title="（6）函数"></a>（6）函数</h4><p><img src="/images/Makefile%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95/12.png"></p>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;Makefile-通过-文件生成时间-来判断文件是否有被修改过-，-进而判断文件是否需要重新编译&quot;&gt;&lt;a href=&quot;#Makefile-通过-文件生成时间-来判断文件是否有被修改过-，-进而判断文件是否需要重新编译&quot; class=&quot;headerlink&quot; title=&quot;Makefile 通过 文件生成时间 来判断文件是否有被修改过 ， 进而判断文件是否需要重新编译&quot;&gt;&lt;/a&gt;Makefile 通过 文件生成时间 来判断文件是否有被修改过 ， 进而判断文件是否需要重新编译&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;如果工程没有被编译过，则所有C文件编译并被链接&lt;/li&gt;
&lt;li&gt;若工程中某几个文件被修改，则单独编译这几个文件，并重新链接&lt;/li&gt;
&lt;li&gt;若头文件.h 被修改&lt;/li&gt;
&lt;/ol&gt;</summary>
    
    
    
    <category term="Android技术" scheme="http://example.com/categories/Android%E6%8A%80%E6%9C%AF/"/>
    
    
  </entry>
  
  <entry>
    <title>AudioTrack概述</title>
    <link href="http://example.com/2023/11/30/AudioTrack%E6%A6%82%E8%BF%B0/"/>
    <id>http://example.com/2023/11/30/AudioTrack%E6%A6%82%E8%BF%B0/</id>
    <published>2023-11-30T07:53:37.844Z</published>
    <updated>2023-11-30T07:53:37.844Z</updated>
    
    <content type="html"><![CDATA[<p> AudioTrack类用来管理、播放单个音频资源，它只能播放PCM数据，其他音频格式（aac、amr、opus、flac等）需要经过解码成PCM才能使用。</p><h2 id="运行模式"><a href="#运行模式" class="headerlink" title="运行模式"></a>运行模式</h2><p>AudioTrack可以运行两种模式：</p><blockquote><p>流模式<br>静态模式</p></blockquote><span id="more"></span><h3 id="流模式"><a href="#流模式" class="headerlink" title="流模式"></a>流模式</h3><p> 可以将连续的数据流写入AudioTrack,进行播放。播放音频数据块时，这种模式最有用。<br>如：</p><ul><li>声音持续的时间太长，无法容纳在内存中;</li><li>由于音频数据的特性（太大的采样率，每个采样的比特数…）而太大而无法容纳在内存中；</li><li>在播放先前排队的音频时收到或生成的声音。</li></ul><h3 id="静态模式"><a href="#静态模式" class="headerlink" title="静态模式"></a>静态模式</h3><p> 当处理很短的音频并且需要以最小延迟播放时，应该选择静态模式。对于经常播放的UI和游戏声音而言，静态模式将是首选方式，并且可能会产生最小的开销。</p><h2 id="缓冲区"><a href="#缓冲区" class="headerlink" title="缓冲区"></a>缓冲区</h2><p> 当创建AudioTrack时，AudioTrack将初始化其关联的音频缓冲区。在构造期间指定的此缓冲区大小决定了AudioTrack在数据用尽之前可以播放多长时间。<br> 对于静态模式，此大小是可以从中播放的最大音频数据大小。<br> 对于流模式，数据将以小于等于此缓冲区大小的块的形式写入音频接收器。</p><p>AudioTrack播放<br>这里主要说一下AudioTrack的流模式使用。<br>基本步骤</p><blockquote><p>获取最小缓冲区大小（创建AudioTrack对象所需）；<br>创建AudioTrack对象；<br>调用AudioTrack play方法，开始播放。<br>写入音频数据；<br>停止播放<br>释放对象。</p></blockquote><h3 id="1-获取最小缓冲区大小"><a href="#1-获取最小缓冲区大小" class="headerlink" title="1 获取最小缓冲区大小"></a>1 获取最小缓冲区大小</h3><p>:::tips<br>int minSize &#x3D; AudioTrack.getMinBufferSize(sampleRate,<br>        outChannelConfig, AudioFormat.ENCODING_PCM_16BIT);<br>:::</p><p>sampleRate：采样频率<br>outChannelConfig：声道配置，CHANNEL_OUT_MONO、CHANNEL_OUT_STEREO。<br>audioFormat：音频编码，AudioFormat.ENCODING_PCM_16BIT、ENCODING_PCM_8BIT.</p><h3 id="2-初始化"><a href="#2-初始化" class="headerlink" title="2 初始化"></a>2 初始化</h3><p>AudioTrack构造器已经过时，推荐使用AudioTrack.Builder进行创建AudioTrack对象。</p><p>:::tips<br>mTrack &#x3D; new AudioTrack.Builder()<br>        .setAudioAttributes(new AudioAttributes.Builder()<br>                .setUsage(AudioAttributes.USAGE_MEDIA)<br>                .setContentType(AudioAttributes.CONTENT_TYPE_MUSIC)<br>                .build())<br>        .setAudioFormat(new AudioFormat.Builder()<br>                .setEncoding(AudioFormat.ENCODING_PCM_16BIT)<br>                .setSampleRate(sampleRate)<br>                .setChannelMask(outChannelConfig)<br>                .build())<br>        .setBufferSizeInBytes(minSize)<br>        .build();<br>:::<br>创建AudioTrack对象，同时设置采样率、声道数、音频格式，缓冲区大小。</p><h3 id="3-开始播放"><a href="#3-开始播放" class="headerlink" title="3 开始播放"></a>3 开始播放</h3><p>调用play前，可以先向缓冲区写入音频数据。也可以后写。<br>:::tips<br>mTrack.play();<br>:::<br>如果不限调用write,或者write数量不足，则调用play处于欠载状态，这种情况下不会播放。只有后续将数据写入，播放才会真正开始播放。</p><h3 id="4-写入数据"><a href="#4-写入数据" class="headerlink" title="4 写入数据"></a>4 写入数据</h3><p>:::tips<br>mTrack.write(audioData.data, 0, size);<br>:::</p><p>将音频数据写入音频接收器以进行播放。<br>该方法默认情况是阻塞模式，直到所有数据都排入队列进行播放为止，并且将返回完整的传输计数。 但是，如果轨道在进入时停止或暂停，或者另一个线程通过调用停止或暂停来中断写入，或者在写入过程中发生I &#x2F; O错误，则写入可能会返回较短的传输计数。</p><blockquote><p>WRITE_BLOCKING：阻塞模式，写入将被阻塞，直到所有数据都已写入音频接收器为止。<br>WRITE_NON_BLOCKING：非阻塞模式，在排队尽可能多的音频数据以进行播放而不会阻塞，写入将立即返回。</p></blockquote><h3 id="5-停止"><a href="#5-停止" class="headerlink" title="5 停止"></a>5 停止</h3><p>调用以下两种方法都可以停止播放，并且都可以恢复播放，停止时机略有不同。</p><p>1 停止播放音频数据，调用此方法后，音频将在播放了最后写入的缓冲区后停止播放。<br>:::tips<br>mTrack.stop();<br>:::</p><p>2 暂停音频数据的播放。 未播放的数据将不会被丢弃。 随后调用play将播放此数据。<br>:::tips<br>mTrack.pause();<br>:::</p><h3 id="6-释放内存"><a href="#6-释放内存" class="headerlink" title="6 释放内存"></a>6 释放内存</h3><p>释放本地AudioRecord资源。<br>调用release（）之后，将无法再使用该对象，并且应将引用设置为null。<br>:::tips<br>mTrack.release();<br>mTrack&#x3D;null;<br>:::</p>]]></content>
    
    
    <summary type="html">&lt;p&gt; AudioTrack类用来管理、播放单个音频资源，它只能播放PCM数据，其他音频格式（aac、amr、opus、flac等）需要经过解码成PCM才能使用。&lt;/p&gt;
&lt;h2 id=&quot;运行模式&quot;&gt;&lt;a href=&quot;#运行模式&quot; class=&quot;headerlink&quot; title=&quot;运行模式&quot;&gt;&lt;/a&gt;运行模式&lt;/h2&gt;&lt;p&gt;AudioTrack可以运行两种模式：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;流模式&lt;br&gt;静态模式&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    <category term="Android技术" scheme="http://example.com/categories/Android%E6%8A%80%E6%9C%AF/"/>
    
    
  </entry>
  
  <entry>
    <title>LEETCODE 1. 两数之和</title>
    <link href="http://example.com/2023/11/30/LEETCODE-1.%20%E4%B8%A4%E6%95%B0%E4%B9%8B%E5%92%8C/"/>
    <id>http://example.com/2023/11/30/LEETCODE-1.%20%E4%B8%A4%E6%95%B0%E4%B9%8B%E5%92%8C/</id>
    <published>2023-11-30T07:53:37.844Z</published>
    <updated>2023-11-30T07:53:37.844Z</updated>
    
    <content type="html"><![CDATA[<h2 id="LEETCODE-1-两数之和"><a href="#LEETCODE-1-两数之和" class="headerlink" title="LEETCODE 1.  两数之和"></a>LEETCODE 1.  两数之和</h2><p>给定一个整数数组 <code>nums</code> 和一个整数目标值 <code>target</code>，请你在该数组中找出 和为目标值 <em><code>target</code></em> 的那两个整数，并返回它们的数组下标。<br>你可以假设每种输入只会对应一个答案。但是，数组中同一个元素在答案里不能重复出现。<br>你可以按任意顺序返回答案</p><span id="more"></span><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">e.g.</span><br><span class="line">输入：nums = [2,7,11,15], target = 9</span><br><span class="line">输出：[0,1]</span><br><span class="line">解释：因为 nums[0] + nums[1] == 9 ，返回 [0, 1] </span><br></pre></td></tr></table></figure><p>该题主要调查最简单的哈希表的概念和使用，或者两个for暴力枚举</p><p>哈希表如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">twoSum</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> target)</span> </span>&#123;</span><br><span class="line">        unordered_map&lt;<span class="type">int</span>,<span class="type">int</span>&gt;hashtable;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span> ; i&lt;nums.<span class="built_in">size</span>();++i)&#123;</span><br><span class="line">            <span class="keyword">auto</span> it = hashtable.<span class="built_in">find</span>(target-nums[i]);</span><br><span class="line">            <span class="keyword">if</span>(it != hashtable.<span class="built_in">end</span>())&#123;</span><br><span class="line">                <span class="keyword">return</span> &#123;it-&gt;second,i&#125;;</span><br><span class="line">            &#125;</span><br><span class="line">            hashtable[nums[i]] = i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span>&#123;&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;LEETCODE-1-两数之和&quot;&gt;&lt;a href=&quot;#LEETCODE-1-两数之和&quot; class=&quot;headerlink&quot; title=&quot;LEETCODE 1.  两数之和&quot;&gt;&lt;/a&gt;LEETCODE 1.  两数之和&lt;/h2&gt;&lt;p&gt;给定一个整数数组 &lt;code&gt;nums&lt;/code&gt; 和一个整数目标值 &lt;code&gt;target&lt;/code&gt;，请你在该数组中找出 和为目标值 &lt;em&gt;&lt;code&gt;target&lt;/code&gt;&lt;/em&gt; 的那两个整数，并返回它们的数组下标。&lt;br&gt;你可以假设每种输入只会对应一个答案。但是，数组中同一个元素在答案里不能重复出现。&lt;br&gt;你可以按任意顺序返回答案&lt;/p&gt;</summary>
    
    
    
    <category term="LeetCode" scheme="http://example.com/categories/LeetCode/"/>
    
    
  </entry>
  
  <entry>
    <title>LEETCODE 2. 两数相加</title>
    <link href="http://example.com/2023/11/30/LEETCODE-2.%E4%B8%A4%E6%95%B0%E7%9B%B8%E5%8A%A0/"/>
    <id>http://example.com/2023/11/30/LEETCODE-2.%E4%B8%A4%E6%95%B0%E7%9B%B8%E5%8A%A0/</id>
    <published>2023-11-30T07:53:37.844Z</published>
    <updated>2023-11-30T07:53:37.844Z</updated>
    
    <content type="html"><![CDATA[<h2 id="LEETCODE-2-两数相加"><a href="#LEETCODE-2-两数相加" class="headerlink" title="LEETCODE 2.  两数相加"></a>LEETCODE 2.  两数相加</h2><p>给你两个 <strong>非空</strong> 的链表，表示两个非负的整数。它们每位数字都是按照 <strong>逆序</strong> 的方式存储的，并且每个节点只能存储 <strong>一位</strong> 数字。</p><p>请你将两个数相加，并以相同形式返回一个表示和的链表。</p><p>你可以假设除了数字 0 之外，这两个数都不会以 0 开头。</p><span id="more"></span><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">e.g.</span><br><span class="line">输入l1 : <span class="number">2</span>-&gt;<span class="number">4</span>-&gt;<span class="number">3</span></span><br><span class="line">l2 : <span class="number">5</span>-&gt;<span class="number">6</span>-&gt;<span class="number">4</span></span><br><span class="line">输出l3 : <span class="number">7</span>-&gt;<span class="number">0</span>-&gt;<span class="number">8</span></span><br><span class="line">解释   ：<span class="number">342</span> + <span class="number">465</span> = <span class="number">807</span></span><br></pre></td></tr></table></figure><hr><p>该题逐步分析</p><p>1、由于两个链表都是逆序存储，所以对应位置的数可以直接相加</p><p>2、对于目标 链表，需要设定头指针和尾指针来进行元素位移</p><p>3、两个给定列表位数不一定相同，所以每次相加时需要判断 tail 指针所指是否非空，若为空，则要在该位赋值为0</p><p>4、注意进位carry</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode() : val(0), next(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">addTwoNumbers</span><span class="params">(ListNode* l1, ListNode* l2)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span>  carry = <span class="number">0</span>;</span><br><span class="line">        ListNode *head = <span class="literal">nullptr</span>;</span><br><span class="line">        ListNode *tail = <span class="literal">nullptr</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(l1 || l2)&#123;</span><br><span class="line">            <span class="type">int</span> n1 = l1? l1-&gt;val:<span class="number">0</span>;</span><br><span class="line">            <span class="type">int</span> n2 = l2? l2-&gt;val:<span class="number">0</span>;</span><br><span class="line">            <span class="type">int</span> sum = n1 + n2 + carry;</span><br><span class="line">            carry  = sum /<span class="number">10</span>;</span><br><span class="line">            <span class="keyword">if</span>(!head)</span><br><span class="line">                head = tail = <span class="keyword">new</span> <span class="built_in">ListNode</span>(sum % <span class="number">10</span>);</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                tail-&gt;next = <span class="keyword">new</span> <span class="built_in">ListNode</span>(sum % <span class="number">10</span>);</span><br><span class="line">                tail = tail-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(l1)  l1 = l1-&gt;next;</span><br><span class="line">            <span class="keyword">if</span>(l2)  l2 = l2-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(carry &gt; <span class="number">0</span>)</span><br><span class="line">            tail-&gt;next = <span class="keyword">new</span> <span class="built_in">ListNode</span>(<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;LEETCODE-2-两数相加&quot;&gt;&lt;a href=&quot;#LEETCODE-2-两数相加&quot; class=&quot;headerlink&quot; title=&quot;LEETCODE 2.  两数相加&quot;&gt;&lt;/a&gt;LEETCODE 2.  两数相加&lt;/h2&gt;&lt;p&gt;给你两个 &lt;strong&gt;非空&lt;/strong&gt; 的链表，表示两个非负的整数。它们每位数字都是按照 &lt;strong&gt;逆序&lt;/strong&gt; 的方式存储的，并且每个节点只能存储 &lt;strong&gt;一位&lt;/strong&gt; 数字。&lt;/p&gt;
&lt;p&gt;请你将两个数相加，并以相同形式返回一个表示和的链表。&lt;/p&gt;
&lt;p&gt;你可以假设除了数字 0 之外，这两个数都不会以 0 开头。&lt;/p&gt;</summary>
    
    
    
    <category term="LeetCode" scheme="http://example.com/categories/LeetCode/"/>
    
    
  </entry>
  
  <entry>
    <title>LEETCODE 3. 无重复字符的最长字串</title>
    <link href="http://example.com/2023/11/30/LEETCODE-3.%E6%97%A0%E9%87%8D%E5%A4%8D%E5%AD%97%E7%AC%A6%E7%9A%84%E6%9C%80%E9%95%BF%E5%AD%97%E4%B8%B2/"/>
    <id>http://example.com/2023/11/30/LEETCODE-3.%E6%97%A0%E9%87%8D%E5%A4%8D%E5%AD%97%E7%AC%A6%E7%9A%84%E6%9C%80%E9%95%BF%E5%AD%97%E4%B8%B2/</id>
    <published>2023-11-30T07:53:37.844Z</published>
    <updated>2023-11-30T07:53:37.844Z</updated>
    
    <content type="html"><![CDATA[<h2 id="LEETCODE-3-无重复字符的最长字串"><a href="#LEETCODE-3-无重复字符的最长字串" class="headerlink" title="LEETCODE 3.  无重复字符的最长字串"></a>LEETCODE 3.  无重复字符的最长字串</h2><p>给定一个字符串 <code>s</code> ，请你找出其中不含有重复字符的 <strong>最长子串</strong> 的长度。</p><span id="more"></span><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">e.g.</span><br><span class="line">输入: s = <span class="string">&quot;abcabcbb&quot;</span></span><br><span class="line">输出: <span class="number">3</span> </span><br><span class="line">解释: 因为无重复字符的最长子串是 <span class="string">&quot;abc&quot;</span>，所以其长度为 <span class="number">3</span>。</span><br><span class="line">    </span><br><span class="line">输入: s = <span class="string">&quot;bbbbb&quot;</span></span><br><span class="line">输出: <span class="number">1</span></span><br><span class="line">解释: 因为无重复字符的最长子串是 <span class="string">&quot;b&quot;</span>，所以其长度为 <span class="number">1</span>。</span><br><span class="line">    </span><br><span class="line">输入: s = <span class="string">&quot;pwwkew&quot;</span></span><br><span class="line">输出: <span class="number">3</span></span><br><span class="line">解释: 因为无重复字符的最长子串是 <span class="string">&quot;wke&quot;</span>，所以其长度为 <span class="number">3</span>。</span><br><span class="line">     请注意，你的答案必须是 子串 的长度，<span class="string">&quot;pwke&quot;</span> 是一个子序列，不是子串。</span><br></pre></td></tr></table></figure><hr><p>该题逐步分析</p><p>解决思路：滑动窗口</p><p>1、依次递增地枚举子串的起始位置，那么子串的结束位置也是递增的</p><p>2、可以指定双指针来定位字串的左右边界</p><p>3、无重复：右边界+1     有重复：左边界+1</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">lengthOfLongestSubstring</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = s.<span class="built_in">size</span>();</span><br><span class="line">        <span class="type">int</span> head=<span class="number">0</span>, tail=<span class="number">0</span>,cur_length=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(tail &lt; n)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i=head;i&lt;tail;i++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(s[i] == s[tail])&#123;</span><br><span class="line">                     head=i+<span class="number">1</span>;</span><br><span class="line">                     <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            cur_length=<span class="built_in">max</span>(cur_length,tail-head+<span class="number">1</span>);</span><br><span class="line">            tail++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> cur_length;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;LEETCODE-3-无重复字符的最长字串&quot;&gt;&lt;a href=&quot;#LEETCODE-3-无重复字符的最长字串&quot; class=&quot;headerlink&quot; title=&quot;LEETCODE 3.  无重复字符的最长字串&quot;&gt;&lt;/a&gt;LEETCODE 3.  无重复字符的最长字串&lt;/h2&gt;&lt;p&gt;给定一个字符串 &lt;code&gt;s&lt;/code&gt; ，请你找出其中不含有重复字符的 &lt;strong&gt;最长子串&lt;/strong&gt; 的长度。&lt;/p&gt;</summary>
    
    
    
    <category term="LeetCode" scheme="http://example.com/categories/LeetCode/"/>
    
    
  </entry>
  
  <entry>
    <title>MMU (个人化理解)</title>
    <link href="http://example.com/2023/11/30/MMU/"/>
    <id>http://example.com/2023/11/30/MMU/</id>
    <published>2023-11-30T07:53:37.844Z</published>
    <updated>2023-11-30T07:53:37.844Z</updated>
    
    <content type="html"><![CDATA[<h2 id="MMU-–memory-managment-unit-内存管理单元"><a href="#MMU-–memory-managment-unit-内存管理单元" class="headerlink" title="MMU –memory managment unit  内存管理单元"></a>MMU –memory managment unit  内存管理单元</h2><h2 id="三点作用："><a href="#三点作用：" class="headerlink" title="三点作用："></a>三点作用：</h2><blockquote><p>1、提供虚拟地址和物理地址的转换<br>2、对内存中各个段的访问、读写权限管理<br>3、虚拟内存，允许程序使用比物理内存更大的内存空间</p></blockquote><span id="more"></span><h3 id="Q1-为什么要引入虚拟内存？"><a href="#Q1-为什么要引入虚拟内存？" class="headerlink" title="Q1:为什么要引入虚拟内存？"></a>Q1:为什么要引入虚拟内存？</h3><blockquote><p>1、未引入虚拟内存时，所有进程直接访问物理地址，数据很容易被修改，不安全。引入虚拟内存后，实现了虚拟内存和物理内存的隔离，保障了安全性，隔离了程序，保护数据。<br>2、系统的理论最大内存容量和CPU的位数有关。32位计算机理论上最高支持4GB内存。但实际生产中有时候用不到这么大的内存，比如只用了2GB内存，这时候浪费了2GB的寻址能力。使用虚拟内存后，在CPU的视角来看模拟出了一个更大的内存，从而提高了系统可用内存的大小。 </p></blockquote><h3 id="Q2：如何实现对内存的权限管理"><a href="#Q2：如何实现对内存的权限管理" class="headerlink" title="Q2：如何实现对内存的权限管理"></a>Q2：如何实现对内存的权限管理</h3><blockquote><p>内存管理分用户层和kernel层<br>kernel层，ARM11允许控制16个域，每个域可以设定不同的权限，（读，写，可执行）<br>内存的访问权限受控于：域的权限+用户是否特权</p></blockquote><blockquote><p>域是节、大页和小页的集合。ARM结构支持16个域。对域的访问由域访问控制寄存器的两个位字段控制。因为每个字段对访问对应的域的使能非常迅速，所以整个存储器区间能很快地交换进出虚拟存储器。这里支持 2种域访问方式：  </p><p><code>客户域</code>的用户（执行程序，访问数据），被形成这个域的节或页来监督访问权限。<br><code>管理者</code>控制域的行为（域中的当前节和页，对域的访问），不被形成这个域的节或页来监督访问权限。<br>一个程序可以是一些域的客户，也是另外一些域的管理者，同时没有对其它域的访问权限。这允许对程序访问不同存储器资源的非常灵活的存储器保护  </p></blockquote><h3 id="Q3：MMU的使用"><a href="#Q3：MMU的使用" class="headerlink" title="Q3：MMU的使用"></a>Q3：MMU的使用</h3><blockquote><p>在kernel中进行make menuconfig ARCH&#x3D;arm 进行配置  </p></blockquote><blockquote><p>&#x2F;***    打开mmu功能    ***&#x2F;<br>CONFIG_MMU&#x3D;y  </p></blockquote><blockquote><p>&#x2F;***    打开内存权限管理    **&#x2F;<br>STRICT_KERNEL_RWX &#x3D;y<br>ARCH_HAS_STRICT_KERNEL_RWX&#x3D;y  </p></blockquote><h3 id="Q4：页表转换"><a href="#Q4：页表转换" class="headerlink" title="Q4：页表转换"></a>Q4：页表转换</h3><blockquote><p>LINUX OS支持三层页表，但是ARM11 只支持两层页表，故在arm架构中，二级页表 &#x3D;&#x3D; 三级页表</p></blockquote>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;MMU-–memory-managment-unit-内存管理单元&quot;&gt;&lt;a href=&quot;#MMU-–memory-managment-unit-内存管理单元&quot; class=&quot;headerlink&quot; title=&quot;MMU –memory managment unit  内存管理单元&quot;&gt;&lt;/a&gt;MMU –memory managment unit  内存管理单元&lt;/h2&gt;&lt;h2 id=&quot;三点作用：&quot;&gt;&lt;a href=&quot;#三点作用：&quot; class=&quot;headerlink&quot; title=&quot;三点作用：&quot;&gt;&lt;/a&gt;三点作用：&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;1、提供虚拟地址和物理地址的转换&lt;br&gt;2、对内存中各个段的访问、读写权限管理&lt;br&gt;3、虚拟内存，允许程序使用比物理内存更大的内存空间&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    <category term="Linux" scheme="http://example.com/categories/Linux/"/>
    
    
  </entry>
  
  <entry>
    <title>莫言-《鳄鱼》</title>
    <link href="http://example.com/2023/11/30/%E8%8E%AB%E8%A8%80-%E3%80%8A%E9%B3%84%E9%B1%BC%E3%80%8B/"/>
    <id>http://example.com/2023/11/30/%E8%8E%AB%E8%A8%80-%E3%80%8A%E9%B3%84%E9%B1%BC%E3%80%8B/</id>
    <published>2023-11-30T07:53:37.844Z</published>
    <updated>2023-11-30T07:53:37.844Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>《鳄鱼》分为四幕九场，讲述的是一位逃亡国外的腐败官员的故事。情节围绕腐败官员单无惮及其在生日派对上收到的贺礼“鳄鱼”展开：2005年无惮五十五岁生日时，做观赏鱼生意的商人老黑送他一条三十厘米长的小鳄鱼作为寿礼。了解到鳄鱼的生长取决于环境限制程度的特性，心事重重的无惮对鳄鱼产生了浓厚的兴趣。十年间，无惮身边各色人等粉墨登场，前妻巧玲欲与情人瘦马争夺无惮所居别墅的所有权；“外甥”牛布与行为艺术表演者灯罩一边从无惮身上榨取“艺术素材”，一边劝诱无惮加入他们的行列……无惮与鳄鱼越发亲近，觉得只有鳄鱼才能了解他的心声。他不断为鳄鱼更换更大的鱼缸，纵容着鳄鱼不断长大，直至成为长达四米的庞然巨兽。</p></blockquote><span id="more"></span>  <p>故事内容和寓意没有太多的感触，情节的冲突性很少，个人感觉一般。但是对其之外的一个文章细节有所感悟。主人公无惮作为一个在逃贪官，在书中展现出的形象相比身边人反而是更爱国的，并且个人也是具有人格魅力的。这种矛盾感却能让人觉得很合理。无惮在短短的四幕话剧中，无数次提到了自己对故土的想念，以及自我嘲弄，一口一个愧对人民，不配当人。 他难道是真心的呢？ 无惮此刻身在美国，身边又都是同流之辈，完全没必要再去装给别人看，所以我倾向于他的这种情绪不是装的，但也不是真的，他不是真心觉得自己做错了，愧对人民和国家，如果让他再来一次，我相信他依然会选择当一个贪官。</p><p>无惮的这种行为，我的理解是 借用自嘲和自我贬低来企图减轻一点自己的罪恶感，同时又能获得道德精神上的崇高感。所有知道 “ 好 ” 而选择 “ 坏 ” 的人或多或少都如此。他用 “ 造桥让你们贪了，但是质量必须要好 ”这种故事来标榜自己是一个复杂的好官，用现在流行的形容词来说，他是一个表演型人格，但是他不演给其他人，而是演给自己。这是坏的不那么纯粹的人惯用的伎俩。他没有办法打心底里说出“人不为己，天诛地灭”，“我只管我自己舒服，他人与我何干”这种话，因为他知道对的东西长什么样，更清楚他就是不对。无惮是有内心世界的，他随时都在和自己对话，这种对话时刻折磨着他，也就是老话说的，良心的谴责。但也仅仅是自我满足一类的谴责罢了。没错，谴责也可以自我满足，你让他真回国接受审判，他是万万不肯的。这种性格的人，批评与谴责远比赞美更加来的让他心安。</p><p>这种人是很可悲的，他清楚知道自己的问题在哪，清楚知道自己想要什么，但是他永远也到不了。他被自己的表演型人格束缚住了，他甚至永远以为自己走在更加复杂，无奈却又正确的路上，他再也找不到 “ 真 ”了，对于他而言这远比其他事情来得更可悲。读过书，受过教育的人，思想上容易变得 “ 精致 ”，这种精致来源于读过书，又没读过很多书。他们的 “ 精致 ”更像是一种自以为是，口感好像劣质酒精夹杂着热塑料味儿， 尖锐又刺鼻。更可怕的是，这种三观一旦形成，是根深蒂固的。动人观念如刨人祖坟。他们自以为是，再听不见只言片语。</p><p>光提出问题不解决多少有点耍流氓的嫌疑。我的办法是，“ 真 ”一点，逼着自己纯粹一点，用他人之言来骂醒自己，让自己变成一个纯粹的人，不管好的还是坏的，都纯粹一点，不要把自己放在火堆上慢烤，拷上八十载，把生活过成人间炼狱。</p>]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;《鳄鱼》分为四幕九场，讲述的是一位逃亡国外的腐败官员的故事。情节围绕腐败官员单无惮及其在生日派对上收到的贺礼“鳄鱼”展开：2005年无惮五十五岁生日时，做观赏鱼生意的商人老黑送他一条三十厘米长的小鳄鱼作为寿礼。了解到鳄鱼的生长取决于环境限制程度的特性，心事重重的无惮对鳄鱼产生了浓厚的兴趣。十年间，无惮身边各色人等粉墨登场，前妻巧玲欲与情人瘦马争夺无惮所居别墅的所有权；“外甥”牛布与行为艺术表演者灯罩一边从无惮身上榨取“艺术素材”，一边劝诱无惮加入他们的行列……无惮与鳄鱼越发亲近，觉得只有鳄鱼才能了解他的心声。他不断为鳄鱼更换更大的鱼缸，纵容着鳄鱼不断长大，直至成为长达四米的庞然巨兽。&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    <category term="读书" scheme="http://example.com/categories/%E8%AF%BB%E4%B9%A6/"/>
    
    
  </entry>
  
  <entry>
    <title>提问的智慧（How To Ask Questions The Smart Way）</title>
    <link href="http://example.com/2023/11/30/%E5%A6%82%E4%BD%95%E6%8F%90%E9%97%AE/"/>
    <id>http://example.com/2023/11/30/%E5%A6%82%E4%BD%95%E6%8F%90%E9%97%AE/</id>
    <published>2023-11-30T07:53:37.844Z</published>
    <updated>2023-11-30T07:53:37.844Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>对于程序员来说，提问的方式往往和解决方法同样重要，一个准确，详实，有准备的问题往往能更快地得到他人的帮助<br>此处转载一篇关于如何提问的经典文章，在我学习过程中使我受益良多<br>Copyright © 2001,2006,2014 Eric S. Raymond, Rick Moen<br>英文原版 ： <a href="http://www.catb.org/~esr/faqs/smart-questions.html">http://www.catb.org/~esr/faqs/smart-questions.html</a><br>繁体中文版 ： <a href="https://github.com/ryanhanwu/How-To-Ask-Questions-The-Smart-Way/blob/main/README.md">https://github.com/ryanhanwu/How-To-Ask-Questions-The-Smart-Way/blob/main/README.md</a></p></blockquote><span id="more"></span><!-- ## 目录- [目录](#目录)- [声明](#声明)- [简介](#简介)- [在提问之前](#在提问之前)- [当你提问时](#当你提问时)  - [慎选提问的论坛](#慎选提问的论坛)  - [Stack Overflow](#stack-overflow)  - [网站和 IRC 论坛](#网站和-irc-论坛)  - [第二步，使用项目邮件列表](#第二步使用项目邮件列表)  - [使用有意义且描述明确的标题](#使用有意义且描述明确的标题)  - [使问题容易回复](#使问题容易回复)  - [使用清晰、正确、精准且合乎语法的语句](#使用清晰正确精准且合乎语法的语句)  - [使用易于读取且标准的文件格式发送问题](#使用易于读取且标准的文件格式发送问题)  - [精确地描述问题并言之有物](#精确地描述问题并言之有物)  - [话不在多而在精](#话不在多而在精)  - [别动辄声称找到 Bug](#别动辄声称找到-bug)  - [低声下气不能代替你的功课](#低声下气不能代替你的功课)  - [描述问题症状而非你的猜测](#描述问题症状而非你的猜测)  - [按发生时间先后列出问题症状](#按发生时间先后列出问题症状)  - [描述目标而不是过程](#描述目标而不是过程)  - [别要求使用私人电邮回复](#别要求使用私人电邮回复)  - [清楚明确地表达你的问题以及需求](#清楚明确地表达你的问题以及需求)  - [询问有关代码的问题时](#询问有关代码的问题时)  - [别把自己家庭作业的问题贴上来](#别把自己家庭作业的问题贴上来)  - [去掉无意义的提问句](#去掉无意义的提问句)  - [即使你很急也不要在标题写`紧急`](#即使你很急也不要在标题写紧急)  - [礼多人不怪，而且有时还很有帮助](#礼多人不怪而且有时还很有帮助)  - [问题解决后，加个简短的补充说明](#问题解决后加个简短的补充说明)- [如何解读答案](#如何解读答案)  - [RTFM 和 STFW：如何知道你已完全搞砸了](#rtfm-和-stfw如何知道你已完全搞砸了)  - [如果还是搞不懂](#如果还是搞不懂)  - [处理无礼的回应](#处理无礼的回应)- [如何避免扮演失败者](#如何避免扮演失败者)- [不该问的问题](#不该问的问题)- [好问题与蠢问题](#好问题与蠢问题)- [如果得不到回答](#如果得不到回答)- [如何更好地回答问题](#如何更好地回答问题)- [相关资源](#相关资源)- [鸣谢](#鸣谢) --><h2 id="声明"><a href="#声明" class="headerlink" title="声明"></a>声明</h2><p>许多项目在他们网站的帮助文档中链接了本指南。这很好，这正是我们想要的用途。但如果你是该项目管理员并试图创建指向本指南的超链接，请在超链接附近的显著位置注明：</p><p><strong>本指南不提供此项目的实际支持服务！</strong></p><p>我们已经深刻领教到缺少上述声明所带来的痛苦：我们将不停地被那些认为发布这本指南就意味着有责任解决世上所有技术问题的傻瓜苦苦纠缠。</p><p>如果你因寻求某些帮助而阅读本指南，并在离开时还觉得可以从本文作者这里得到直接帮助，那你就是我们之前说的那些傻瓜之一。别问我们问题，我们只会忽略你。我们在这本指南中想教你如何从那些真正懂得你所遇到的软件或硬件问题的人处取得协助，而 99% 的情况下那不会是我们。除非你确定本指南的作者之一刚好是你所遇到的问题领域的专家，否则请不要打扰我们，这样大家都会开心一点。</p><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>在<a href="http://www.catb.org/~esr/faqs/hacker-howto.html">黑客</a>的世界里，当你拋出一个技术问题时，最终是否能得到有用的回答，往往取决于你所提问和追问的方式。本指南将教你如何正确地提问以获得你满意的答案。</p><p>现在开源（Open Source）软件已经相当盛行，您通常可以从其他更有经验的用户那里获得与黑客一样好的答案，这是件<strong>好事</strong>；和黑客相比，用户们往往对那些新手常遇到的问题更宽容一些。尽管如此，以我们在此推荐的方式对待这些有经验的用户通常也是从他们那里获得有用答案的最有效方式。</p><p>首先你应该明白，黑客们喜爱有挑战性的问题，或者能激发他们思维的好问题。如果我们并非如此，那我们也不会成为你想询问的对象。如果你给了我们一个值得反复咀嚼玩味的好问题，我们自会对你感激不尽。好问题是激励，是厚礼。好问题可以提高我们的理解力，而且通常会暴露我们以前从没意识到或者思考过的问题。对黑客而言，“好问题！”是诚挚的大力称赞。</p><p>尽管如此，黑客们有着蔑视或傲慢面对简单问题的坏名声，这有时让我们看起来对新手、无知者似乎较有敌意，但其实不是那样的。</p><p>我们不讳言我们对那些不愿思考、或者在发问前不做他们该做的事的人的蔑视。那些人是时间杀手 —— 他们只想索取，从不付出，消耗我们可用在更有趣的问题或更值得回答的人身上的时间。我们称这样的人为 <code>失败者（撸瑟）</code> （由于历史原因，我们有时把它拼作 <code>lusers</code>）。</p><p>我们意识到许多人只是想使用我们写的软件，他们对学习技术细节没有兴趣。对大多数人而言，电脑只是种工具，是种达到目的的手段而已。他们有自己的生活并且有更要紧的事要做。我们认可这点，也从不指望每个人都对这些让我们着迷的技术问题感兴趣。尽管如此，我们只为那些真正有兴趣并愿意积极参与问题解决的人调整回答问题的风格。这点不会变，也不该变：否则，我们就是在最擅长的事情上降低效率。</p><p>我们（在很大程度上）是自愿的，从繁忙的生活中抽出时间来解答疑惑，而且时常被提问淹没。所以我们无情地滤掉一些话题，特别是拋弃那些看起来像失败者的家伙，以便更高效地利用时间来回答<code>赢家（winner）</code>的问题。</p><p>如果你厌恶我们的态度，高高在上，或过于傲慢，不妨也设身处地想想。我们并没有要求你向我们屈服 —— 事实上，我们大多数人非常乐意与你平等地交流，只要你付出小小努力来满足基本要求，我们就会欢迎你加入我们的文化。但让我们帮助那些不愿意帮助自己的人是没有效率的。无知没有关系，但装白痴就是不行。</p><p>所以，你不必在技术上很在行才能吸引我们的注意，但你必须表现出能引导你变得在行的特质 —— 机敏、有想法、善于观察、乐于主动参与解决问题。如果你做不到这些使你与众不同的事情，我们建议你花点钱找家商业公司签个技术支持服务合同，而不是要求黑客个人无偿地帮助你。</p><p>如果你决定向我们求助，当然你也不希望被视为失败者，更不愿成为失败者中的一员。能立刻得到快速并有效答案的最好方法，就是像赢家那样提问 —— 聪明、自信、有解决问题的思路，只是偶尔在特定的问题上需要获得一点帮助。</p><p>（欢迎对本指南提出改进意见。你可以把你的建议发送至 <a href="esr@thyrsus.com">esr@thyrsus.com</a> 或 <a href="respond-auto@linuxmafia.com">respond-auto@linuxmafia.com</a>。然而请注意，本文并非<a href="http://www.ietf.org/rfc/rfc1855.txt">网络礼节</a>的通用指南，而我们通常会拒绝无助于在技术论坛得到有用答案的建议）。</p><h2 id="在提问之前"><a href="#在提问之前" class="headerlink" title="在提问之前"></a>在提问之前</h2><p>在你准备要通过电子邮件、新闻群组或者聊天室提出技术问题前，请先做到以下事情：</p><ol><li>尝试在你准备提问的论坛的旧文章中搜索答案。</li><li>尝试上网搜索以找到答案。</li><li>尝试阅读手册以找到答案。</li><li>尝试阅读常见问题文件（FAQ）以找到答案。</li><li>尝试自己检查或试验以找到答案。</li><li>向你身边的强者朋友打听以找到答案。</li><li>如果你是程序开发者，请尝试阅读源代码以找到答案。</li></ol><p>当你提出问题的时候，请先表明你已经做了上述的努力；这将有助于树立你并不是一个不劳而获且浪费别人的时间的提问者。如果你能一并表达在做了上述努力的过程中所<strong>学到</strong>的东西会更好，因为我们更乐于回答那些表现出能从答案中学习的人的问题。</p><p>运用某些策略，比如先用 Google 搜索你所遇到的各种错误信息（搜索 <a href="http://groups.google.com/">Google 论坛</a>和网页），这样很可能直接就找到了能解决问题的文件或邮件列表线索。即使没有结果，在邮件列表或新闻组寻求帮助时加上一句 <code>我在 Google 中搜过下列句子但没有找到什么有用的东西</code> 也是件好事，即使它只是表明了搜索引擎不能提供哪些帮助。这么做（加上搜索过的字串）也让遇到相似问题的其他人能被搜索引擎引导到你的提问来。</p><p>别着急，不要指望几秒钟的 Google 搜索就能解决一个复杂的问题。在向专家求助之前，再阅读一下常见问题文件（FAQ）、放轻松、坐得舒服一些，再花点时间思考一下这个问题。相信我们，他们能从你的提问看出你做了多少阅读与思考，如果你是有备而来，将更有可能得到解答。不要将所有问题一股脑拋出，只因你的第一次搜索没有找到答案（或者找到太多答案）。</p><p>准备好你的问题，再将问题仔细地思考过一遍，因为草率的发问只能得到草率的回答，或者根本得不到任何答案。越是能表现出在寻求帮助前你为解决问题所付出的努力，你越有可能得到实质性的帮助。</p><p>小心别问错了问题。如果你的问题基于错误的假设，某个普通黑客（J. Random Hacker）多半会一边在心里想着<code>蠢问题…</code>，一边用无意义的字面解释来答复你，希望着你会从问题的回答（而非你想得到的答案）中汲取教训。</p><p>绝不要自以为<strong>够格</strong>得到答案，你没有；你并没有。毕竟你没有为这种服务支付任何报酬。你将会是自己去<strong>挣到</strong>一个答案，靠提出有内涵的、有趣的、有思维激励作用的问题 —— 一个有潜力能贡献社区经验的问题，而不仅仅是被动地从他人处索取知识。</p><p>另一方面，表明你愿意在找答案的过程中做点什么是一个非常好的开端。<code>谁能给点提示？</code>、<code>我的这个例子里缺了什么？</code>以及<code>我应该检查什么地方</code>比<code>请把我需要的确切的过程贴出来</code>更容易得到答复。因为你表现出只要有人能指个正确方向，你就有完成它的能力和决心。</p><h2 id="当你提问时"><a href="#当你提问时" class="headerlink" title="当你提问时"></a>当你提问时</h2><h3 id="慎选提问的论坛"><a href="#慎选提问的论坛" class="headerlink" title="慎选提问的论坛"></a>慎选提问的论坛</h3><p>小心选择你要提问的场合。如果你做了下述的事情，你很可能被忽略掉或者被看作失败者：</p><ul><li>在与主题不合的论坛上贴出你的问题。</li><li>在探讨进阶技术问题的论坛张贴非常初级的问题；反之亦然。</li><li>在太多的不同新闻群组上重复转贴同样的问题（cross-post）。</li><li>向既非熟人也没有义务解决你问题的人发送私人电邮。</li></ul><p>黑客会剔除掉那些搞错场合的问题，以保护他们沟通的渠道不被无关的东西淹没。你不会想让这种事发生在自己身上的。</p><p>因此，第一步是找到对的论坛。再说一次，Google 和其它搜索引擎还是你的朋友，用它们来找到与你遭遇到困难的软硬件问题最相关的网站。通常那儿都有常见问题（FAQ）、邮件列表及相关说明文件的链接。如果你的努力（包括<strong>阅读</strong> FAQ）都没有结果，网站上也许还有报告 Bug（Bug-reporting）的流程或链接，如果是这样，链过去看看。</p><p>向陌生的人或论坛发送邮件最可能是风险最大的事情。举例来说，别假设一个提供丰富内容的网页的作者会想充当你的免费顾问。不要对你的问题是否会受到欢迎做太乐观的估计 —— 如果你不确定，那就向别处发送，或者压根别发。</p><p>在选择论坛、新闻群组或邮件列表时，别太相信它的名字，先看看 FAQ 或者许可书以弄清楚你的问题是否切题。发文前先翻翻已有的话题，这样可以让你感受一下那里的文化。事实上，事先在新闻组或邮件列表的历史记录中搜索与你问题相关的关键词是个极好的主意，也许这样就找到答案了。即使没有，也能帮助你归纳出更好的问题。</p><p>别像机关枪似的一次“扫射”所有的帮助渠道，这就像大喊大叫一样会使人不快。要一个一个地来。</p><p>搞清楚你的主题！最典型的错误之一是在某种致力于跨平台可移植的语言、套件或工具的论坛中提关于 Unix 或 Windows 操作系统程序界面的问题。如果你不明白为什么这是大错，最好在搞清楚这之间差异之前什么也别问。</p><p>一般来说，在仔细挑选的公共论坛中提问，会比在私有论坛中提同样的问题更容易得到有用的回答。有几个理由可以支持这点，一是看潜在的回复者有多少，二是看观众有多少。黑客较愿意回答那些能帮助到许多人的问题。</p><p>可以理解的是，老练的黑客和一些热门软件的作者正在接受过多的错发信息。就像那根最后压垮骆驼背的稻草一样，你的加入也有可能使情况走向极端 —— 已经好几次了，一些热门软件的作者由于涌入其私人邮箱的大量不堪忍受的无用邮件而不再提供支持。</p><h3 id="Stack-Overflow"><a href="#Stack-Overflow" class="headerlink" title="Stack Overflow"></a>Stack Overflow</h3><p>搜索，<em>然后</em>在 Stack Exchange 问。</p><p>近年来，Stack Exchange 社区已经成为回答技术及其他问题的主要渠道，尤其是那些开放源码的项目。</p><p>因为 Google 索引是即时的，在看 Stack Exchange 之前先在 Google 搜索。有很高的几率某人已经问了一个类似的问题，而且 Stack Exchange 网站们往往会是搜索结果中最前面几个。如果你在 Google 上没有找到任何答案，你再到特定相关主题的网站去找。用标签（Tag）搜索能让你更缩小你的搜索结果。</p><p>如果你还是找不到任何对你的问题有用的内容，请把你的问题发在与它最相关的网站上。提问的时候请善用格式化工具，尤其注意为代码添加格式，并且添加相关的标签（特别是编程语言、操作系统或库&#x2F;包的名称）。当有人要求你提供更多相关信息时，请编辑你的贴子来补充它们[译注：而不是发一个回帖或回答！]。如果你觉得一个答案对你有帮助，点击向上的箭头来为它投票；如果一个答案提供了问题的正确解决方案，点击投票按钮下方的对勾来将它标记为正解。</p><p>Stack Exchange 已经成长到<a href="https://stackexchange.com/sites">超过一百个网站</a>，以下是最常用的几个站：</p><ul><li>Super User 是问一些通用的电脑问题，如果你的问题跟代码或是写程序无关，只是一些网络连线之类的，请到这里。</li><li>Stack Overflow 是问写程序有关的问题。</li><li>Server Fault 是问服务器和网管相关的问题。</li></ul><h3 id="网站和-IRC-论坛"><a href="#网站和-IRC-论坛" class="headerlink" title="网站和 IRC 论坛"></a>网站和 IRC 论坛</h3><p>本地的用户群组（user group），或者你所用的 Linux 发行版本也许正在宣传他们的网页论坛或 IRC 频道，并提供新手帮助（在一些非英语国家，新手论坛很可能还是邮件列表），这些都是开始提问的好地方，特别是当你觉得遇到的也许只是相对简单或者很普通的问题时。有广告赞助的 IRC 频道是公开欢迎提问的地方，通常可以即时得到回应。</p><p>事实上，如果程序出的问题只发生在特定 Linux 发行版提供的版本（这很常见），最好先去该发行版的论坛或邮件列表中提问，再到程序本身的论坛或邮件列表提问。（否则）该项目的黑客可能仅仅回复“使用<strong>我们的</strong>版本”。</p><p>在任何论坛发文以前，先确认一下有没有搜索功能。如果有，就试着搜索一下问题的几个关键词，也许这会有帮助。如果在此之前你已做过通用的网页搜索（你也该这样做），还是再搜索一下论坛，搜索引擎有可能没来得及索引此论坛的全部内容。</p><p>通过论坛或 IRC 频道来提供用户支持服务有增长的趋势，电子邮件则大多为项目开发者间的交流而保留。所以最好先在论坛或 IRC 中寻求与该项目相关的协助。</p><p>在使用 IRC 的时候，首先最好不要发布很长的问题描述，有些人称之为频道洪水。最好通过一句话的问题描述来开始聊天。</p><h3 id="第二步，使用项目邮件列表"><a href="#第二步，使用项目邮件列表" class="headerlink" title="第二步，使用项目邮件列表"></a>第二步，使用项目邮件列表</h3><p>当某个项目提供开发者邮件列表时，要向列表而不是其中的个别成员提问，即使你确信他能最好地回答你的问题。查一查项目的文件和首页，找到项目的邮件列表并使用它。有几个很好的理由支持我们采用这种办法：</p><ul><li>任何好到需要向个别开发者提出的问题，也将对整个项目群组有益。反之，如果你认为自己的问题对整个项目群组来说太愚蠢，那这也不能成为骚扰个别开发者的理由。</li><li>向列表提问可以分散开发者的负担，个别开发者（尤其是项目领导人）也许太忙以至于没法回答你的问题。</li><li>大多数邮件列表都会被存档，那些被存档的内容将被搜索引擎索引。如果你向列表提问并得到解答，将来其他人可以通过网页搜索找到你的问题和答案，也就不用再次发问了。</li><li>如果某些问题经常被问到，开发者可以利用此信息来改进说明文件或软件本身，以使其更清楚。如果只是私下提问，就没有人能看到最常见问题的完整场景。</li></ul><p>如果一个项目既有“用户”也有“开发者”（或“黑客”）邮件列表或论坛，而你又不会动到那些源代码，那么就向“用户”列表或论坛提问。不要假设自己会在开发者列表中受到欢迎，那些人多半会将你的提问视为干扰他们开发的噪音。</p><p>然而，如果你<strong>确信</strong>你的问题很特别，而且在“用户”列表或论坛中几天都没有回复，可以试试前往“开发者”列表或论坛发问。建议你在张贴前最好先暗地里观察几天以了解那里的行事方式（事实上这是参与任何私有或半私有列表的好主意）</p><p>如果你找不到一个项目的邮件列表，而只能查到项目维护者的电子邮件地址，尽管向他发信。即使是在这种情况下，也别假设（项目）邮件列表不存在。在你的电子邮件中，请陈述你已经试过但没有找到合适的邮件列表，也提及你不反对将自己的邮件转发给他人（许多人认为，即使没什么秘密，私人电子邮件也不应该被公开。通过允许将你的电子邮件转发他人，你给了相应人员处置你邮件的选择）。</p><h3 id="使用有意义且描述明确的标题"><a href="#使用有意义且描述明确的标题" class="headerlink" title="使用有意义且描述明确的标题"></a>使用有意义且描述明确的标题</h3><p>在邮件列表、新闻群组或论坛中，大约 50 字以内的标题是抓住资深专家注意力的好机会。别用喋喋不休的<code>帮帮忙</code>、<code>跪求</code>、<code>急</code>（更别说<code>救命啊！！！！</code>这样让人反感的话，用这种标题会被条件反射式地忽略）来浪费这个机会。不要妄想用你的痛苦程度来打动我们，而应该是在这点空间中使用极简单扼要的描述方式来提出问题。</p><p>一个好标题范例是<code>目标 —— 差异</code>式的描述，许多技术支持组织就是这样做的。在<code>目标</code>部分指出是哪一个或哪一组东西有问题，在<code>差异</code>部分则描述与期望的行为不一致的地方。</p><blockquote><p>蠢问题：救命啊！我的笔记本电脑不能正常显示了！</p></blockquote><blockquote><p>聪明问题：X.org 6.8.1 的鼠标指针会变形，某牌显卡 MV1005 芯片组。</p></blockquote><blockquote><p>更聪明问题：X.org 6.8.1 的鼠标指针，在某牌显卡 MV1005 芯片组环境下 - 会变形。</p></blockquote><p>编写<code>目标 —— 差异</code> 式描述的过程有助于你组织对问题的细致思考。是什么被影响了？ 仅仅是鼠标指针或者还有其它图形？只在 X.org 的 X 版中出现？或只是出现在 6.8.1 版中？ 是针对某牌显卡芯片组？或者只是其中的 MV1005 型号？ 一个黑客只需瞄一眼就能够立即明白你的环境<strong>和</strong>你遇到的问题。</p><p>总而言之，请想像一下你正在一个只显示标题的存档讨论串（Thread）索引中查寻。让你的标题更好地反映问题，可使下一个搜索类似问题的人能够关注这个讨论串，而不用再次提问相同的问题。</p><p>如果你想在回复中提出问题，记得要修改内容标题，以表明你是在问一个问题， 一个看起来像 <code>Re: 测试</code> 或者 <code>Re: 新 bug</code> 的标题很难引起足够重视。另外，在不影响连贯性之下，适当引用并删减前文的内容，能给新来的读者留下线索。</p><p>对于讨论串，不要直接点击回复来开始一个全新的讨论串，这将限制你的观众。因为有些邮件阅读程序，比如 mutt ，允许用户按讨论串排序并通过折叠讨论串来隐藏消息，这样做的人永远看不到你发的消息。</p><p>仅仅改变标题还不够。mutt 和其它一些邮件阅读程序还会检查邮件标题以外的其它信息，以便为其指定讨论串。所以宁可发一个全新的邮件。</p><p>在网页论坛上，好的提问方式稍有不同，因为讨论串与特定的信息紧密结合，并且通常在讨论串外就看不到里面的内容，故通过回复提问，而非改变标题是可接受的。不是所有论坛都允许在回复中出现分离的标题，而且这样做了基本上没有人会去看。不过，通过回复提问，这本身就是暧昧的做法，因为它们只会被正在查看该标题的人读到。所以，除非你<strong>只想</strong>在该讨论串当前活跃的人群中提问，不然还是另起炉灶比较好。</p><h3 id="使问题容易回复"><a href="#使问题容易回复" class="headerlink" title="使问题容易回复"></a>使问题容易回复</h3><p>以<code>请将你的回复发送到……</code>来结束你的问题多半会使你得不到回答。如果你觉得花几秒钟在邮件客户端设置一下回复地址都麻烦，我们也觉得花几秒钟思考你的问题更麻烦。如果你的邮件程序不支持这样做，<a href="http://linuxmafia.com/faq/Mail/muas.html">换个好点的</a>；如果是操作系统不支持这种邮件程序，也换个好点的。</p><p>在论坛，要求通过电子邮件回复是非常无礼的，除非你认为回复的信息可能比较敏感（有人会为了某些未知的原因，只让你而不是整个论坛知道答案）。如果你只是想在有人回复讨论串时得到电子邮件提醒，可以要求网页论坛发送给你。几乎所有论坛都支持诸如<code>追踪此讨论串</code>、<code>有回复时发送邮件提醒</code>等功能。</p><h3 id="使用清晰、正确、精准且合乎语法的语句"><a href="#使用清晰、正确、精准且合乎语法的语句" class="headerlink" title="使用清晰、正确、精准且合乎语法的语句"></a><a name="使用清晰、正确、精准且合乎语法的语句">使用清晰、正确、精准且合乎语法的语句</a></h3><p>我们从经验中发现，粗心的提问者通常也会粗心地写程序与思考（我敢打包票）。回答粗心大意者的问题很不值得，我们宁愿把时间耗在别处。</p><p>正确的拼写、标点符号和大小写是很重要的。一般来说，如果你觉得这样做很麻烦，不想在乎这些，那我们也觉得麻烦，不想在乎你的提问。花点额外的精力斟酌一下字句，用不着太僵硬与正式 —— 事实上，黑客文化很看重能准确地使用非正式、俚语和幽默的语句。但它<strong>必须很</strong>准确，而且有迹象表明你是在思考和关注问题。</p><p>正确地拼写、使用标点和大小写，不要将<code>its</code>混淆为<code>it&#39;s</code>，<code>loose</code>搞成<code>lose</code>或者将<code>discrete</code>弄成<code>discreet</code>。不要<strong>全部用大写</strong>，这会被视为无礼的大声嚷嚷（全部小写也好不到哪去，因为不易阅读。<a href="http://en.wikipedia.org/wiki/Alan_Cox">Alan Cox</a> 也许可以这样做，但你不行）。</p><p>更白话的说，如果你写得像是个半文盲[译注：<a href="http://zh.wikipedia.org/wiki/%E5%B0%8F%E7%99%BD">小白</a>]，那多半得不到理睬。也不要使用即时通信中的简写或<a href="http://zh.wikipedia.org/wiki/%E7%81%AB%E6%98%9F%E6%96%87">火星文</a>，如将<code>的</code>简化为<code>d</code>会使你看起来像一个为了少打几个键而省字的小白。更糟的是，如果像个小孩似地鬼画符那绝对是在找死，可以肯定没人会理你（或者最多是给你一大堆指责与挖苦）。</p><p>如果在使用非母语的论坛提问，你可以犯点拼写和语法上的小错，但决不能在思考上马虎（没错，我们通常能弄清两者的分别）。同时，除非你知道回复者使用的语言，否则请使用英语书写。繁忙的黑客一般会直接删除用他们看不懂的语言写的消息。在网络上英语是通用语言，用英语书写可以将你的问题在尚未被阅读就被直接删除的可能性降到最低。</p><p>如果英文是你的外语（Second language），提示潜在回复者你有潜在的语言困难是很好的：<br>[译注：以下附上原文以供使用]</p><blockquote><p>English is not my native language; please excuse typing errors.</p></blockquote><ul><li>英文不是我的母语，请原谅我的错字或语法。</li></ul><blockquote><p>If you speak $LANGUAGE, please email&#x2F;PM me;<br>I may need assistance translating my question.</p></blockquote><ul><li>如果你说<strong>某语言</strong>，请向我发电邮&#x2F;私信；</li><li>我需要有人协助我翻译我的问题。</li></ul><blockquote><p>I am familiar with the technical terms,<br>but some slang expressions and idioms are difficult for me.</p></blockquote><ul><li>我对技术名词很熟悉，但对于俗语或是特别用法不甚了解。</li></ul><blockquote><p>I’ve posted my question in $LANGUAGE and English.<br>I’ll be glad to translate responses, if you only use one or the other.</p></blockquote><ul><li>我把我的问题用<strong>某语言</strong>和英文写出来。</li><li>如果你只用其中的一种语言回答，我会乐意将回复翻译成为你使用的语言。</li></ul><h3 id="使用易于读取且标准的文件格式发送问题"><a href="#使用易于读取且标准的文件格式发送问题" class="headerlink" title="使用易于读取且标准的文件格式发送问题"></a>使用易于读取且标准的文件格式发送问题</h3><p>如果你人为地将问题搞得难以阅读，它多半会被忽略，人们更愿读易懂的问题，所以：</p><ul><li>使用纯文字而不是 HTML (<a href="http://archive.birdhouse.org/etc/evilmail.html">关闭 HTML</a> 并不难）。</li><li>使用 MIME 附件通常是可以的，前提是真正有内容（譬如附带的源代码或 patch），而不仅仅是邮件程序生成的模板（譬如只是信件内容的拷贝）。</li><li>不要发送一段文字只是一行句子但自动换行后会变成多行的邮件（这使得回复部分内容非常困难）。设想你的读者是在 80 个字符宽的终端机上阅读邮件，最好设置你的换行分割点小于 80 字。</li><li>但是，对一些特殊的文件<strong>不要</strong>设置固定宽度（譬如日志文件拷贝或会话记录）。数据应该原样包含，让回复者有信心他们看到的是和你看到的一样的东西。</li><li>在英语论坛中，不要使用<code>Quoted-Printable</code> MIME 编码发送消息。这种编码对于张贴非 ASCII 语言可能是必须的，但很多邮件程序并不支持这种编码。当它们处理换行时，那些文本中四处散布的<code>=20</code>符号既难看也分散注意力，甚至有可能破坏内容的语意。</li><li>绝对，<strong>永远</strong>不要指望黑客们阅读使用封闭格式编写的文档，像微软公司的 Word 或 Excel 文件等。大多数黑客对此的反应就像有人将还在冒热气的猪粪倒在你家门口时你的反应一样。即便他们能够处理，他们也很厌恶这么做。</li><li>如果你从使用 Windows 的电脑发送电子邮件，关闭微软愚蠢的<code>智能引号</code>功能 （从[选项] &gt; [校订] &gt; [自动校正选项]，勾选掉<code>智能引号</code>单选框），以免在你的邮件中到处散布垃圾字符。</li><li>在论坛，勿滥用<code>表情符号</code>和<code>HTML</code>功能（当它们提供时）。一两个表情符号通常没有问题，但花哨的彩色文本倾向于使人认为你是个无能之辈。过滥地使用表情符号、色彩和字体会使你看来像个傻笑的小姑娘。这通常不是个好主意，除非你只是对性而不是对答案感兴趣。</li></ul><p>如果你使用图形用户界面的邮件程序（如微软公司的 Outlook 或者其它类似的），注意它们的默认设置不一定满足这些要求。大多数这类程序有基于选单的<code>查看源代码</code>命令，用它来检查发送文件夹中的邮件，以确保发送的是纯文本文件同时没有一些奇怪的字符。</p><h3 id="精确地描述问题并言之有物"><a href="#精确地描述问题并言之有物" class="headerlink" title="精确地描述问题并言之有物"></a>精确地描述问题并言之有物</h3><ul><li>仔细、清楚地描述你的问题或 Bug 的症状。</li><li>描述问题发生的环境（机器配置、操作系统、应用程序、以及相关的信息），提供经销商的发行版和版本号（如：<code>Fedora Core 4</code>、<code>Slackware 9.1</code>等）。</li><li>描述在提问前你是怎样去研究和理解这个问题的。</li><li>描述在提问前为确定问题而采取的诊断步骤。</li><li>描述最近做过什么可能相关的硬件或软件变更。</li><li>尽可能地提供一个可以<code>重现这个问题的可控环境</code>的方法。</li></ul><p>尽量去揣测一个黑客会怎样反问你，在你提问之前预先将黑客们可能提出的问题回答一遍。</p><p>以上几点中，当你报告的是你认为可能在代码中的问题时，给黑客一个可以重现你的问题的环境尤其重要。当你这么做时，你得到有效的回答的机会和速度都会大大的提升。</p><p><a href="http://www.chiark.greenend.org.uk/~sgtatham/">Simon Tatham</a> 写过一篇名为《<a href="http://www.chiark.greenend.org.uk/~sgtatham/bugs-cn.html">如何有效的报告 Bug</a>》的出色文章。强力推荐你也读一读。</p><h3 id="话不在多而在精"><a href="#话不在多而在精" class="headerlink" title="话不在多而在精"></a>话不在多而在精</h3><p>你需要提供精确有内容的信息。这并不是要求你简单的把成堆的出错代码或者资料完全转录到你的提问中。如果你有庞大而复杂的测试样例能重现程序挂掉的情境，尽量将它剪裁得越小越好。</p><p>这样做的用处至少有三点。<br>第一，表现出你为简化问题付出了努力，这可以使你得到回答的机会增加；<br>第二，简化问题使你更有可能得到<strong>有用</strong>的答案；<br>第三，在精炼你的 bug 报告的过程中，你很可能就自己找到了解决方法或权宜之计。</p><h3 id="别动辄声称找到-Bug"><a href="#别动辄声称找到-Bug" class="headerlink" title="别动辄声称找到 Bug"></a>别动辄声称找到 Bug</h3><p>当你在使用软件中遇到问题，除非你非常、<strong>非常</strong>的有根据，不要动辄声称找到了 Bug。提示：除非你能提供解决问题的源代码补丁，或者提供回归测试来表明前一版本中行为不正确，否则你都多半不够完全确信。这同样适用在网页和文件，如果你（声称）发现了文件的<code>Bug</code>，你应该能提供相应位置的修正或替代文件。</p><p>请记得，还有其他许多用户没遇到你发现的问题，否则你在阅读文件或搜索网页时就应该发现了（你在抱怨前<a href="#%E5%9C%A8%E6%8F%90%E9%97%AE%E4%B9%8B%E5%89%8D">已经做了这些，是吧</a>？）。这也意味着很有可能是你弄错了而不是软件本身有问题。</p><p>编写软件的人总是非常辛苦地使它尽可能完美。如果你声称找到了 Bug，也就是在质疑他们的能力，即使你是对的，也有可能会冒犯到其中某部分人。当你在标题中嚷嚷着有<code>Bug</code>时，这尤其严重。</p><p>提问时，即使你私下非常确信已经发现一个真正的 Bug，最好写得像是<strong>你</strong>做错了什么。如果真的有 Bug，你会在回复中看到这点。这样做的话，如果真有 Bug，维护者就会向你道歉，这总比你惹恼别人然后欠别人一个道歉要好一点。</p><h3 id="低声下气不能代替你的功课"><a href="#低声下气不能代替你的功课" class="headerlink" title="低声下气不能代替你的功课"></a>低声下气不能代替你的功课</h3><p>有些人明白他们不该粗鲁或傲慢的提问并要求得到答复，但他们选择另一个极端 —— 低声下气：<code>我知道我只是个可悲的新手，一个撸瑟，但...</code>。这既使人困扰，也没有用，尤其是伴随着与实际问题含糊不清的描述时更令人反感。</p><p>别用原始灵长类动物的把戏来浪费你我的时间。取而代之的是，尽可能清楚地描述背景条件和你的问题情况。这比低声下气更好地定位了你的位置。</p><p>有时网页论坛会设有专为新手提问的版面，如果你真的认为遇到了初学者的问题，到那去就是了，但一样别那么低声下气。</p><h3 id="描述问题症状而非你的猜测"><a href="#描述问题症状而非你的猜测" class="headerlink" title="描述问题症状而非你的猜测"></a>描述问题症状而非你的猜测</h3><p>告诉黑客们你认为问题是怎样造成的并没什么帮助。（如果你的推断如此有效，还用向别人求助吗？），因此要确信你原原本本告诉了他们问题的症状，而不是你的解释和理论；让黑客们来推测和诊断。如果你认为陈述自己的猜测很重要，清楚地说明这只是你的猜测，并描述为什么它们不起作用。</p><p><strong>蠢问题</strong></p><blockquote><p>我在编译内核时接连遇到 SIG11 错误，<br>我怀疑某条飞线搭在主板的走线上了，这种情况应该怎样检查最好？</p></blockquote><p><strong>聪明问题</strong></p><blockquote><p>我的组装电脑是 FIC-PA2007 主机板搭载 AMD K6&#x2F;233 CPU（威盛 Apollo VP2 芯片组），<br>256MB Corsair PC133 SDRAM 内存，在编译内核时，从开机 20 分钟以后就频频产生 SIG11 错误，<br>但是在头 20 分钟内从没发生过相同的问题。重新启动也没有用，但是关机一晚上就又能工作 20 分钟。<br>所有内存都换过了，没有效果。相关部分的标准编译记录如下…</p></blockquote><p>由于以上这点似乎让许多人觉得难以配合，这里有句话可以提醒你：<code>所有的诊断专家都来自密苏里州。</code> 美国国务院的官方座右铭则是：<code>让我看看</code>（出自国会议员 Willard D. Vandiver 在 1899 年时的讲话：<code>我来自一个出产玉米，棉花，牛蒡和民主党人的国家，滔滔雄辩既不能说服我，也不会让我满意。我来自密苏里州，你必须让我看看。</code>） 针对诊断者而言，这并不是一种怀疑，而只是一种真实而有用的需求，以便让他们看到的是与你看到的原始证据尽可能一致的东西，而不是你的猜测与归纳的结论。所以，大方地展示给我们看吧！</p><h3 id="按发生时间先后列出问题症状"><a href="#按发生时间先后列出问题症状" class="headerlink" title="按发生时间先后列出问题症状"></a>按发生时间先后列出问题症状</h3><p>问题发生前的一系列操作，往往就是对找出问题最有帮助的线索。因此，你的说明里应该包含你的操作步骤，以及机器和软件的反应，直到问题发生。在命令行处理的情况下，提供一段操作记录（例如运行脚本工具所生成的），并引用相关的若干行（如 20 行）记录会非常有帮助。</p><p>如果挂掉的程序有诊断选项（如 -v 的详述开关），试着选择这些能在记录中增加调试信息的选项。记住，<code>多</code>不等于<code>好</code>。试着选取适当的调试级别以便提供有用的信息而不是让读者淹没在垃圾中。</p><p>如果你的说明很长（如超过四个段落），在开头简述问题，接下来再按时间顺序详述会有所帮助。这样黑客们在读你的记录时就知道该注意哪些内容了。</p><h3 id="描述目标而不是过程"><a href="#描述目标而不是过程" class="headerlink" title="描述目标而不是过程"></a>描述目标而不是过程</h3><p>如果你想弄清楚如何做某事（而不是报告一个 Bug），在开头就描述你的目标，然后才陈述重现你所卡住的特定步骤。</p><p>经常寻求技术帮助的人在心中有个更高层次的目标，而他们在自以为能达到目标的特定道路上被卡住了，然后跑来问该怎么走，但没有意识到这条路本身就有问题。结果要费很大的劲才能搞定。</p><p><strong>蠢问题</strong></p><blockquote><p>我怎样才能从某绘图程序的颜色选择器中取得十六进制的 RGB 值？</p></blockquote><p><strong>聪明问题</strong></p><blockquote><p>我正试着用替换一幅图片的色码（color table）成自己选定的色码，我现在知道的唯一方法是编辑每个色码区块（table slot），<br>但却无法从某绘图程序的颜色选择器取得十六进制的 RGB 值。</p></blockquote><p>第二种提问法比较聪明，你可能得到像是<code>建议采用另一个更合适的工具</code>的回复。</p><h3 id="别要求使用私人电邮回复"><a href="#别要求使用私人电邮回复" class="headerlink" title="别要求使用私人电邮回复"></a>别要求使用私人电邮回复</h3><p>黑客们认为问题的解决过程应该公开、透明，此过程中如果更有经验的人注意到不完整或者不当之处，最初的回复才能够、也应该被纠正。同时，作为提供帮助者可以得到一些奖励，奖励就是他的能力和学识被其他同行看到。</p><p>当你要求私下回复时，这个过程和奖励都被中止。别这样做，让<strong>回复者</strong>来决定是否私下回答 —— 如果他真这么做了，通常是因为他认为问题编写太差或者太肤浅，以至于不可能使其他人产生兴趣。</p><p>这条规则存在一条有限的例外，如果你确信提问可能会引来大量雷同的回复时，那么这个神奇的提问句会是<code>向我发电邮，我将为论坛归纳这些回复</code>。试着将邮件列表或新闻群组从洪水般的雷同回复中解救出来是非常有礼貌的 —— 但你必须信守诺言。</p><h3 id="清楚明确地表达你的问题以及需求"><a href="#清楚明确地表达你的问题以及需求" class="headerlink" title="清楚明确地表达你的问题以及需求"></a>清楚明确地表达你的问题以及需求</h3><p>漫无边际的提问是近乎无休无止的时间黑洞。最有可能给你有用答案的人通常也正是最忙的人（他们忙是因为要亲自完成大部分工作）。这样的人对无节制的时间黑洞相当厌恶，所以他们也倾向于厌恶那些漫无边际的提问。</p><p>如果你明确表述需要回答者做什么（如提供指点、发送一段代码、检查你的补丁、或是其他等等），就最有可能得到有用的答案。因为这会定出一个时间和精力的上限，便于回答者能集中精力来帮你。这么做很棒。</p><p>要理解专家们所处的世界，请把专业技能想像为充裕的资源，而回复的时间则是稀缺的资源。你要求他们奉献的时间越少，你越有可能从真正专业而且很忙的专家那里得到解答。</p><p>所以，界定一下你的问题，使专家花在辨识你的问题和回答所需要付出的时间减到最少，这技巧对你获得有用的答案相当有帮助 —— 但这技巧通常和简化问题有所区别。因此，问<code>我想更好地理解 X，可否指点一下哪有好一点说明？</code>通常比问<code>你能解释一下 X 吗？</code>更好。如果你的代码不能运作，通常请别人看看哪里有问题，比要求别人替你改正要明智得多。</p><h3 id="询问有关代码的问题时"><a href="#询问有关代码的问题时" class="headerlink" title="询问有关代码的问题时"></a>询问有关代码的问题时</h3><p>如果没有提示别人应该从何入手，别要求他人帮你调试有问题的代码。张贴几百行的代码，然后说一声：<code>它不能工作</code>会让你完全被忽略。只贴几十行代码，然后说一句：<code>在第七行以后，我期待它显示 &lt;x&gt;，但实际出现的是 &lt;y&gt;</code>比较有可能让你得到回应。</p><p>最有效描述程序问题的方法是提供最精简的 Bug 展示测试用例（bug-demonstrating test case）。什么是最精简的测试用例？那是问题的缩影；一小个程序片段能<strong>刚好</strong>展示出程序的异常行为，而不包含其他令人分散注意力的内容。怎么制作最精简的测试用例？如果你知道哪一行或哪一段代码会造成异常的行为，复制下来并加入足够重现这个状况的代码（例如，足以让这段代码能被编译&#x2F;直译&#x2F;被应用程序处理）。如果你无法将问题缩减到一个特定区块，就复制一份代码并移除不影响产生问题行为的部分。总之，测试用例越小越好（查看<a href="#%E8%AF%9D%E4%B8%8D%E5%9C%A8%E5%A4%9A%E8%80%8C%E5%9C%A8%E7%B2%BE">话不在多而在精</a>一节）。</p><p>一般而言，要得到一段相当精简的测试用例并不太容易，但永远先尝试这样做是一个好习惯。这种方式可以帮助你了解如何自行解决这个问题 —— 而且即使你的尝试不成功，黑客们也会看到你在尝试取得答案的过程中付出了努力，这可以让他们更愿意与你合作。</p><p>如果你只是想让别人帮忙审查（Review）一下代码，在信的开头就要说出来，并且一定要提到你认为哪一部分特别需要关注以及为什么。</p><h3 id="别把自己家庭作业的问题贴上来"><a href="#别把自己家庭作业的问题贴上来" class="headerlink" title="别把自己家庭作业的问题贴上来"></a>别把自己家庭作业的问题贴上来</h3><p>黑客们很擅长分辨哪些问题是家庭作业式的问题；因为我们中的大多数都曾自己解决这类问题。同样，这些问题得由<strong>你</strong>来搞定，你会从中学到东西。你可以要求给点提示，但别要求得到完整的解决方案。</p><p>如果你怀疑自己碰到了一个家庭作业式的问题，但仍然无法解决，试试在用户群组，论坛或（最后一招）在项目的<strong>用户</strong>邮件列表或论坛中提问。尽管黑客们<strong>会</strong>看出来，但一些有经验的用户也许仍会给你一些提示。</p><h3 id="去掉无意义的提问句"><a href="#去掉无意义的提问句" class="headerlink" title="去掉无意义的提问句"></a>去掉无意义的提问句</h3><p>避免用无意义的话结束提问，例如<code>有人能帮我吗？</code>或者<code>这有答案吗？</code>。</p><p>首先：如果你对问题的描述不是很好，这样问更是画蛇添足。</p><p>其次：由于这样问是画蛇添足，黑客们会很厌烦你 —— 而且通常会用逻辑上正确，但毫无意义的回答来表示他们的蔑视， 例如：<code>没错，有人能帮你</code>或者<code>不，没答案</code>。</p><p>一般来说，避免用 <code>是或否</code>、<code>对或错</code>、<code>有或没有</code>类型的问句，除非你想得到<a href="https://strcat.de/questions-with-yes-or-no-answers.html">是或否类型的回答</a>。</p><h3 id="即使你很急也不要在标题写紧急"><a href="#即使你很急也不要在标题写紧急" class="headerlink" title="即使你很急也不要在标题写紧急"></a>即使你很急也不要在标题写<code>紧急</code></h3><p>这是你的问题，不是我们的。宣称<code>紧急</code>极有可能事与愿违：大多数黑客会直接删除无礼和自私地企图即时引起关注的问题。更严重的是，<code>紧急</code>这个字（或是其他企图引起关注的标题）通常会被垃圾信过滤器过滤掉 —— 你希望能看到你问题的人可能永远也看不到。</p><p>有半个例外的情况是，如果你是在一些很高调，会使黑客们兴奋的地方，也许值得这样去做。在这种情况下，如果你有时间压力，也很有礼貌地提到这点，人们也许会有兴趣回答快一点。</p><p>当然，这风险很大，因为黑客们兴奋的点多半与你的不同。譬如从 NASA 国际空间站（International Space Station）发这样的标题没有问题，但用自我感觉良好的慈善行为或政治原因发肯定不行。事实上，张贴诸如<code>紧急：帮我救救这个毛茸茸的小海豹！</code>肯定让你被黑客忽略或惹恼他们，即使他们认为毛茸茸的小海豹很重要。</p><p>如果你觉得这点很不可思议，最好再把这份指南剩下的内容多读几遍，直到你弄懂了再发文。</p><h3 id="礼多人不怪，而且有时还很有帮助"><a href="#礼多人不怪，而且有时还很有帮助" class="headerlink" title="礼多人不怪，而且有时还很有帮助"></a>礼多人不怪，而且有时还很有帮助</h3><p>彬彬有礼，多用<code>请</code>和<code>谢谢您的关注</code>，或<code>谢谢你的关照</code>。让大家都知道你对他们花时间免费提供帮助心存感激。</p><p>坦白说，这一点并没有比使用清晰、正确、精准且合乎语法和避免使用专用格式重要（也不能取而代之）。黑客们一般宁可读有点唐突但技术上鲜明的 Bug 报告，而不是那种有礼但含糊的报告。（如果这点让你不解，记住我们是按问题能教给我们什么来评价问题的价值的）</p><p>然而，如果你有一串的问题待解决，客气一点肯定会增加你得到有用回应的机会。</p><p>（我们注意到，自从本指南发布后，从资深黑客那里得到的唯一严重缺陷反馈，就是对预先道谢这一条。一些黑客觉得<code>先谢了</code>意味着事后就不用再感谢任何人的暗示。我们的建议是要么先说<code>先谢了</code>，<strong>然后</strong>事后再对回复者表示感谢，或者换种方式表达感激，譬如用<code>谢谢你的关注</code>或<code>谢谢你的关照</code>。）</p><h3 id="问题解决后，加个简短的补充说明"><a href="#问题解决后，加个简短的补充说明" class="headerlink" title="问题解决后，加个简短的补充说明"></a>问题解决后，加个简短的补充说明</h3><p>问题解决后，向所有帮助过你的人发个说明，让他们知道问题是怎样解决的，并再一次向他们表示感谢。如果问题在新闻组或者邮件列表中引起了广泛关注，应该在那里贴一个说明比较恰当。</p><p>最理想的方式是向最初提问的话题回复此消息，并在标题中包含<code>已修正</code>，<code>已解决</code>或其它同等含义的明显标记。在人来人往的邮件列表里，一个看见讨论串<code>问题 X</code>和<code>问题 X - 已解决</code>的潜在回复者就明白不用再浪费时间了（除非他个人觉得<code>问题 X</code>有趣），因此可以利用此时间去解决其它问题。</p><p>补充说明不必很长或是很深入；简单的一句<code>你好，原来是网线出了问题！谢谢大家 – Bill</code>比什么也不说要来的好。事实上，除非结论真的很有技术含量，否则简短可爱的小结比长篇大论更好。说明问题是怎样解决的，但大可不必将解决问题的过程复述一遍。</p><p>对于有深度的问题，张贴调试记录的摘要是有帮助的。描述问题的最终状态，说明是什么解决了问题，在此<strong>之后</strong>才指明可以避免的盲点。避免盲点的部分应放在正确的解决方案和其它总结材料之后，而不要将此信息搞成侦探推理小说。列出那些帮助过你的名字，会让你交到更多朋友。</p><p>除了有礼貌和有内涵以外，这种类型的补充也有助于他人在邮件列表&#x2F;新闻群组&#x2F;论坛中搜索到真正解决你问题的方案，让他们也从中受益。</p><p>至少，这种补充有助于让每位参与协助的人因问题的解决而从中得到满足感。如果你自己不是技术专家或者黑客，那就相信我们，这种感觉对于那些你向他们求助的大师或者专家而言，是非常重要的。问题悬而未决会让人灰心；黑客们渴望看到问题被解决。好人有好报，满足他们的渴望，你会在下次提问时尝到甜头。</p><p>思考一下怎样才能避免他人将来也遇到类似的问题，自问写一份文件或加个常见问题（FAQ）会不会有帮助。如果是的话就将它们发给维护者。</p><p>在黑客中，这种良好的后继行动实际上比传统的礼节更为重要，也是你如何透过善待他人而赢得声誉的方式，这是非常有价值的资产。</p><h2 id="如何解读答案"><a href="#如何解读答案" class="headerlink" title="如何解读答案"></a>如何解读答案</h2><p><a id="rtfm"></a></p><h3 id="RTFM-和-STFW：如何知道你已完全搞砸了"><a href="#RTFM-和-STFW：如何知道你已完全搞砸了" class="headerlink" title="RTFM 和 STFW：如何知道你已完全搞砸了"></a>RTFM 和 STFW：如何知道你已完全搞砸了</h3><p>有一个古老而神圣的传统：如果你收到<code>RTFM（Read The Fucking Manual）</code>的回应，回答者认为你<strong>应该去读他妈的手册</strong>。当然，基本上他是对的，你应该去读一读。</p><p>RTFM 有一个年轻的亲戚。如果你收到<code>STFW（Search The Fucking Web）</code>的回应，回答者认为你<strong>应该到他妈的网上搜索</strong>。那人多半也是对的，去搜索一下吧。（更温和一点的说法是 **<a href="http://lmgtfy.com/">Google 是你的朋友</a>**！）</p><p>在论坛，你也可能被要求去爬爬论坛的旧文。事实上，有人甚至可能热心地为你提供以前解决此问题的讨论串。但不要依赖这种关照，提问前应该先搜索一下旧文。</p><p>通常，用这两句之一回答你的人会给你一份包含你需要内容的手册或者一个网址，而且他们打这些字的时候也正在读着。这些答复意味着回答者认为：</p><ul><li><strong>你需要的信息非常容易获得</strong>；</li><li><strong>你自己去搜索这些信息比灌给你，能让你学到更多</strong>。</li></ul><p>你不应该因此不爽；<strong>依照黑客的标准，他已经表示了对你一定程度的关注，而没有对你的要求视而不见</strong>。你应该对他祖母般的慈祥表示感谢。</p><h3 id="如果还是搞不懂"><a href="#如果还是搞不懂" class="headerlink" title="如果还是搞不懂"></a>如果还是搞不懂</h3><p>如果你看不懂回应，别立刻要求对方解释。像你以前试着自己解决问题时那样（利用手册，FAQ，网络，身边的高手），先试着去搞懂他的回应。如果你真的需要对方解释，记得表现出你已经从中学到了点什么。</p><p>比方说，如果我回答你：<code>看来似乎是 zentry 卡住了；你应该先清除它。</code>，然后，这是一个<strong>很糟的</strong>后续问题回应：<code>zentry 是什么？</code> <strong>好</strong>的问法应该是这样：<code>哦~~~我看过说明了但是只有 -z 和 -p 两个参数中提到了 zentries，而且还都没有清楚的解释如何清除它。你是指这两个中的哪一个吗？还是我看漏了什么？</code></p><h3 id="处理无礼的回应"><a href="#处理无礼的回应" class="headerlink" title="处理无礼的回应"></a>处理无礼的回应</h3><p>很多黑客圈子中看似无礼的行为并不是存心冒犯。相反，它是直截了当，一针见血式的交流风格，这种风格更注重解决问题，而不是使人感觉舒服而却模模糊糊。</p><p>如果你觉得被冒犯了，试着平静地反应。如果有人真的做了出格的事，邮件列表、新闻群组或论坛中的前辈多半会招呼他。如果这<strong>没有</strong>发生而你却发火了，那么你发火对象的言语可能在黑客社区中看起来是正常的，而<strong>你</strong>将被视为有错的一方，这将伤害到你获取信息或帮助的机会。</p><p>另一方面，你偶尔真的会碰到无礼和无聊的言行。与上述相反，对真正的冒犯者狠狠地打击，用犀利的语言将其驳得体无完肤都是可以接受的。然而，在行事之前一定要非常非常的有根据。纠正无礼的言论与开始一场毫无意义的口水战仅一线之隔，黑客们自己莽撞地越线的情况并不鲜见。如果你是新手或外人，避开这种莽撞的机会并不高。如果你想得到的是信息而不是消磨时光，这时最好不要把手放在键盘上以免冒险。</p><p>（有些人断言很多黑客都有轻度的自闭症或亚斯伯格综合症，缺少用于润滑人类社会<strong>正常</strong>交往所需的神经。这既可能是真也可能是假的。如果你自己不是黑客，兴许你认为我们脑袋有问题还能帮助你应付我们的古怪行为。只管这么干好了，我们不在乎。我们<strong>喜欢</strong>我们现在这个样子，并且通常对病患标记都有站得住脚的怀疑。）</p><p>Jeff Bigler 的观察总结和这个相关也值得一读 (<strong><a href="http://www.mit.edu/~jcb/tact.html">tact filters</a></strong>)。</p><p>在下一节，我们会谈到另一个问题，当<strong>你</strong>行为不当时所会受到的<code>冒犯</code>。</p><h2 id="如何避免扮演失败者"><a href="#如何避免扮演失败者" class="headerlink" title="如何避免扮演失败者"></a>如何避免扮演失败者</h2><p>在黑客社区的论坛中，你以本指南所描述的或类似的方式，可能会有那么几次搞砸了。而你会在公开场合中被告知你是如何搞砸的，也许攻击的言语中还会带点夹七夹八的颜色。</p><p>这种事发生以后，你能做的最糟糕的事莫过于哀嚎你的遭遇、宣称被言语攻击、要求道歉、高声尖叫、憋闷气、威胁诉诸法律、向其雇主报怨、不去关马桶盖等等。相反地，你该这么做：</p><p>熬过去，这很正常。事实上，它是有益健康且合理的。</p><p>社区的标准不会自行维持，它们是通过参与者积极而<strong>公开地</strong>执行来维持的。不要哭嚎所有的批评都应该通过私下的邮件传送，它不是这样运作的。当有人评论你的一个说法有误或者提出不同看法时，坚持声称受到个人攻击也毫无益处，这些都是失败者的态度。</p><p>也有其它的黑客论坛，受过高礼节要求的误导，禁止参与者张贴任何对别人帖子挑毛病的消息，并声称<code>如果你不想帮助用户就闭嘴。</code> 结果造成有想法的参与者纷纷离开，这么做只会使它们沦为毫无意义的唠叨与无用的技术论坛。</p><p>夸张的讲法是：你要的是“友善”（以上述方式）还是有用？两个里面挑一个。</p><p>记着：当黑客说你搞砸了，并且（无论多么刺耳）告诉你别再这样做时，他正在为关心<strong>你</strong>和<strong>他的社区</strong>而行动。对他而言，不理你并将你从他的生活中滤掉更简单。如果你无法做到感谢，至少要表现得有点尊严，别大声哀嚎，也别因为自己是个有戏剧性超级敏感的灵魂和自以为有资格的新来者，就指望别人像对待脆弱的洋娃娃那样对你。</p><p>有时候，即使你没有搞砸（或者只是在他的想像中你搞砸了），有些人也会无缘无故地攻击你本人。在这种情况下，抱怨倒是<strong>真的</strong>会把问题搞砸。</p><p>这些来找麻烦的人要么是毫无办法但自以为是专家的不中用家伙，要么就是测试你是否真会搞砸的心理专家。其它读者要么不理睬，要么用自己的方式对付他们。这些来找麻烦的人在给他们自己找麻烦，这点你不用操心。</p><p>也别让自己卷入口水战，最好不要理睬大多数的口水战 —— 当然，这是在你检验它们只是口水战，并且未指出你有搞砸的地方，同时也没有巧妙地将问题真正的答案藏于其后（这也是有可能的）。</p><h2 id="不该问的问题"><a href="#不该问的问题" class="headerlink" title="不该问的问题"></a>不该问的问题</h2><p>以下是几个经典蠢问题，以及黑客没回答时心中所想的：</p><p>问题：<a href="#q1">我能在哪找到 X 程序或 X 资源？</a></p><p>问题：<a href="#q2">我怎样用 X 做 Y？</a></p><p>问题：<a href="#q3">如何设定我的 shell 提示？</a></p><p>问题：<a href="#q4">我可以用 Bass-o-matic 文件转换工具将 AcmeCorp 文件转换为 TeX 格式吗？</a></p><p>问题：<a href="#q5">我的程序&#x2F;设定&#x2F;SQL 语句没有用</a></p><p>问题：<a href="#q6">我的 Windows 电脑有问题，你能帮我吗？</a></p><p>问题：<a href="#q7">我的程序不会动了，我认为系统工具 X 有问题</a></p><p>问题：<a href="#q8">我在安装 Linux（或者 X ）时有问题，你能帮我吗？</a></p><p>问题：<a href="#q9">我怎么才能破解 root 帐号&#x2F;窃取 OP 特权&#x2F;读别人的邮件呢？</a></p><hr><p><a id="q1"></a></p><blockquote><p>问题：我能在哪找到 X 程序或 X 资源？</p></blockquote><p>回答：就在我找到它的地方啊，白痴 —— 搜索引擎的那一头。天哪！难道还有人不会用 <a href="https://www.google.com/">Google</a> 吗？</p><p><a id="q2"></a></p><blockquote><p>问题：我怎样用 X 做 Y？</p></blockquote><p>回答：如果你想解决的是 Y ，提问时别给出可能并不恰当的方法。这种问题说明提问者不但对 X 完全无知，也对 Y 要解决的问题糊涂，还被特定形势禁锢了思维。最好忽略这种人，等他们把问题搞清楚了再说。</p><p><a id="q3"></a></p><blockquote><p>问题：如何设定我的 shell 提示？？</p></blockquote><p>回答：如果你有足够的智慧提这个问题，你也该有足够的智慧去 <a href="#RTFM">RTFM</a>，然后自己去找出来。</p><p><a id="q4"></a></p><blockquote><p>问题：我可以用 Bass-o-matic 文件转换工具将 AcmeCorp 文件转换为 TeX 格式吗？</p></blockquote><p>回答：试试看就知道了。如果你试过，你就知道了答案，就不用浪费我的时间了。</p><p><a id="q5"></a></p><blockquote><p>问题：我的{程序&#x2F;设定&#x2F;SQL 语句}没有用</p></blockquote><p>回答：这不算是问题吧，我对要我问你二十个问题才找得出你真正问题的问题没兴趣 —— 我有更有意思的事要做呢。在看到这类问题的时候，我的反应通常不外如下三种</p><ul><li>你还有什么要补充的吗？</li><li>真糟糕，希望你能搞定。</li><li>这关我屁事？</li></ul><p><a id="q6"></a></p><blockquote><p>问题：我的 Windows 电脑有问题，你能帮我吗？</p></blockquote><p>回答：能啊，扔掉微软的垃圾，换个像 Linux 或 BSD 的开源操作系统吧。</p><p>注意：如果程序有官方版 Windows 或者与 Windows 有互动（如 Samba），你<strong>可以</strong>问与 Windows 相关的问题，只是别对问题是由 Windows 操作系统而不是程序本身造成的回复感到惊讶， 因为 Windows 一般来说实在太烂，这种说法通常都是对的。</p><p><a id="q7"></a></p><blockquote><p>问题：我的程序不会动了，我认为系统工具 X 有问题</p></blockquote><p>回答：你完全有可能是第一个注意到被成千上万用户反复使用的系统调用与函数库文件有明显缺陷的人，更有可能的是你完全没有根据。不同凡响的说法需要不同凡响的证据，当你这样声称时，你必须有清楚而详尽的缺陷说明文件作后盾。</p><p><a id="q8"></a></p><blockquote><p>问题：我在安装 Linux（或者 X ）时有问题，你能帮我吗？</p></blockquote><p>回答：不能，我只有亲自在你的电脑上动手才能找到毛病。还是去找你当地的 Linux 使用群组者寻求实际的指导吧（你能在<a href="http://www.linux.org/groups/index.html">这儿</a>找到用户群组的清单）。</p><p>注意：如果安装问题与某 Linux 的发行版有关，在它的邮件列表、论坛或本地用户群组中提问也许是恰当的。此时，应描述问题的准确细节。在此之前，先用 <code>Linux</code> 和<strong>所有</strong>被怀疑的硬件作关键词仔细搜索。</p><p><a id="q9"></a></p><blockquote><p>问题：我怎么才能破解 root 帐号&#x2F;窃取 OP 特权&#x2F;读别人的邮件呢？</p></blockquote><p>回答：想要这样做，说明了你是个卑鄙小人；想找个黑客帮你，说明你是个白痴！</p><h2 id="好问题与蠢问题"><a href="#好问题与蠢问题" class="headerlink" title="好问题与蠢问题"></a>好问题与蠢问题</h2><p>最后，我将透过举一些例子，来说明怎样聪明的提问；同一个问题的两种问法被放在一起，一种是愚蠢的，另一种才是明智的。</p><p><strong>蠢问题</strong>：</p><blockquote><p>我可以在哪儿找到关于 Foonly Flurbamatic 的资料？</p></blockquote><p>这种问法无非想得到 <a href="#RTFM">STFW</a> 这样的回答。</p><p><strong>聪明问题</strong>：</p><blockquote><p>我用 Google 搜索过 “Foonly Flurbamatic 2600”，但是没找到有用的结果。谁知道上哪儿去找对这种设备编程的资料？</p></blockquote><p>这个问题已经 STFW 过了，看起来他真的遇到了麻烦。</p><p><strong>蠢问题</strong>：</p><blockquote><p>我从 foo 项目找来的源码没法编译。它怎么这么烂？</p></blockquote><p>他觉得都是别人的错，这个傲慢自大的提问者。</p><p><strong>聪明问题</strong>：</p><blockquote><p>foo 项目代码在 Nulix 6.2 版下无法编译通过。我读过了 FAQ，但里面没有提到跟 Nulix 有关的问题。这是我编译过程的记录，我有什么做的不对的地方吗？</p></blockquote><p>提问者已经指明了环境，也读过了 FAQ，还列出了错误，并且他没有把问题的责任推到别人头上，他的问题值得被关注。</p><p><strong>蠢问题</strong>：</p><blockquote><p>我的主机板有问题了，谁来帮我？</p></blockquote><p>某黑客对这类问题的回答通常是：<code>好的，还要帮你拍拍背和换尿布吗？</code>，然后按下删除键。</p><p><strong>聪明问题</strong>：</p><blockquote><p>我在 S2464 主机板上试过了 X 、 Y 和 Z ，但没什么作用，我又试了 A 、 B 和 C 。请注意当我尝试 C 时的奇怪现象。显然 florbish 正在 grommicking，但结果出人意料。通常在 Athlon MP 主机板上引起 grommicking 的原因是什么？有谁知道接下来我该做些什么测试才能找出问题？</p></blockquote><p>这个家伙，从另一个角度来看，值得去回答他。他表现出了解决问题的能力，而不是坐等天上掉答案。</p><p>在最后一个问题中，注意<code>告诉我答案</code>和<code>给我启示，指出我还应该做什么诊断工作</code>之间微妙而又重要的区别。</p><p>事实上，后一个问题源自于 2001 年 8 月在 Linux 内核邮件列表（lkml）上的一个真实的提问。我（Eric）就是那个提出问题的人。我在 Tyan S2464 主板上观察到了这种无法解释的锁定现象，列表成员们提供了解决这一问题的重要信息。</p><p>通过我的提问方法，我给了别人可以咀嚼玩味的东西；我设法让人们很容易参与并且被吸引进来。我显示了自己具备和他们同等的能力，并邀请他们与我共同探讨。通过告诉他们我所走过的弯路，以避免他们再浪费时间，我也表明了对他们宝贵时间的尊重。</p><p>事后，当我向每个人表示感谢，并且赞赏这次良好的讨论经历的时候，一个 Linux 内核邮件列表的成员表示，他觉得我的问题得到解决并非由于我是这个列表中的<strong>名</strong>人，而是因为我用了正确的方式来提问。</p><p>黑客从某种角度来说是拥有丰富知识但缺乏人情味的家伙；我相信他是对的，如果我<strong>像</strong>个乞讨者那样提问，不论我是谁，一定会惹恼某些人或者被他们忽视。他建议我记下这件事，这直接导致了本指南的出现。</p><h2 id="如果得不到回答"><a href="#如果得不到回答" class="headerlink" title="如果得不到回答"></a>如果得不到回答</h2><p>如果仍得不到回答，请不要以为我们觉得无法帮助你。有时只是看到你问题的人不知道答案罢了。没有回应不代表你被忽视，虽然不可否认这种差别很难区分。</p><p>总的来说，简单地重复张贴问题是个很糟的点子。这将被视为无意义的喧闹。有点耐心，知道你问题答案的人可能生活在不同的时区，可能正在睡觉，也有可能你的问题一开始就没有组织好。</p><p>你可以通过其他渠道获得帮助，这些渠道通常更适合初学者的需要。</p><p>有许多网上的以及本地的用户群组，由热情的软件爱好者（即使他们可能从没亲自写过任何软件）组成。通常人们组建这样的团体来互相帮助并帮助新手。</p><p>另外，你可以向很多商业公司寻求帮助，不论公司大还是小。别为要付费才能获得帮助而感到沮丧！毕竟，假使你的汽车发动机汽缸密封圈爆掉了 —— 完全可能如此 —— 你还得把它送到修车铺，并且为维修付费。就算软件没花费你一分钱，你也不能强求技术支持总是免费的。</p><p>对像是 Linux 这种大众化的软件，每个开发者至少会对应到上万名用户。根本不可能由一个人来处理来自上万名用户的求助电话。要知道，即使你要为这些协助付费，和你所购买的同类软件相比，你所付出的也是微不足道的（通常封闭源代码软件的技术支持费用比开源软件的要高得多，且内容也没那么丰富）。</p><h2 id="如何更好地回答问题"><a href="#如何更好地回答问题" class="headerlink" title="如何更好地回答问题"></a>如何更好地回答问题</h2><p><strong>态度和善一点。</strong> 问题带来的压力常使人显得无礼或愚蠢，其实并不是这样。</p><p><strong>对初犯者私下回复。</strong> 对那些坦诚犯错之人没有必要当众羞辱，一个真正的新手也许连怎么搜索或在哪找常见问题都不知道。</p><p><strong>如果你不确定，一定要说出来！</strong> 一个听起来权威的错误回复比没有还要糟，别因为听起来像个专家很好玩，就给别人乱指路。要谦虚和诚实，给提问者与同行都树个好榜样。</p><p><strong>如果帮不了忙，也别妨碍他。</strong> 不要在实际步骤上开玩笑，那样也许会毁了提问者的设置 —— 有些可怜的呆瓜会把它当成真的指令。</p><p><strong>试探性的反问以引出更多的细节。</strong> 如果你做得好，提问者可以学到点东西 —— 你也可以。试试将蠢问题转变成好问题，别忘了我们都曾是新手。</p><p>尽管对那些懒虫抱怨一声 RTFM 是正当的，但能给出文档的链接（即使只是建议个 Google 搜索关键词）会更好。</p><p><strong>如果你决定回答，就请给出好的答案。</strong> 当别人正在用错误的工具或方法时别建议笨拙的权宜之计（workaround），应推荐更好的工具，重新界定问题。</p><p><strong>正面地回答问题！</strong> 如果这个提问者已经很深入的研究而且也表明已经试过 X 、 Y 、 Z 、 A 、 B 、 C 但没得到结果，回答 <code>试试看 A 或是 B</code> 或者 <code>试试 X 、 Y 、 Z 、 A 、 B 、 C</code> 并附上一个链接一点用都没有。</p><p><strong>帮助你的社区从问题中学习。</strong> 当回复一个好问题时，问问自己<code>如何修改相关文件或常见问题文件以免再次解答同样的问题？</code>，接着再向文件维护者发一份补丁。</p><p>如果你在研究一番后才作出了回答，<strong>展现你的技巧而不是直接端出结果</strong>。毕竟<code>授人以鱼不如授人以渔</code>。</p><h2 id="相关资源"><a href="#相关资源" class="headerlink" title="相关资源"></a>相关资源</h2><p>如果你需要个人电脑、Unix 系统和网络如何运作的基础知识，参阅 <a href="http://en.tldp.org/HOWTO/Unix-and-Internet-Fundamentals-HOWTO/">Unix 系统和网络基本原理</a>。</p><p>当你发布软件或补丁时，试着按<a href="http://en.tldp.org/HOWTO/Software-Release-Practice-HOWTO/index.html">软件发布实践</a>操作。</p><h2 id="鸣谢"><a href="#鸣谢" class="headerlink" title="鸣谢"></a>鸣谢</h2><p>Evelyn Mitchel 贡献了一些愚蠢问题例子并启发了编写<code>如何更好地回答问题</code>这一节， Mikhail Ramendik 贡献了一些特别有价值的建议和改进。</p><p>2</p>]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;对于程序员来说，提问的方式往往和解决方法同样重要，一个准确，详实，有准备的问题往往能更快地得到他人的帮助&lt;br&gt;此处转载一篇关于如何提问的经典文章，在我学习过程中使我受益良多&lt;br&gt;Copyright © 2001,2006,2014 Eric S. Raymond, Rick Moen&lt;br&gt;英文原版 ： &lt;a href=&quot;http://www.catb.org/~esr/faqs/smart-questions.html&quot;&gt;http://www.catb.org/~esr/faqs/smart-questions.html&lt;/a&gt;&lt;br&gt;繁体中文版 ： &lt;a href=&quot;https://github.com/ryanhanwu/How-To-Ask-Questions-The-Smart-Way/blob/main/README.md&quot;&gt;https://github.com/ryanhanwu/How-To-Ask-Questions-The-Smart-Way/blob/main/README.md&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    <category term="文章分享" scheme="http://example.com/categories/%E6%96%87%E7%AB%A0%E5%88%86%E4%BA%AB/"/>
    
    
  </entry>
  
</feed>
