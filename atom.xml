<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>XinCm</title>
  
  <subtitle>嘿嘿嘿</subtitle>
  <link href="http://example.com/atom.xml" rel="self"/>
  
  <link href="http://example.com/"/>
  <updated>2024-01-15T05:15:34.082Z</updated>
  <id>http://example.com/</id>
  
  <author>
    <name>lx</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>C++的参数传递</title>
    <link href="http://example.com/2024/01/15/C++%E7%9A%84%E5%8F%82%E6%95%B0%E4%BC%A0%E9%80%92/"/>
    <id>http://example.com/2024/01/15/C++%E7%9A%84%E5%8F%82%E6%95%B0%E4%BC%A0%E9%80%92/</id>
    <published>2024-01-15T05:15:34.082Z</published>
    <updated>2024-01-15T05:15:34.082Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>C++的参数传递</p><ul><li>值传递</li><li>指针传递</li><li>引用传递</li></ul></blockquote><span id="more"></span><h2 id="值传递"><a href="#值传递" class="headerlink" title="值传递"></a>值传递</h2><p><font color="#FF0000">this is red test</font><br><font color="#00FF00">this is green test</font><br><font color="#0000FF">this is blue test</font><br>​当初始化一个非引用类型的变量时，初始值被<strong>拷贝</strong>给变量，对此变量的操作不会影响初始值。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a = <span class="number">0</span>;  <span class="comment">// a为初始变量</span></span><br><span class="line"><span class="type">int</span> b = a;  <span class="comment">// b是a的值的副本</span></span><br><span class="line">b = <span class="number">10</span>;   <span class="comment">// b值的修改不会改变a的初始值</span></span><br></pre></td></tr></table></figure><h2 id="指针形参"><a href="#指针形参" class="headerlink" title="指针形参"></a>指针形参</h2><p>​当执行指针拷贝时，行为和普通值传递一样，拷贝的是指针的值，拷贝之后，两个指针是不同的指针</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">change</span><span class="params">(<span class="type">int</span> *ptr)</span></span>&#123;</span><br><span class="line">    *ptr = <span class="number">100</span>;<span class="comment">//改变了ptr所指的对象的值</span></span><br><span class="line">      ptr = <span class="number">100</span>;<span class="comment">//只改变了ptr的局部拷贝，实参的值未改变</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> num = <span class="number">40</span>;</span><br><span class="line"><span class="built_in">change</span>(&amp;num); <span class="comment">//改变了num的值而非地址</span></span><br><span class="line"><span class="built_in">print</span>(num);  <span class="comment">// 伪代码，输出 num = 100</span></span><br></pre></td></tr></table></figure><p><strong>C中常常使用指针类型的形参访问函数外部的对象，在C++中建议用引用类型替代指针类型</strong></p><h2 id="引用传递"><a href="#引用传递" class="headerlink" title="引用传递"></a>引用传递</h2><p>​<strong>引用</strong>可以等价看作为对象起了一个别名，声明符号为**&amp;a**</p><blockquote><p>​int num &#x3D; 100;<br>​int &amp;ref &#x3D; num; &#x2F;&#x2F; ref 指向 num, 是 num 的另一个名字<br>​int &mmm;     &#x2F;&#x2F; <strong>报错，引用必须被初始化</strong></p></blockquote><p>一般在初始化变量时，初始值会被拷贝到新建对象中。而在定义引用时，程序把引用和初始值进行了<strong>绑定</strong>，而非拷贝初始值，所以引用必须被初始化。</p><p><strong>牢记：引用即别名</strong></p><p>引用本身不是一个对象，所以不能定义引用的引用，即：</p><blockquote><p>int a &#x3D; 1;<br>int &amp;ref_1 &#x3D; a;   &#x2F;&#x2F; 正确初始化引用<br>int &amp;ref_2 &#x3D; ref_1 &#x2F;&#x2F; <strong>错误：不能定义引用的引用</strong> </p></blockquote><p>在函数中使用引用传递：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">change</span><span class="params">(<span class="type">int</span> &amp;i)</span></span>&#123;<span class="comment">//此处的 int &amp;i 意思是接收一个int对象的引用，而非取地址</span></span><br><span class="line">    i = <span class="number">100</span>;<span class="comment">// 可理解为 &amp;i = j;标准的初始化引用,i仅仅是j的一个别称</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> j = <span class="number">5</span>;</span><br><span class="line"><span class="built_in">change</span>(j);<span class="comment">// j 采用传引用方式，值将被改变</span></span><br><span class="line"><span class="built_in">print</span>(j);   <span class="comment">// j = 100</span></span><br></pre></td></tr></table></figure><p>使用引用传递的好处：</p><ol><li><p>避免拷贝<br>当对象比较大时，直接拷贝对象比较低效，有些类型(如IO)根本不支持拷贝操作，此时只能引用</p></li><li><p>返回额外信息<br>C++中一个函数只能返回一个值，引用形参可以为我们返回多个值提供途径</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">test_a</span><span class="params">(<span class="type">int</span> a)</span></span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">return</span> x;   <span class="comment">//不使用引用时，只能返回一个x   </span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test_b</span><span class="params">(<span class="type">int</span> &amp;a)</span></span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">return</span> x;  <span class="comment">//使用引用时，除了x， 改变引用a的值同时会改变实参，相当于返回了另一个值</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h2 id="引用与指针的区别"><a href="#引用与指针的区别" class="headerlink" title="引用与指针的区别"></a>引用与指针的区别</h2><ol><li><p>形式上：</p><ul><li><p>指针本质上是一个存放地址的变量，是逻辑上独立的对象，可以被改变；</p></li><li><p>引用逻辑上不独立，只是一个别名，初始化后不可被改变，只能依附于同一个变量</p></li></ul></li><li><p>传递方式上：</p><ul><li>指针传递参数本质上还是<strong>值传递</strong>，它所传递的是个地址，在传递过程中会在栈上开辟空间，存放由主函数放进来的实参的值，从而成为实参的一个副本。值传递的特点是对任何形参做的任何操作都作为局部变量进行，不会印象实参。</li><li>引用传递过程中，形参虽然也作为局部变量在栈上开辟空间，但此时存放的是实参的地址，对形参做的操作都可以看做间接寻址。</li></ul></li><li><p>编译角度：<br>程序在编译时分别将指针和引用添加到符号表上，符号表上记录的是变量名及变量所对应地址。指针变量在符号表上对应的地址值为指针变量的地址值，而引用在符号表上对应的地址值为引用对象的地址值。符号表生成后就不会再改，因此指针可以改变其指向的对象（指针变量中的值可以改），而引用对象则不能修改。</p></li></ol>]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;C++的参数传递&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;值传递&lt;/li&gt;
&lt;li&gt;指针传递&lt;/li&gt;
&lt;li&gt;引用传递&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    <category term="C++" scheme="http://example.com/categories/C/"/>
    
    
  </entry>
  
  <entry>
    <title>字符设备与块设备的区别</title>
    <link href="http://example.com/2024/01/12/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E4%B8%8E%E5%9D%97%E8%AE%BE%E5%A4%87/"/>
    <id>http://example.com/2024/01/12/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E4%B8%8E%E5%9D%97%E8%AE%BE%E5%A4%87/</id>
    <published>2024-01-11T16:00:00.000Z</published>
    <updated>2024-01-11T16:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<p>在LINUX里面，设备类型分为：字符设备、块设备以及网络设备， PCI是一种和ISA为一类的总线结构，归属于网络驱动设备</p><span id="more"></span><h2 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h2><p>字符设备、块设备主要区别是：<br>在对字符设备发出读&#x2F;写请求时，实际的硬件I&#x2F;O一般就紧接着发生了，而块设备则不然，它利用一块系统内存作为缓冲区，当用户进程对设备请求能满足用户的要求时，就返回请求的数据，如果不能就调用请求函数来进行实际的I&#x2F;O操作，因此，块设备主要是针对磁盘等慢速设备设计的，以免消耗过多的CPU时间来等待</p><p><strong>系统中能够随机（不需要按顺序）访问固定大小数据片（chunks）的设备被称作块设备</strong>，这些数据片就称作块。最常见的块设备是硬盘，除此以外，还有软盘驱动器、CD-ROM驱动器和闪存等等许多其他块设备。注意，它们都是以安装文件系统的方式使用的——这也是块设备的一般访问方式。</p><p>另一种基本的设备类型是字符设备。字符设备按照字符流的方式被有序访问，像串口和键盘就都属于字符设备。如果一个硬件设备是以字符流的方式被访问的话，那就应该将它归于字符设备；反过来，如果一个设备是随机（无序的）访问的，那么它就属于块设备。</p><p><strong>这两种类型的设备的根本区别在于它们是否可以被随机访问——换句话说就是，能否在访问设备时随意地从一个位置跳转到另一个位置</strong>。举个例子，键盘这种设备提供的就是一个数据流，当你敲入”fox” 这个字符串时，键盘驱动程序会按照和输入完全相同的顺序返回这个由三个字符组成的数据流。如果让键盘驱动程序打乱顺序来读字符串，或读取其他字符，都是没有意义的。所以键盘就是一种典型的字符设备，它提供的就是用户从键盘输入的字符流。对键盘进行读操作会得到一个字符流，首先是”f”，然后是”o”，最后是”x”，最终是文件的结束（EOF）。当没人敲键盘时，字符流就是空的。硬盘设备的情况就不大一样了。硬盘设备的驱动可能要求读取磁盘上任意块的内容，<strong>然后又转去读取别的块的内容，而被读取的块在磁盘上位置不一定要连续</strong>，所以说硬盘可以被随机访问，而不是以流的方式被访问，显然它是一个块设备。</p><p>内核管理块设备要比管理字符设备细致得多，需要考虑的问题和完成的工作相比字符设备来说要复杂许多。这是因为字符设备仅仅需要控制一个位置—当前位置—而块设备访问的位置必须能够在介质的不同区间前后移动。所以事实上内核不必提供一个专门的子系统来管理字符设备，但是对块设备的管理却必须要有一个专门的提供服务的子系统。不仅仅是因为块设备的复杂性远远高于字符设备，更重要的原因是块设备对执行性能的要求很高；对硬盘每多一分利用都会对整个系统的性能带来提升，其效果要远远比键盘吞吐速度成倍的提高大得多。另外，我们将会看到，块设备的复杂性会为这种优化留下很大的施展空间。</p><p>块设备通过系统缓存进行读取，不是直接和物理磁盘读取。字符设备可以直接物理磁盘读取，不经过系统缓存。（如键盘，直接相应中断）</p><p>字符设备是裸设备 通过查看 ll &#x2F;dev&#x2F;vg00&#x2F; 下的内容 若开头带c字符的则为字符设备<br>块设备是文件设备 通过查看 ll &#x2F;dev&#x2F;vg00&#x2F; 下的内容 若开头带b字符的则为块符设备</p><h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><p>在使用上，只要在对数据库方面的应用需要考虑是选择块设备还是字符设备。一般数据库厂商会建议你建库时使用裸设备（字符设备），空间管理完全由数据库引擎进行管理，这样所有数据和日志直接写盘，当发生系统故障时，不至于丢失数据。但还有一种说法是使用块设备便于管理维护人员的系统管理，因为使用裸设备在第一次分配出去之后，这个设备的空间就不能做任何其他用途了，但块设备则不然，你想使用多少空间就分配多少，你可以进行自由的扩展，而无需一次性的全部分配出去。所以我建议在创建数据库master库使用裸设备，而业务数据库及tempdb则使用块设备。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;在LINUX里面，设备类型分为：字符设备、块设备以及网络设备， PCI是一种和ISA为一类的总线结构，归属于网络驱动设备&lt;/p&gt;</summary>
    
    
    
    <category term="Linux" scheme="http://example.com/categories/Linux/"/>
    
    
  </entry>
  
  <entry>
    <title>内存对齐</title>
    <link href="http://example.com/2024/01/09/%E5%86%85%E5%AD%98%E5%AF%B9%E9%BD%90/"/>
    <id>http://example.com/2024/01/09/%E5%86%85%E5%AD%98%E5%AF%B9%E9%BD%90/</id>
    <published>2024-01-08T16:00:00.000Z</published>
    <updated>2021-01-10T16:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>维基百科中对内存对齐的定义：</p><blockquote><p><strong>内存地址</strong>a<em>被称为</em>n<strong>字节</strong>对齐<em>，</em>a<em>是</em>n<em>的倍数（</em>n<em>应是2的[幂]），也可以理解为当被访问的数据长度为</em>n* 字节时，数据地址为<em>n</em>字节对齐。如果内存未对齐，称作<em>misaligned</em>。</p><p><strong>内存指针</strong>是对齐的，如果它所指的数据是对齐的。指向聚合数据（aggregate data，如struct或数组）是对齐的，当且仅当它的每个组成数据是对齐的。</p></blockquote><span id="more"></span><p><strong>一句话总结，内存对齐的目的是 牺牲内存空间，换取运行效率</strong></p><hr><h2 id="技术细节"><a href="#技术细节" class="headerlink" title="技术细节"></a>技术细节</h2><p>假设现在的<strong>系统为32位</strong>只能从地址为<strong>4的倍数的内存</strong>进行读取数据。如果没有内存对齐，数据任意存放，那么假如一个int类型的数据是<strong>从地址2开始存储</strong>的（<strong>占用2，3，4，5</strong>）那么内存在寻址的时候需要读取两个字节块，并且需要<strong>剔除0，1，6，7四个地址</strong>，并<strong>把地址2，3，4，5合并成一起</strong>，降低了效率，提高了成本。于是就有了内存对齐。</p><p>如果不内存对齐的话，由于硬件的限制，会导致<strong>访存次数增加</strong>，影响了效率。因为尽管<strong>内存以字节为单位</strong>，但是大部分处理器不是按字节来存取内存的，它们一般会以<strong>双字节，4字节，8字节，16字节以及32字节</strong>为单位来存取内存，我们将上述这些内存存取单位称为<strong>内存存取粒度</strong>。</p><p>32位系统一次读取4字节，64位系统一次读取8字节，此数值与系统的地址线有关。</p><p>以32位系统举例，数据线为32位，一次性可读取32位，即 4字节。</p><br /> <h3 id="注意区分寻址线和数据总线："><a href="#注意区分寻址线和数据总线：" class="headerlink" title="注意区分寻址线和数据总线："></a>注意区分寻址线和数据总线：</h3><p>读取数据的线是数据总线（Data Bus），它用于传输实际的数据。数据总线的宽度决定了在一次传输中可以传送的数据位数。例如，32位的数据总线可以传输32位（4字节）的数据。</p><p>当处理器要从内存中读取数据时，它会将要读取的内存地址放在寻址线上，然后将读取到的数据放在数据总线上，这样中央处理器就可以访问所需的数据。</p><hr><h2 id="对齐规则"><a href="#对齐规则" class="headerlink" title="对齐规则"></a>对齐规则</h2><p>每个特定平台上的编译器都有自己默认“<strong>对齐系数</strong>”（也叫对齐模数）。<br>有效对齐值是指给定值”<strong>对齐系数</strong>“和数据结构体中最长数据类型长度中较小的那个。有效对齐值也叫<strong>对齐单位</strong>。<br><br /></p><ol><li><p>结构体中对一个成员的偏移量为0，以后每个成员相对于结构体首地址的偏移量都是<strong>该成员大小与有效对齐值中较小那个</strong>的整数倍，如有需要编译器会在成员之间加上填充字节。</p></li><li><p>结构体的总大小为 有效对齐值 的<strong>整数倍</strong>，如有需要编译器会在最末一个成员之后加上填充字节</p></li></ol><p><strong>PS</strong>： <em>#pragma pack(n)</em>  规则仅影响结构体的对齐方式，对于独立变量，默认根据特定平台的自然对齐要求进行对齐，这通常是编译器的默认行为。</p><br /><hr>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;定义&quot;&gt;&lt;a href=&quot;#定义&quot; class=&quot;headerlink&quot; title=&quot;定义&quot;&gt;&lt;/a&gt;定义&lt;/h2&gt;&lt;p&gt;维基百科中对内存对齐的定义：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;内存地址&lt;/strong&gt;a&lt;em&gt;被称为&lt;/em&gt;n&lt;strong&gt;字节&lt;/strong&gt;对齐&lt;em&gt;，&lt;/em&gt;a&lt;em&gt;是&lt;/em&gt;n&lt;em&gt;的倍数（&lt;/em&gt;n&lt;em&gt;应是2的[幂]），也可以理解为当被访问的数据长度为&lt;/em&gt;n* 字节时，数据地址为&lt;em&gt;n&lt;/em&gt;字节对齐。如果内存未对齐，称作&lt;em&gt;misaligned&lt;/em&gt;。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;内存指针&lt;/strong&gt;是对齐的，如果它所指的数据是对齐的。指向聚合数据（aggregate data，如struct或数组）是对齐的，当且仅当它的每个组成数据是对齐的。&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    <category term="Linux" scheme="http://example.com/categories/Linux/"/>
    
    
  </entry>
  
  <entry>
    <title>GIT</title>
    <link href="http://example.com/2024/01/05/git/"/>
    <id>http://example.com/2024/01/05/git/</id>
    <published>2024-01-05T07:30:13.301Z</published>
    <updated>2024-01-05T07:30:13.301Z</updated>
    
    <content type="html"><![CDATA[<h3 id="git-amend"><a href="#git-amend" class="headerlink" title="git  amend"></a>git  amend</h3><ul><li>修改上次的 commit  提交</li><li>直接覆盖上次的commit,生成新的commit ID</li><li>保留上次commit的修改，将新修改合并到上次的commit</li></ul><blockquote><p>git add<br>git commit –amend</p></blockquote><span id="more"></span><hr><h3 id="git-clean"><a href="#git-clean" class="headerlink" title="git clean"></a>git clean</h3><p>从工作目录中删除未被版本控制的文件或目录。它通常用于清理工作目录，删除一些生成的或不必要的文件，以确保工作目录的状态是干净的。</p><blockquote><p>git clean -n      显示 将要 删除的 文件 和  目录<br>git clean -f　　删除当前目录下所有没有track过的文件. 他不会删除.gitignore文件里面指定的文件夹和文件, 不管这些文件有没有被track过.<br>git clean -df     删除当前目录下没有被track过的文件和文件夹<br>git clean -xfd   删除当前目录下所有没有track过的文件. 不管他是否是.gitignore文件里面指定的文件夹和文件.</p></blockquote><hr><h1 id="REPO"><a href="#REPO" class="headerlink" title="REPO"></a>REPO</h1><hr><hr><h3 id="repo-start"><a href="#repo-start" class="headerlink" title="repo start"></a>repo start</h3><p>repo start  <branch-name> [–all] [–rebase | –detach | –current-branch] [projects…]<br>为所有模块创建一个分支</p><blockquote><p><code>&lt;branch-name&gt;</code>: 要创建的新分支的名称。<br><code>--all</code>: 为所有项目创建分支。<br><code>--rebase</code>: 使用 rebase 方式创建分支（默认方式）。<br><code>--detach</code>: 创建一个分离头的分支。<br><code>--current-branch</code>: 在当前分支上工作，不切换到新分支。<br><code>projects...</code>: 要在其上创建新分支的项目（可选）。</p></blockquote><hr><h3 id="repo-status"><a href="#repo-status" class="headerlink" title="repo status"></a>repo status</h3><p>显示 project 中每个仓库的状态，并打印仓库名称。</p><hr><h3 id="repo-forall-c"><a href="#repo-forall-c" class="headerlink" title="repo forall -c"></a>repo forall -c</h3><p>遍历所有的git仓库，并在每个仓库执行-c所指定的命令（被执行的命令不限于git命令，而是任何被系统支持的命令，比如：ls 、 pwd 、cp 等 。</p><blockquote><p>ex :<br>    <strong>repo forall -c ‘git reset –hard &amp;&amp; git clean -fdx’</strong><br>    这个命令会对 Repo 管理的每个 Git 仓库执行两个命令：<br>    <code>git reset --hard</code>：将所有本地修改的文件丢弃，将 HEAD 恢复到最近的一次提交状态。<br>    <code>git clean -fdx</code>：删除所有未被 Git 跟踪的文件，包括构建产物、临时文件等。</p></blockquote>]]></content>
    
    
    <summary type="html">&lt;h3 id=&quot;git-amend&quot;&gt;&lt;a href=&quot;#git-amend&quot; class=&quot;headerlink&quot; title=&quot;git  amend&quot;&gt;&lt;/a&gt;git  amend&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;修改上次的 commit  提交&lt;/li&gt;
&lt;li&gt;直接覆盖上次的commit,生成新的commit ID&lt;/li&gt;
&lt;li&gt;保留上次commit的修改，将新修改合并到上次的commit&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;git add&lt;br&gt;git commit –amend&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    <category term="开发工具" scheme="http://example.com/categories/%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7/"/>
    
    
  </entry>
  
  <entry>
    <title>android 下device.mk</title>
    <link href="http://example.com/2024/01/04/device.mk/"/>
    <id>http://example.com/2024/01/04/device.mk/</id>
    <published>2024-01-04T07:53:59.712Z</published>
    <updated>2024-01-04T07:53:59.712Z</updated>
    
    <content type="html"><![CDATA[<h3 id="device-mk在Android中用于定义特定设备或特定产品的编译、链接、打包"><a href="#device-mk在Android中用于定义特定设备或特定产品的编译、链接、打包" class="headerlink" title="device.mk在Android中用于定义特定设备或特定产品的编译、链接、打包"></a><code>device.mk</code>在Android中用于定义特定设备或特定产品的<code>编译、链接、打包</code></h3><span id="more"></span><p><strong>.mk和.bp文件语法不同，举例均为mk语法，bp均有替代语法</strong></p><p>常见使用方法：</p><h3 id="1-需要编译某一模块时，在device-mk或者-mk中添加："><a href="#1-需要编译某一模块时，在device-mk或者-mk中添加：" class="headerlink" title="1. 需要编译某一模块时，在device.mk或者&lt;product_name&gt;.mk中添加："></a>1. 需要编译某一模块时，在<code>device.mk</code>或者<code>&lt;product_name&gt;.mk</code>中添加：</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">PRODUCT_PACKAGES += \</span><br><span class="line">    MyApp\</span><br></pre></td></tr></table></figure><h3 id="2-添加Android-propty："><a href="#2-添加Android-propty：" class="headerlink" title="2. 添加Android propty："></a>2. 添加Android propty：</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">PRODUCT_PROPERTY_OVERRIDES += \</span><br><span class="line">    wifi.interface=wlan0 \</span><br></pre></td></tr></table></figure><h3 id="3-添加其他mk-bp文件："><a href="#3-添加其他mk-bp文件：" class="headerlink" title="3. 添加其他mk&#x2F;bp文件："></a>3. 添加其他mk&#x2F;bp文件：</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$(call inherit-product, device/commom/xxx/new_add.mk)</span><br></pre></td></tr></table></figure><h3 id="4-拷贝文件"><a href="#4-拷贝文件" class="headerlink" title="4. 拷贝文件"></a>4. 拷贝文件</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">PRODUCT_COPY_FILES += \</span><br><span class="line">    device/&lt;company-name&gt;/&lt;device-name&gt;/etc/permissions/privapp-permissions-R.xml:system_ext/etc/permissions/privapp-permissions-R.xml \</span><br></pre></td></tr></table></figure><h3 id="5-添加编译log"><a href="#5-添加编译log" class="headerlink" title="5. 添加编译log"></a>5. 添加编译log</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$(warning <span class="string">&quot;[TEST] call here&quot;</span>)</span><br></pre></td></tr></table></figure><h3 id="6-使其他模块不编入系统："><a href="#6-使其他模块不编入系统：" class="headerlink" title="6. 使其他模块不编入系统："></a>6. 使其他模块不编入系统：</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">LOCAL_OVERRIDES_PACKAGES := AlarmClock</span><br></pre></td></tr></table></figure><p>参考：</p><p><a href="https://source.android.com/docs/setup/create/new-device?hl=zh-cn">https://source.android.com/docs/setup/create/new-device?hl=zh-cn</a></p><hr>]]></content>
    
    
    <summary type="html">&lt;h3 id=&quot;device-mk在Android中用于定义特定设备或特定产品的编译、链接、打包&quot;&gt;&lt;a href=&quot;#device-mk在Android中用于定义特定设备或特定产品的编译、链接、打包&quot; class=&quot;headerlink&quot; title=&quot;device.mk在Android中用于定义特定设备或特定产品的编译、链接、打包&quot;&gt;&lt;/a&gt;&lt;code&gt;device.mk&lt;/code&gt;在Android中用于定义特定设备或特定产品的&lt;code&gt;编译、链接、打包&lt;/code&gt;&lt;/h3&gt;</summary>
    
    
    
    <category term="Android技术" scheme="http://example.com/categories/Android%E6%8A%80%E6%9C%AF/"/>
    
    
  </entry>
  
  <entry>
    <title>Treble Hal</title>
    <link href="http://example.com/2024/01/03/HAL_Project_Treble/"/>
    <id>http://example.com/2024/01/03/HAL_Project_Treble/</id>
    <published>2024-01-03T06:01:22.112Z</published>
    <updated>2024-01-03T06:01:22.112Z</updated>
    
    <content type="html"><![CDATA[<h1 id="ANDROID-HAL-Project-Treble"><a href="#ANDROID-HAL-Project-Treble" class="headerlink" title="ANDROID HAL- Project Treble"></a>ANDROID HAL- <strong>Project Treble</strong></h1><h2 id="1-HAL至今有四种架构"><a href="#1-HAL至今有四种架构" class="headerlink" title="1. HAL至今有四种架构"></a>1. HAL至今有四种架构</h2><blockquote><ul><li>Treble Project 之前使用的实现架构,使用传统 HAL 和旧版 HAL</li><li>直通式（passthrough mode）：Framework 和 HAL 层工作在同一个进程当中</li><li>绑定式（binderized mode）：直通式 HAL binder 化，变为绑定式 HAL。Framework 和 HAL 层工作在不同的进程，之间通过 Binder 进行 IPC</li><li>纯绑定式 ：相对于<strong>绑定式</strong>来说，绑定式 HAL 中并不包含直通式 HAL，因此称为纯绑定式</li></ul></blockquote><span id="more"></span><p>根据谷歌要求，出厂时就搭载 8.0 的设备，除了谷歌规定的 <a href="mailto:&#97;&#x6e;&#100;&#x72;&#111;&#x69;&#100;&#x2e;&#104;&#x61;&#x72;&#100;&#x77;&#x61;&#114;&#x65;&#x2e;&#103;&#114;&#97;&#112;&#104;&#x69;&#99;&#x73;&#x2e;&#x6d;&#97;&#x70;&#112;&#101;&#x72;&#x40;&#x31;&#46;&#48;">&#97;&#x6e;&#100;&#x72;&#111;&#x69;&#100;&#x2e;&#104;&#x61;&#x72;&#100;&#x77;&#x61;&#114;&#x65;&#x2e;&#103;&#114;&#97;&#112;&#104;&#x69;&#99;&#x73;&#x2e;&#x6d;&#97;&#x70;&#112;&#101;&#x72;&#x40;&#x31;&#46;&#48;</a> 和 <a href="mailto:&#x61;&#110;&#100;&#x72;&#111;&#x69;&#100;&#46;&#104;&#x61;&#x72;&#100;&#x77;&#97;&#114;&#101;&#46;&#x72;&#x65;&#x6e;&#x64;&#x65;&#x72;&#x73;&#99;&#x72;&#x69;&#112;&#x74;&#64;&#x31;&#x2e;&#48;">&#x61;&#110;&#100;&#x72;&#111;&#x69;&#100;&#46;&#104;&#x61;&#x72;&#100;&#x77;&#97;&#114;&#101;&#46;&#x72;&#x65;&#x6e;&#x64;&#x65;&#x72;&#x73;&#99;&#x72;&#x69;&#112;&#x74;&#64;&#x31;&#x2e;&#48;</a> 需使用 ②直通模式，其它 HAL 只能采用 绑定式 和 纯绑定式 模式的实现架构。</p><hr><h2 id="2-绑定式"><a href="#2-绑定式" class="headerlink" title="2. 绑定式"></a>2. 绑定式</h2><ul><li><p>绑定式hal 在直通式的基础上，添加 service 进程，修改 transport 类型为 hwbinder</p></li><li><p>service 的注册使用的是 <a href="https://android.googlesource.com/platform/hardware/interfaces/+/refs/tags/android-8.1.0_r65/graphics/composer/2.1/default/service.cpp#43">defaultPassthroughServiceImplementation()</a> 方法</p></li><li><p><code>*-impl.so</code> 库文件通过 <code>HIDL_FETCH_I***</code> 方法来加载传统 HAL(一般硬件厂家提供so共享库)</p></li><li><p>厂商的实现都在 service 中</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">impl.so:</span><br><span class="line">            cc_library_shared &#123;</span><br><span class="line">                name: &quot;android.hardware.gnss@1.0-impl&quot;,</span><br><span class="line">                    ...</span><br><span class="line">                srcs: [...],</span><br><span class="line">                shared_libs: [...],</span><br><span class="line">            &#125;</span><br><span class="line">service:</span><br><span class="line">            cc_binary &#123;</span><br><span class="line">                name: &quot;android.hardware.gnss@1.0-service&quot;,</span><br><span class="line">                    ...</span><br><span class="line">                srcs: [&quot;service.cpp&quot;],</span><br><span class="line">                shared_libs: [...],</span><br><span class="line">            &#125;</span><br></pre></td></tr></table></figure></li></ul><hr><h2 id="3-纯绑定式"><a href="#3-纯绑定式" class="headerlink" title="3. 纯绑定式"></a>3. 纯绑定式</h2><ul><li>service 的注册方法都是 <code>registerAsService()</code>，在 manifest.xml 中的 transport 类型为 hwbinder</li><li>**不再单独编译 <code>*-impl.so</code>**，而是全编译进 service 中。</li></ul>   <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">cc_binary &#123;</span><br><span class="line">    name: &quot;android.hardware.gnss@2.0-service&quot;,</span><br><span class="line">...</span><br><span class="line">    srcs: [</span><br><span class="line">    &quot;service.cpp&quot;,</span><br><span class="line">        &quot;GnssConfiguration.cpp&quot;,</span><br><span class="line">... </span><br><span class="line">    ],</span><br><span class="line">    shared_libs: [...],</span><br><span class="line">    static_libs: [...],</span><br></pre></td></tr></table></figure><hr><p><strong>参考：</strong> </p><p><a href="https://blog.omitol.com/2018/11/09/android-treble-hidl/">https://blog.omitol.com/2018/11/09/android-treble-hidl/</a></p><p><a href="https://source.android.google.cn/docs/core/architecture/hidl?hl=zh-cn">HIDL  | Android 开源项目  | Android Open Source Project (google.cn)</a></p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;ANDROID-HAL-Project-Treble&quot;&gt;&lt;a href=&quot;#ANDROID-HAL-Project-Treble&quot; class=&quot;headerlink&quot; title=&quot;ANDROID HAL- Project Treble&quot;&gt;&lt;/a&gt;ANDROID HAL- &lt;strong&gt;Project Treble&lt;/strong&gt;&lt;/h1&gt;&lt;h2 id=&quot;1-HAL至今有四种架构&quot;&gt;&lt;a href=&quot;#1-HAL至今有四种架构&quot; class=&quot;headerlink&quot; title=&quot;1. HAL至今有四种架构&quot;&gt;&lt;/a&gt;1. HAL至今有四种架构&lt;/h2&gt;&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;Treble Project 之前使用的实现架构,使用传统 HAL 和旧版 HAL&lt;/li&gt;
&lt;li&gt;直通式（passthrough mode）：Framework 和 HAL 层工作在同一个进程当中&lt;/li&gt;
&lt;li&gt;绑定式（binderized mode）：直通式 HAL binder 化，变为绑定式 HAL。Framework 和 HAL 层工作在不同的进程，之间通过 Binder 进行 IPC&lt;/li&gt;
&lt;li&gt;纯绑定式 ：相对于&lt;strong&gt;绑定式&lt;/strong&gt;来说，绑定式 HAL 中并不包含直通式 HAL，因此称为纯绑定式&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    <category term="Android技术" scheme="http://example.com/categories/Android%E6%8A%80%E6%9C%AF/"/>
    
    
  </entry>
  
  <entry>
    <title>Android-vintf</title>
    <link href="http://example.com/2024/01/02/VINTF/"/>
    <id>http://example.com/2024/01/02/VINTF/</id>
    <published>2024-01-02T09:26:21.055Z</published>
    <updated>2024-01-02T09:26:21.055Z</updated>
    
    <content type="html"><![CDATA[<h1 id="VINTF"><a href="#VINTF" class="headerlink" title="VINTF"></a>VINTF</h1><p><a href="https://source.android.com/docs/core/architecture?hl=zh-cn">https://source.android.com/docs/core/architecture?hl=zh-cn</a></p><blockquote><p>Vendor Interface Object的缩写，即厂商接口对象。<br>android 8.0分离system和<a href="https://www.zhihu.com/search?q=vendor&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra=%7B%22sourceType%22:%22article%22,%22sourceId%22:%22661008492%22%7D">vendor</a>分区的机制之一，用来检查system和vendor依赖是否匹配。</p></blockquote><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>主要有<strong>两对 manifest 和 matrix</strong>，这两对清单和矩阵必须在 OTA 时进行协调，以确保设备可以获取与设备功能兼容的框架更新。Manifest 和 Matrix 在OTA升级前会进行匹配检查，以确保framework和device是兼容的。总的来说，manifest是提供端，matrix是需求端。</p><span id="more"></span> <p><img src="/images/VINTF/%E6%80%BB%E4%BD%93%E6%A1%86%E6%9E%B6.png"></p><blockquote><p><strong>设备清单</strong>描述了设备可以为框架提供的静态组件。<br><strong>框架兼容性矩阵</strong>描述了 Android 框架预期从给定设备中获取的内容。</p></blockquote><blockquote><p><strong>框架清单</strong>描述了框架可以为设备提供的高级层服务。<br><strong>设备兼容性矩阵</strong>描述了供应商映像需要框架提供的服务，此矩阵的组成在设备开发期间由开发者手动确定。</p></blockquote><ul><li><p><strong>Manifest 描述了提供给对方的feature（Provider）</strong></p></li><li><p><strong>Matrix 描述了需要对方提供的feature（Requirement）</strong></p><hr></li></ul><h2 id="Manifest"><a href="#Manifest" class="headerlink" title="Manifest"></a>Manifest</h2><p><strong>主要介绍设备清单（由设备提供）包含供应商清单和 ODM 清单。</strong></p><p><strong>Framework manifest文件是由Google手动生成的</strong></p><ul><li>在aosp源码的路径: <code>system/libhidl/manifest.xml</code></li><li>在设备上的路径: <code>/system/manifest.xml</code></li></ul><p><strong>Device manifest文件是和设备，硬件相关的</strong></p><ul><li>在aosp源码路径: <code>device/$&#123;VENDOR&#125;/$&#123;DEVICE&#125;/manifest.xml</code></li><li>在设备的路径: <code>/vendor/manifest.xml</code></li></ul><h3 id="Manifest-Fragment"><a href="#Manifest-Fragment" class="headerlink" title="Manifest Fragment"></a>Manifest Fragment</h3><p>在您的 <code>Android.bp</code> 或 <code>Android.mk</code> 文件中，将 <code>vintf_fragments</code> 添加到任意模块。例如，您可以修改实现了 HAL 的模块 (<code>my.package.foo@1.0-service-bar</code>)。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">... &#123;</span><br><span class="line">    ...</span><br><span class="line">    vintf_fragments: [&quot;manifest_foo.xml&quot;],</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">LOCAL_MODULE := ...</span><br><span class="line">LOCAL_VINTF_FRAGMENTS := manifest_foo.xml</span><br></pre></td></tr></table></figure><p>在名为 <code>manifest_foo.xml</code> 的文件中，为此模块创建清单。在构建时，此清单会添加到设备中。在此处添加条目与在设备的主清单中添加条目相同。这样，客户端就可以使用该接口，并允许 VTS 识别设备上的 HAL 实现。此清单会执行常规清单执行的任何操作。</p><p><strong>本质上，除了常规路径manifest，还会收集各处单独的device_manifest</strong></p><h3 id="example"><a href="#example" class="headerlink" title="example"></a>example</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- Comments, Legal notices, etc. here --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">manifest</span> <span class="attr">version</span>=<span class="string">&quot;1.0&quot;</span> <span class="attr">type</span>=<span class="string">&quot;framework&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">hal</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">name</span>&gt;</span>android.hidl.allocator<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">transport</span>&gt;</span>hwbinder<span class="tag">&lt;/<span class="name">transport</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">interface</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">name</span>&gt;</span>IAllocator<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">instance</span>&gt;</span>ashmem<span class="tag">&lt;/<span class="name">instance</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">interface</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">hal</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">hal</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">name</span>&gt;</span>android.hidl.memory<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">transport</span> <span class="attr">arch</span>=<span class="string">&quot;32+64&quot;</span>&gt;</span>passthrough<span class="tag">&lt;/<span class="name">transport</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">interface</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">name</span>&gt;</span>IMapper<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">instance</span>&gt;</span>ashmem<span class="tag">&lt;/<span class="name">instance</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">interface</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">hal</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">hal</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">name</span>&gt;</span>android.hidl.manager<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">transport</span>&gt;</span>hwbinder<span class="tag">&lt;/<span class="name">transport</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">interface</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">name</span>&gt;</span>IServiceManager<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">instance</span>&gt;</span>default<span class="tag">&lt;/<span class="name">instance</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">interface</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">hal</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">hal</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">name</span>&gt;</span>android.frameworks.sensorservice<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">transport</span>&gt;</span>hwbinder<span class="tag">&lt;/<span class="name">transport</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">interface</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">name</span>&gt;</span>ISensorManager<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">instance</span>&gt;</span>default<span class="tag">&lt;/<span class="name">instance</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">interface</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">hal</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">hal</span> <span class="attr">max-level</span>=<span class="string">&quot;5&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">name</span>&gt;</span>android.frameworks.schedulerservice<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">transport</span>&gt;</span>hwbinder<span class="tag">&lt;/<span class="name">transport</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">interface</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">name</span>&gt;</span>ISchedulingPolicyService<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">instance</span>&gt;</span>default<span class="tag">&lt;/<span class="name">instance</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">interface</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">hal</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">vendor-ndk</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>27<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">vendor-ndk</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">system-sdk</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>27<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">system-sdk</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">manifest</span>&gt;</span></span><br></pre></td></tr></table></figure><hr><h2 id="Matrix"><a href="#Matrix" class="headerlink" title="Matrix"></a>Matrix</h2><p><a href="https://source.android.google.cn/docs/core/architecture/vintf/comp-matrices?hl=zh-cn">兼容性矩阵  | Android 开源项目  | Android Open Source Project (google.cn)</a></p><p>Framework compatibility matrix描述的是framework对 device的需求，这个matrix文件是和Android Framework Image（system.img）关联的，Framework compatibility matrix的这些需要被device manifest支持。</p><p><strong>Device compatibility matrix描述了device对framework的需求。</strong></p><h3 id="example-1"><a href="#example-1" class="headerlink" title="example"></a>example</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- Comments, Legal notices, etc. here --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">compatibility-matrix</span> <span class="attr">version</span>=<span class="string">&quot;1.0&quot;</span> <span class="attr">type</span>=<span class="string">&quot;framework&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">hal</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">name</span>&gt;</span>vendor.foo.camera<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">interface</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">name</span>&gt;</span>IBetterCamera<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">instance</span>&gt;</span>default<span class="tag">&lt;/<span class="name">instance</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">interface</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">hal</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">compatibility-matrix</span>&gt;</span></span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;VINTF&quot;&gt;&lt;a href=&quot;#VINTF&quot; class=&quot;headerlink&quot; title=&quot;VINTF&quot;&gt;&lt;/a&gt;VINTF&lt;/h1&gt;&lt;p&gt;&lt;a href=&quot;https://source.android.com/docs/core/architecture?hl=zh-cn&quot;&gt;https://source.android.com/docs/core/architecture?hl=zh-cn&lt;/a&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Vendor Interface Object的缩写，即厂商接口对象。&lt;br&gt;android 8.0分离system和&lt;a href=&quot;https://www.zhihu.com/search?q=vendor&amp;search_source=Entity&amp;hybrid_search_source=Entity&amp;hybrid_search_extra=%7B%22sourceType%22:%22article%22,%22sourceId%22:%22661008492%22%7D&quot;&gt;vendor&lt;/a&gt;分区的机制之一，用来检查system和vendor依赖是否匹配。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h2&gt;&lt;p&gt;主要有&lt;strong&gt;两对 manifest 和 matrix&lt;/strong&gt;，这两对清单和矩阵必须在 OTA 时进行协调，以确保设备可以获取与设备功能兼容的框架更新。Manifest 和 Matrix 在OTA升级前会进行匹配检查，以确保framework和device是兼容的。总的来说，manifest是提供端，matrix是需求端。&lt;/p&gt;</summary>
    
    
    
    <category term="Android技术" scheme="http://example.com/categories/Android%E6%8A%80%E6%9C%AF/"/>
    
    
  </entry>
  
  <entry>
    <title>LEETCODE 7. 整数反转</title>
    <link href="http://example.com/2023/12/08/LEETCODE-7.%E6%95%B4%E6%95%B0%E5%8F%8D%E8%BD%AC/"/>
    <id>http://example.com/2023/12/08/LEETCODE-7.%E6%95%B4%E6%95%B0%E5%8F%8D%E8%BD%AC/</id>
    <published>2023-12-08T09:46:02.251Z</published>
    <updated>2023-12-08T09:46:02.251Z</updated>
    
    <content type="html"><![CDATA[<p>给你一个 32 位的有符号整数 <code>x</code> ，返回将 <code>x</code> 中的数字部分反转后的结果。</p><p>如果反转后整数超过 32 位的有符号整数的范围 <code>[−2^31, 2^31 − 1]</code> ，就返回 0。</p><p><strong>假设环境不允许存储 64 位整数（有符号或无符号）。</strong></p><span id="more"></span><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">e.g.</span><br><span class="line">输入：x = <span class="number">123</span></span><br><span class="line">输出：<span class="number">321</span></span><br><span class="line">    </span><br><span class="line">输入：x = <span class="number">-123</span></span><br><span class="line">输出：<span class="number">-321</span></span><br><span class="line">    </span><br><span class="line">输入：x = <span class="number">120</span></span><br><span class="line">输出：<span class="number">21</span></span><br><span class="line">    </span><br><span class="line">输入：x = <span class="number">0</span></span><br><span class="line">输出：<span class="number">0</span></span><br></pre></td></tr></table></figure><hr><p>该题逐步分析</p><p>解决思路：直接计算即可</p><ol><li><p>处理边界条件： 数据范围是否超出int32  【−2^31, 2^31 − 1】</p></li><li><p>当x在边界内，反转后数字有可能超出边界，所以需要实时判断</p></li><li><p>对于负数不用额外单独处理,与正数的计算流程一样：</p></li></ol><blockquote><p> -12%10&#x3D; -2<br> -12 &#x2F;10 &#x3D; -1</p><p> rev &#x3D; -2*10 + (-1) &#x3D; -21</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">reverse</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> rev = <span class="number">0</span>;  <span class="comment">//反转后数字</span></span><br><span class="line">        <span class="type">int</span> digist = <span class="number">0</span>; <span class="comment">//POP的x结尾数字</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(x != <span class="number">0</span>)&#123;</span><br><span class="line"></span><br><span class="line">            digist = x % <span class="number">10</span>;</span><br><span class="line">            x /= <span class="number">10</span>;</span><br><span class="line">            </span><br><span class="line"> <span class="comment">// 检查溢出</span></span><br><span class="line">            <span class="keyword">if</span>(rev &gt; INT_MAX/<span class="number">10</span> || (rev == INT_MAX/<span class="number">10</span> &amp;&amp; digist &gt; <span class="number">7</span>)) <span class="keyword">return</span> <span class="number">0</span>;  <span class="comment">//INT_MAX 的个位是7</span></span><br><span class="line">            <span class="keyword">if</span>(rev &lt; INT_MIN/<span class="number">10</span> || (rev == INT_MIN/<span class="number">10</span> &amp;&amp; digist&lt; <span class="number">-8</span>)) <span class="keyword">return</span> <span class="number">0</span>;  <span class="comment">//INT_MIN 的个位是-8</span></span><br><span class="line"></span><br><span class="line">            rev = rev*<span class="number">10</span>+digist;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> rev;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;给你一个 32 位的有符号整数 &lt;code&gt;x&lt;/code&gt; ，返回将 &lt;code&gt;x&lt;/code&gt; 中的数字部分反转后的结果。&lt;/p&gt;
&lt;p&gt;如果反转后整数超过 32 位的有符号整数的范围 &lt;code&gt;[−2^31, 2^31 − 1]&lt;/code&gt; ，就返回 0。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;假设环境不允许存储 64 位整数（有符号或无符号）。&lt;/strong&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="LeetCode" scheme="http://example.com/categories/LeetCode/"/>
    
    
  </entry>
  
  <entry>
    <title>LEETCODE 5. 最长回文子串</title>
    <link href="http://example.com/2023/12/04/LEETCODE-5.%E6%9C%80%E9%95%BF%E5%9B%9E%E6%96%87%E5%AD%90%E4%B8%B2/"/>
    <id>http://example.com/2023/12/04/LEETCODE-5.%E6%9C%80%E9%95%BF%E5%9B%9E%E6%96%87%E5%AD%90%E4%B8%B2/</id>
    <published>2023-12-04T06:18:51.207Z</published>
    <updated>2023-12-04T06:18:51.207Z</updated>
    
    <content type="html"><![CDATA[<h2 id="LEETCODE-5-最长回文子串"><a href="#LEETCODE-5-最长回文子串" class="headerlink" title="LEETCODE 5.  最长回文子串"></a>LEETCODE 5.  最长回文子串</h2><p>给你一个字符串 <code>s</code>，找到 <code>s</code> 中最长的回文子串。<br>如果字符串的反序与原始字符串相同，则该字符串称为回文字符串。</p><span id="more"></span><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">e.g.</span><br><span class="line">输入：s = <span class="string">&quot;babad&quot;</span></span><br><span class="line">输出：<span class="string">&quot;bab&quot;</span></span><br><span class="line">解释：<span class="string">&quot;aba&quot;</span> 同样是符合题意的答案。</span><br><span class="line">    </span><br><span class="line">输入：s = <span class="string">&quot;cbbd&quot;</span></span><br><span class="line">输出：<span class="string">&quot;bb&quot;</span></span><br></pre></td></tr></table></figure><hr><p>该题逐步分析</p><p>解决思路：动态规划（此题非最优解，主要了解动态规划思想）</p><p>1、状态定义：定义数组dp[ i ] [ j ]: 代表 从字符串中索引 从i 到 j 是否为回文串，若是设为true，否则false</p><p>2、状态转移： 若要确定dp[ i ] [ j ]是回文串，则需要满足</p><ul><li><p>s[ i ] &#x3D; s[ j ]</p></li><li><p>s[i+1] &#x3D; s[j-1]  </p><p>即最终状态转移方程： <em>P</em>(<em>i</em>,<em>j</em>)&#x3D;<em>P</em>(<em>i</em>+1,<em>j</em>−1)∧(<em>Si</em>&#x3D;&#x3D;<em>Sj</em>)</p><p><em>（思想方法类似于科学归纳法）</em></p></li></ul><p>3、边界条件初始化： 单独处理长度为 1 和 2 的字符串</p><ul><li><p>len &#x3D; 1: dp[ i ] [ i ] &#x3D; true</p></li><li><p>len &#x3D; 2 : if  s[ i ] &#x3D; s[ i+1 ]  ; then dp[ i ] [ i+1 ] &#x3D; true</p></li></ul><p>4、 返回值维护: 维护最长回文字串的起始位置和长度</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">string <span class="title">longestPalindrome</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span>  n = s.<span class="built_in">size</span>();</span><br><span class="line">        <span class="type">int</span> maxLen = <span class="number">1</span>;     <span class="comment">//最长字串的长度</span></span><br><span class="line">        <span class="type">int</span> begin = <span class="number">0</span>;  <span class="comment">//最长字串的起始位置</span></span><br><span class="line">        <span class="keyword">if</span>(n&lt;<span class="number">2</span>) <span class="keyword">return</span> s;   <span class="comment">//当字符串长度为1或0时，一定是回文子串</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//动态规划：创建一个二维数组来存储已经计算过的子问题的解</span></span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">dp</span>(n, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(n));      <span class="comment">// dp[i][j] 表示 s[i..j] 是否是回文串</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">            dp[i][i] = <span class="literal">true</span>;   <span class="comment">//单独处理L=1的子串，每个长度为1的字串都是回文串</span></span><br><span class="line">            <span class="keyword">if</span>(i&lt;n<span class="number">-1</span> &amp;&amp; s[i]==s[i+<span class="number">1</span>])&#123;    <span class="comment">//单独处理L=2的子串</span></span><br><span class="line">                dp[i][i+<span class="number">1</span>]=<span class="literal">true</span>;</span><br><span class="line">                maxLen = <span class="number">2</span>;</span><br><span class="line">                begin = i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//递推开始</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> L=<span class="number">3</span>;L&lt;=n;L++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">                <span class="type">int</span> j = L+i<span class="number">-1</span>;     <span class="comment">// j-i+1 = L</span></span><br><span class="line">                <span class="keyword">if</span>(j&gt;=n)    <span class="keyword">break</span>;  <span class="comment">//右边越界</span></span><br><span class="line">            </span><br><span class="line">                <span class="keyword">if</span>(s[i] != s[j])    dp[i][j] = <span class="literal">false</span>;</span><br><span class="line">                <span class="keyword">else</span>&#123;</span><br><span class="line">                    dp[i][j] = dp[i+<span class="number">1</span>][j<span class="number">-1</span>];</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(dp[i][j] &amp;&amp; j-i+<span class="number">1</span> &gt;= maxLen)&#123;</span><br><span class="line">                    maxLen = j-i+<span class="number">1</span>;</span><br><span class="line">                    begin = i;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span>  s.<span class="built_in">substr</span>(begin,maxLen);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;LEETCODE-5-最长回文子串&quot;&gt;&lt;a href=&quot;#LEETCODE-5-最长回文子串&quot; class=&quot;headerlink&quot; title=&quot;LEETCODE 5.  最长回文子串&quot;&gt;&lt;/a&gt;LEETCODE 5.  最长回文子串&lt;/h2&gt;&lt;p&gt;给你一个字符串 &lt;code&gt;s&lt;/code&gt;，找到 &lt;code&gt;s&lt;/code&gt; 中最长的回文子串。&lt;br&gt;如果字符串的反序与原始字符串相同，则该字符串称为回文字符串。&lt;/p&gt;</summary>
    
    
    
    <category term="LeetCode" scheme="http://example.com/categories/LeetCode/"/>
    
    
  </entry>
  
  <entry>
    <title>GDB 常用手顺</title>
    <link href="http://example.com/2023/12/01/GDB%20%E5%B8%B8%E7%94%A8%E6%89%8B%E9%A1%BA/"/>
    <id>http://example.com/2023/12/01/GDB%20%E5%B8%B8%E7%94%A8%E6%89%8B%E9%A1%BA/</id>
    <published>2023-12-01T06:02:04.070Z</published>
    <updated>2023-12-01T06:02:04.070Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>GDB usage</p></blockquote><span id="more"></span><h2 id="GDB-常用手顺"><a href="#GDB-常用手顺" class="headerlink" title="GDB 常用手顺"></a>GDB 常用手顺</h2><ol><li><h3 id="编译程序-gcc-编译时-加上-g-调试选项"><a href="#编译程序-gcc-编译时-加上-g-调试选项" class="headerlink" title="编译程序, gcc 编译时 加上-g 调试选项"></a>编译程序, gcc 编译时 加上-g 调试选项</h3><blockquote><p>gcc -g  main.c -o main.o</p></blockquote></li><li><h3 id="启动gdb"><a href="#启动gdb" class="headerlink" title="启动gdb"></a>启动gdb</h3><blockquote><p>gdb main.o</p></blockquote></li><li><h3 id="设置断点"><a href="#设置断点" class="headerlink" title="设置断点"></a>设置断点</h3><blockquote><p>(gdb) break main </p><p>&#x2F;&#x2F; 这会在 <code>main</code> 函数的开始处设置一个断点。也可以在特定的行号或函数上设置断点。</p></blockquote></li><li><h3 id="启动程序"><a href="#启动程序" class="headerlink" title="启动程序"></a>启动程序</h3><blockquote><p>(gdb) run</p><p>&#x2F;&#x2F;程序将开始执行并在达到第一个断点时停止。</p></blockquote></li><li><h3 id="单步执行和检查"><a href="#单步执行和检查" class="headerlink" title="单步执行和检查"></a>单步执行和检查</h3><blockquote><ul><li><code>next</code>（或 <code>n</code>）：执行下一行代码，但不进入函数内部。</li><li><code>step</code>（或 <code>s</code>）：执行下一行代码，如果是函数则进入函数内部。</li><li><code>print</code>（或 <code>p</code>）：打印变量的值或表达式的结果。</li><li><code>info locals</code>：显示当前函数的局部变量。</li><li><code>info args</code>：显示当前函数的参数。</li></ul></blockquote></li><li><h3 id="继续执行"><a href="#继续执行" class="headerlink" title="继续执行"></a>继续执行</h3><p>如果您想继续执行到下一个断点，使用：</p><blockquote><p>(gdb) continue</p></blockquote></li><li><h3 id="退出GDB"><a href="#退出GDB" class="headerlink" title="退出GDB"></a>退出GDB</h3><blockquote><p>(gdb) quit </p></blockquote></li><li><h3 id="常用指令"><a href="#常用指令" class="headerlink" title="常用指令"></a>常用指令</h3><blockquote><p>run：简记为 r ，其作用是运行程序，当遇到断点后，程序会在断点处停止运行，等待用户输入下一步的命令。 </p><p>continue （简写c ）：继续执行，到下一个断点处（或运行结束） </p><p>next：（简写 n），单步跟踪程序，当遇到函数调用时，也不进入此函数体；此命令同 step 的主要区别是，step 遇到用户自定义的函数，将步进到函数中去运行，而 next 则直接调用函数，不会进入到函数体内。 </p><p>step （简写s）：单步调试如果有函数调用，则进入函数；与命令n不同，n是不进入调用的函数的 </p><p>until：当你厌倦了在一个循环体内单步跟踪时，这个命令可以运行程序直到退出循环体。 </p><p>until+行号： 运行至某行，不仅仅用来跳出循环 finish： 运行程序，直到当前函数完成返回，并打印函数返回时的堆栈地址及参数值等信息。</p><p>call 函数(参数)：调用程序中可见的函数，并传递“参数”，如：call gdb_test(55) quit：简记为 q ，退出gdb</p><hr><p>print a : 打印变量a的值</p><p>print &amp;a : 打印变量a的地址</p><p>watch 表达式：设置一个监视点，一旦被监视的“表达式”的值改变，gdb将强行终止正在被调试的程序。如： watch a</p><hr><p>list ：简记为 l ，其作用就是列出程序的源代码，默认每次显示10行。 </p><p>list 行号：将显示当前文件以“行号”为中心的前后10行代码，如：list 12 </p><p>list 函数名：将显示“函数名”所在函数的源代码，如：list main</p><p>list ：不带参数，将接着上一次 list 命令的，输出下边的内容</p><hr><p>break n （简写b n）:在第n行处设置断点 （可以带上代码路径和代码名称： b OAGUPDATE.cpp:578）</p><p>b fn1 if a＞b：条件断点设置 </p><p>break func（break缩写为b）：在函数func()的入口处设置断点，如：break cb_button </p><p>delete 断点号n：删除第n个断点 </p><p>disable 断点号n：暂停第n个断点 </p><p>enable 断点号n：开启第n个断点 </p><p>clear 行号n：清除第n行的断点 </p><p>info b （info breakpoints） ：显示当前程序的断点设置情况 </p><p>delete breakpoints：清除所有断点：</p></blockquote></li></ol>]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;GDB usage&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    <category term="开发工具" scheme="http://example.com/categories/%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7/"/>
    
    
  </entry>
  
  <entry>
    <title>BootChart使用手顺</title>
    <link href="http://example.com/2023/12/01/bootchart%E4%BD%BF%E7%94%A8%E6%89%8B%E9%A1%BA/"/>
    <id>http://example.com/2023/12/01/bootchart%E4%BD%BF%E7%94%A8%E6%89%8B%E9%A1%BA/</id>
    <published>2023-12-01T06:02:04.070Z</published>
    <updated>2023-12-01T06:02:04.070Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>BootChart是用于linux启动过程性能分析的开源软件工具，它可以在内核装载后就开始运行，记录各个程序启动占用的时间、CPU以及硬盘读写，直到系统启动完成为止。</p></blockquote><span id="more"></span><h2 id="STEP1"><a href="#STEP1" class="headerlink" title="STEP1"></a>STEP1</h2><p>kernel config中打开以下四个配置：</p><blockquote><p>CONFIG_PROC_FS&#x3D;y<br>CONFIG_SCHEDSTATS&#x3D;y<br>CONFIG_SCHED_DEBUG&#x3D;y<br>CONFIG_LATENCYTOP&#x3D;y</p></blockquote><h2 id="STEP2"><a href="#STEP2" class="headerlink" title="STEP2"></a>STEP2</h2><p>bootchart工程编译生成两个产物：</p><blockquote><p>bootchartd: 放在目录&#x2F;sbin下<br>bootchartd.conf :放在目录&#x2F;etc下</p></blockquote><h2 id="STEP3"><a href="#STEP3" class="headerlink" title="STEP3"></a>STEP3</h2><p>修改uboot cmdline中，init&#x3D;bootchartd</p><h2 id="STEP4"><a href="#STEP4" class="headerlink" title="STEP4"></a>STEP4</h2><p>重启机器，在&#x2F;var&#x2F;log 目录下生成 .svg 文件   </p><p><em>注意事项</em>:<br><em>1、若系统开启selinux,需要考虑权限问题，不确定是否有影响可以先关闭selinux查看svg文件是否正常生成</em></p><p><em>2、必须保证&#x2F;var目录有可写权限，一般嵌入式系统默认rootfs是ro,需修改其权限</em></p><p><em>3、若无法在系统命令行对cmdline修改，需要在step3中源码修改完cmdline后，单独烧录uboot。顺序必须为先将两个产物放入对应目录，再修改cmdline, 否则会导致init 查找不到&#x2F;sbin&#x2F;bootchard 导致crash</em></p>]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;BootChart是用于linux启动过程性能分析的开源软件工具，它可以在内核装载后就开始运行，记录各个程序启动占用的时间、CPU以及硬盘读写，直到系统启动完成为止。&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    <category term="开发工具" scheme="http://example.com/categories/%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7/"/>
    
    
  </entry>
  
  <entry>
    <title>D-Bus_介绍&amp;工具使用</title>
    <link href="http://example.com/2023/12/01/D-Bus%20%E4%BB%8B%E7%BB%8D&amp;%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8/"/>
    <id>http://example.com/2023/12/01/D-Bus%20%E4%BB%8B%E7%BB%8D&amp;%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8/</id>
    <published>2023-12-01T06:02:04.066Z</published>
    <updated>2023-12-01T06:02:04.066Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>DBUS，数据总线，是一个低延迟，低开销，高可用性的ipc机制。<br>在D-Bus中，“bus”是核心的概念，它是一个通道：不同的程序可以通过这个通道做些操作，比如方法调用、发送信号和监听特定的信号。在一台机器上总线守护有多个实例(instance)。这些总线之间都是相互独立的。</p></blockquote><span id="more"></span><h1 id="一、D-Bus简介"><a href="#一、D-Bus简介" class="headerlink" title="一、D-Bus简介"></a>一、D-Bus简介</h1><p><img src="/images/D-Bus_%E4%BB%8B%E7%BB%8D&%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8/1.png"></p><h2 id="1、D-Bus简介"><a href="#1、D-Bus简介" class="headerlink" title="1、D-Bus简介"></a>1、D-Bus简介</h2><p>D-Bus是Desktop Bus的缩写，是针对桌面环境优化的IPC(InterProcess Communication)机制，用于进程间的通信或进程与内核的通信。<br>D-Bus是为Linux系统开发的进程间通信（IPC）和远程过程调用（RPC）机制，使用统一的通信协议来代替现有的各种IPC解决方案。D-Bus允许系统级进程（如：打印机和硬件驱动服务）和普通用户进程进行通信。<br>D-Bus使用一个快速的二进制消息传递协议，D-Bus协议的低延迟和低消耗特点适用于同一台机器的通信。D-Bus的规范目前由freedesktop.org项目定义，可供所有团体使用。<br>D-Bus不和低层的IPC直接竞争，比如sockets，shared memory或message queues。低层IPC有自己的特点，和D-Bus并不冲突。<br>与其他重量级的进程间通信技术不同，D-Bus是非事务的。D-Bus使用了状态以及连接的概念，比UDP等底层消息传输协议更“聪明”。但另一方面，D-Bus传送的是离散消息，与TCP协议将数据看做“流”有所不同。D-Bus支持点对点的消息传递以及广播&#x2F;订阅式的通信。</p><h2 id="2、不同IPC通信方式比较"><a href="#2、不同IPC通信方式比较" class="headerlink" title="2、不同IPC通信方式比较"></a>2、不同IPC通信方式比较</h2><p><strong>不同IPC通信机制的特点如下：</strong></p><blockquote><p>A、CORBA是用于面向对象编程中复杂IPC的一个强大的解决方案。<br>B、Bonobo是一个只用于GNOME的解决方案，基于CORBA并依赖于GObject。<br>C、DCOP是一个较轻量级的IPC框架，功能较少，但可以很好地集成到KDE桌面环境中。<br>D、SOAP和XML-RPC设计用于Web服务，因而使用HTTP作为其传输协议。<br>E、D-BUS设计用于桌面应用程序和OS通信。</p></blockquote><h2 id="3、D-Bus特性"><a href="#3、D-Bus特性" class="headerlink" title="3、D-Bus特性"></a>3、D-Bus特性</h2><blockquote><p>A、D-BUS的协议是低延迟而且低开销的，设计小巧且高效，以便最小化传送时间。从设计上避免往返交互并允许异步操作。<br>B、协议是二进制的，而不是文本，排除序列化过程。<br>C、考虑了字节序问题。<br>D、易用性：按照消息而不是字节流来工作，并且自动地处理了许多困难的IPC问题，并且D-Bus库以可以封装的方式来设计，开发者可以使用框架里存在的对象&#x2F;类型系统，而不用学习一种新的专用于IPC的对象&#x2F;类型系统。<br>E、请求时启动服务以及安全策略。<br>F、支持多语言（C&#x2F;C++&#x2F;Java&#x2F;C#&#x2F;Python&#x2F;Ruby），多平台(Linux&#x2F;windows&#x2F;maemo)。<br>G、采用C语言，而不是C++。<br>H、由于基本上不用于internet上的IPC，因此对本地IPC进行了特别优化。<br>I、提供服务注册，理论上可以进行无限扩展。</p></blockquote><h1 id="二、D-Bus架构"><a href="#二、D-Bus架构" class="headerlink" title="二、D-Bus架构"></a>二、D-Bus架构</h1><h2 id="1、D-Bus架构简介"><a href="#1、D-Bus架构简介" class="headerlink" title="1、D-Bus架构简介"></a>1、D-Bus架构简介</h2><p><strong>D-Bus是按一定的层次结构实现的，总体上D-Bus分为三层：</strong><br>A、接口层——接口层由libdbus库提供，进程通过libdbus库使用D-Bus的能力。通过底层库的接口可以实现两个进程之间进行连接并发送消息。<br>B、总线层——由消息总线守护进程(message bus daemon )提供，消息总线守护进程是基于libdbus底层库的，可以路由消息。消息总线守护进程负责进程间的消息路由和传递，其中包括Linux内核和Linux桌面环境的消息传递。<br>C、封装层——封装层是一系列基于特定应用程序框架的Wrapper库，将D-Bus底层接口封装成方便用户使用的通用API。</p><blockquote><p>A、接口层——接口层由libdbus库提供，进程通过libdbus库使用D-Bus的能力。通过底层库的接口可以实现两个进程之间进行连接并发送消息。<br>B、总线层——由消息总线守护进程(message bus daemon )提供，消息总线守护进程是基于libdbus底层库的，可以路由消息。消息总线守护进程负责进程间的消息路由和传递，其中包括Linux内核和Linux桌面环境的消息传递。<br>C、封装层——封装层是一系列基于特定应用程序框架的Wrapper库，将D-Bus底层接口封装成方便用户使用的通用API。</p></blockquote><h2 id="2、D-Bus接口层"><a href="#2、D-Bus接口层" class="headerlink" title="2、D-Bus接口层"></a>2、D-Bus接口层</h2><p>libdbus只支持点对点的通信，即只支持一进程与另外的一个进程进行通信。通信是基于消息的，消息包含头部和消息体。<br>libdbus提供C语言的底层API，API是为了将D-Bus绑定到特定的对象或是语言而设计的，官方文档中建议不要在应用上直接使用D-Bus的底层接口，推荐使用D-Bus的绑定，如QtDBus、GDBus、dbus-c++等实现。</p><h2 id="3、D-Bus总线层"><a href="#3、D-Bus总线层" class="headerlink" title="3、D-Bus总线层"></a>3、D-Bus总线层</h2><p>D-Bus总线层由消息总线守护进程(message bus daemon )提供。消息总线守护进程是一个后台进程,是&#x2F;usr&#x2F;bin&#x2F;dbus-daemon的一个运行实例, 负责消息的转发，dbus-daemon运行时会调用libdus的库。应用程序调用特定的应用程序框架的Wrapper库与dbus-daemon进行通信。应用程序通过D-Bus与其它进程通信必须先建立到消息总线守护进程实例的连接。<br>最常见的基于dbus的程序也符合C&#x2F;S结构。比如开发两个程序A和B，其中A是客户端，B是服务端。假设A要调用B的一个函数func，那么实际的消息流动方向是：A告诉dbus-daemon请求要调用B的func函数，然后dbus-daemon去调用B的func函数，如果func有返回值的话，B会把返回值告诉dbus-daemon，然后dbus- daemon再把返回值告诉A。如果B进程还没有启动，则dbus-daemon会自动的先把B进程启动起来。<br>通常情况下，Linux会有两个dbus-daemon进程，一个属于system，一个属于session，在用户登录的时候由dbus-launch启动。<br>大多数普通程序，都是使用session的dbus-daemon，默认情况下，A就是将消息发给属于session的dbus-daemon。<br>dbus-daemon是有地址的，环境变量DBUS_SESSION_BUS_ADDRESS用于表示当前登录用户的session的dbus-daemon进程的地址，可以使用下面命令查看。</p><blockquote><p>zyb@zyb:~$ echo $DBUS_SESSION_BUS_ADDRESS<br>unix:abstract&#x3D;&#x2F;tmp&#x2F;dbus-7BEdWvxPGx</p></blockquote><p>当用户登录进桌面环境的时候，系统启动脚本会调用到dbus-launch来启动一个dbus-daemon进程，同时会把启动的dbus-daemon地址赋予环境变量DBUS_SESSION_BUS_ADDRESS。<br>一般情况下，不需要考虑DBUS_SESSION_BUS_ADDRESS，但某些时候，单独启动一个dbus-daemon有助于程序的调试。<br>利用dbus-daemon自启动机制运行的服务进程，都是后台进程，标准输出设备已经被重定向，如果B进程有一些调试用的打印信息输出，则很难直接查看。此时，可以单独启动一个dbus-daemon，让A和B都使用自己启动的dbus-daemon，此时，dbus-daemon能把B的打印信息显示出来。<br><strong>先在终端下启动一个dbus-daemon，命令如下形式如下：</strong></p><blockquote><p>zyb@zyb:~$ DBUS_VERBOSE&#x3D;1 dbus-daemon –session –print-address<br>unix:abstract&#x3D;&#x2F;tmp&#x2F;dbus-uA3iIEfO1Z,guid&#x3D;4c58483b0f9112cb98abd34062287954</p></blockquote><p>如此启动的dbus-daemon会前台执行，并且打印出地址。然后，在执行A程序的时候，设置环境变量DBUS_SESSION_BUS_ADDRESS为刚才得到的地址值。</p><blockquote><p>DBUS_SESSION_BUS_ADDRESS&#x3D;unix:abstract&#x3D;&#x2F;tmp&#x2F;dbus-uA3iIEfO1Z,guid&#x3D;4c58483b0f9112cb98abd34062287954 .&#x2F;A</p></blockquote><p>此时运行程序A和B，使用自己启动的dbus-daemon来转发消息，并且会把B的打印信息显示出来。<br>消息总线守护进程是一个特殊的进程，用于管理系统内的总线，可以将一个进程的消息路由给另外一个进程。如果有很多应用程序连接到消息总线守护进程的总线上，总线能把消息路由到对应的一个或多个进程中去。因此在总线层上，实现了点对点通信的支持，也实现了广播&#x2F;订阅通信方式。<br>在最底层，D-Bus只支持点对点的通信，一般使用本地套接字(AF_UNIX)在应用和消息总线守护进程之间通信。D-Bus的点对点是经过bus daemon抽象过的，由bus daemon来完成寻址和发送消息，因此每个应用不必关心要把消息发给哪个进程。</p><h3 id="D-Bus发送消息通常包含如下步骤："><a href="#D-Bus发送消息通常包含如下步骤：" class="headerlink" title="D-Bus发送消息通常包含如下步骤："></a>D-Bus发送消息通常包含如下步骤：</h3><blockquote><p>A、应用程序创建和发送消息给消息总线守护进程。<br>B、消息总线守护进程对收到的消息进行分发处理。<br>C、目标程序接收到消息，然后根据消息的种类，做不同的响应：确认、应答、忽略。</p></blockquote><p>总线是D-Bus的进程间通信机制，一个系统中通常存在多条总线，总线由D-Bus总线守护进程管理。<br>最重要的总线为系统总线（System Bus），Linux内核引导时，系统总线就已被装入内存。只有Linux内核、Linux桌面环境和权限较高的程序才能向系统总线写入消息，以此保障系统安全性，防止有恶意进程假冒Linux发送消息。<br>会话总线（Session Buses）由普通进程创建，可同时存在多条。会话总线属于某个进程私有，用于进程间传递消息。</p><h2 id="4、D-Bus封装层"><a href="#4、D-Bus封装层" class="headerlink" title="4、D-Bus封装层"></a>4、D-Bus封装层</h2><p>D-Bus封装层是将libdbus底层API绑定到特定的对象系统或是语言中，將不便使用的libdbus底层API封裝成可以在应用层使用的高級API，如libdbus-glib、libdbus-qt等。<br>D-Bus在很多不同的编程语言上都有其接口实现。不同语言的接口封装了D-Bus低级API，提供了更符合编程语言的语法结构。<br>实现D-Bus接口的语言正在逐渐增加。在C语言中，有最底层的API，但其实现及使用上非常复杂。C语言中另一个实用化的实现基于GLib。在Java、Perl、Python等都有D-Bus接口实现。</p><h1 id="三、D-Bus术语"><a href="#三、D-Bus术语" class="headerlink" title="三、D-Bus术语"></a>三、D-Bus术语</h1><h2 id="1、D-Bus术语简介"><a href="#1、D-Bus术语简介" class="headerlink" title="1、D-Bus术语简介"></a>1、D-Bus术语简介</h2><p>总线是消息总线守护进程(message bus daemon)的运行实例，每个总线都有一个地址，应用进程就是通过总线地址和相应的总线连接的。总线上的每一个连接都有一个连接名，连接名也称bus name。每个连接上有至少一个对象，通常有多个对象，对象使用对象路径唯一标识。对象要实现一个或多个接口，每个接口包含一组方法和信号。</p><h2 id="2、总线（Bus）"><a href="#2、总线（Bus）" class="headerlink" title="2、总线（Bus）"></a>2、总线（Bus）</h2><p>在D-Bus中，总线(bus)是核心的概念：不同的程序可以通过总线进行某些操作，比如方法调用、发送信号和监听特定的信号。总线通常有两种，系统总线(system bus)和会话总线(session bus)，系统总线通常只有一条，用户总线在用户登录时创建。<br>系统总线是一个持久的总线，在系统启动时就创建，供系统内核和后台进程使用，具有较高的安全性。系统总线最常用是发送系统消息，比如：插入一个新的存储设备、有新的网络连接等。<br>会话总线是在某个用户登录后启动，属于某个用户私有，是某用户的应用程序用来通话的通道。在很多嵌入式系统中，只有一个用户ID登录运行，因此只有一个会话总线。<br>一条消息总线就是一个消息路由器，是消息总线守护进程(message bus daemon)的一个实例。</p><h2 id="3、地址-Address"><a href="#3、地址-Address" class="headerlink" title="3、地址(Address)"></a>3、地址(Address)</h2><p>使用d-bus的应用程序既可以是server端也可以是client端，server端监听到来的连接，client端连接到server端，一旦连接建立，消息就可以流转。如果使用dbus daemon，所有的应用程序都是client端，dbus daemon监听所有的连接，应用程序初始化连接到dbus daemon。<br>每一条总线都有一个地址，进程通过总线的地址连接到总线上。一个D-Bus的地址是指server端用于监听，client端将要连接的地方，例如unix:path&#x3D;&#x2F;tmp&#x2F;abcedf标识server端将在路径&#x2F;tmp&#x2F;abcedf的UNIX domain socket监听，client端将要连接到这个地址。地址可以是指定的TCP&#x2F;IP socket或者其他在或者将在D-Bus协议中定义的传输方式。<br>如果使用bus daemon，libdbus将通过读取环境变量DBUS_SESSION_BUS_ADDRESS自动获取session bus damon的地址，通过检查一个指定的UNIX domain socket路径获取system bus的地址。<br>如果使用D-bus，但不是daemon，需要定义哪个应用是server端，哪个是client端，并定义一套机制用于认可server端的地址。</p><h2 id="4、连接名-Bus-Name"><a href="#4、连接名-Bus-Name" class="headerlink" title="4、连接名(Bus Name)"></a>4、连接名(Bus Name)</h2><p>总线上的每个连接都有一个或多个名字。当连接建立以后，D-Bus 服务会分配一个不可改变的连接名，称为唯一连接名(unique connection name)，唯一连接名即使在进程结束后也不会再被其他进程所使用。<br>唯一连接名以冒号开头，如“:34-907”。但唯一连接名总是临时分配，无法确定，也难以记忆，因此应用可以要求有另外一个名字公共名(well-known name)来对应唯一连接名。例如可以使用“com.mycompany”来映射“:34-907”。应用程序可能会要求拥有额外的公共名(well-known name)。例如，可以写一个规范来定义一个名字叫做 com.mycompany.TextEditor。协议可以指定自己拥有名字为com.mycompany.TextEditor的连接，一个路径为&#x2F;com&#x2F;mycompany&#x2F;TextFileManager的对象，对象拥有接口org.freedesktop.FileHandler。应用程序就可以发送消息到总线上的连接名字，对象和接口以执行方法调用。</p><p>连接名可以用于跟踪应用程序的生命周期。当应用退出（或者崩溃）时，与总线的连接将被OS内核关掉，总线将会发送通知，告诉剩余的应用程序。</p><h2 id="5、对象和对象路径-Object-and-Object-Path"><a href="#5、对象和对象路径-Object-and-Object-Path" class="headerlink" title="5、对象和对象路径(Object and Object Path)"></a>5、对象和对象路径(Object and Object Path)</h2><p>D-Bus的对象和面向对象语言中的对象含义是不同的，D-Bus的对象表示的是D-Bus通道中信息流向的端点。对象由客户进程创建，并在连接进程中保持不变。<br>所有使用D-BUS的应用程序都包含一些对象, 当经由一个D-BUS连接收到一条消息时，消息是被发往一个对象而不是整个应用程序。应用程序框架中定义了这样的对象，如GObject，QObject等，在D-Bus中称为原生对象（native object）。<br>对于底层的D-Bus协议，即libdbus API，并不理会原生对象，使用对象路径(object path)的概念。通过对象路径，高层API接口可以绑定到对象，允许远程应用指向对象。对象路径如同文件系统路径，例如一个对象可能叫做“&#x2F;org&#x2F;kde&#x2F;kspread&#x2F;sheets&#x2F;3&#x2F;cells&#x2F;4&#x2F;5”。<br>对象路径在全局（session或者system）是唯一的，用于消息的路由。</p><h2 id="6、接口（Interface）"><a href="#6、接口（Interface）" class="headerlink" title="6、接口（Interface）"></a>6、接口（Interface）</h2><p>每一个对象支持一个或者多个接口，接口是一组方法和信号的集和，接口定义一个对象实体的类型。D-Bus对接口的命名方式，类似org.freedesktop.Introspectable。开发人员通常使用编程语言名字作为接口名字。</p><h2 id="7、方法-Methods"><a href="#7、方法-Methods" class="headerlink" title="7、方法(Methods)"></a>7、方法(Methods)</h2><p>每一个对象有两类成员：方法和信号。方法是一段函数代码，带有输入和输出；信号是广播给所有兴趣的其他实体，信号可以带有数据payload。</p><p>客户向某对象发送一个请求，即对象被请求执行一个明确的、有名称的动作。如果客户请求执行一个目标对象未提供的方法，将会产生一个错误。方法的定义可以支持输入参数。对于每个请求，都有一个包含请求结果以及结果数据(输出参数)的响应返回给请求者。当请求无法完成时，响应中将包含异常信息，其中至少有异常名称以及错误信息。<br>大多数语言都将这些封装在自身的语言机制中，比如将参数包装进消息包，将异常信息转换成语言自身的异常等等。在这些实现中，向远程对象传递一个字符串参数就好像是在本地执行一个字符串参数的函数一样简单。此时不再需要数据类型转换、数据复制等繁琐工作，语言本身封装了一切底层实现。</p><h2 id="8、信号-Signals"><a href="#8、信号-Signals" class="headerlink" title="8、信号(Signals)"></a>8、信号(Signals)</h2><p>信号依然遵从面向对象概念，信号是从对象发出但没有特定目的地址的单向数据广播。客户进程可以预先注册其感兴趣的信号，如特定名称的信号或从某个对象发出的信号等。当对象发出信号后，所有订阅了该信号的客户进程将收到此信号的复本。接收端可能有多种情况出现，或者有一个客户进程，或者有多个客户进程，或者根本没有客户进程对这个信号感兴趣。对于信号来说没有响应消息，发出信号的对象不会知道是不是有客户进程在接收，有多少客户进程接收，以及从客户进程收到任何反馈。<br>信号可以有参数。<br>但信号是单向通信，因此不可能像方法一样具有输入输出参数。D-Bus允许客户进程通过参数比对过滤其需要的信号。<br>信号一般用来广播一些客户可能会感兴趣的事件，比如某个其它的客户进程与总线的连接断开等。这些信号来自总线对象，因此从信号中客户进程可以分辨断线是由于正常退出、被杀掉或者程序崩溃。</p><h2 id="9、代理-Proxies"><a href="#9、代理-Proxies" class="headerlink" title="9、代理(Proxies)"></a>9、代理(Proxies)</h2><p>代理对象用来表示其他的remote object。当触发了proxy对象的method时，将会在D-Bus上发送一个method_call的消息，并等待答复，根据答复返回。<br>总线上的对象一般通过代理来访问。总线上的对象位于客户进程以外，而客户可以调用本地接口与对象通信，此时，本地接口充当了代理的角色。当触发了代理对象的方法时，将会在D-Bus上发送一个method_call的消息，并等待答复返回，就象使用一个本地对象一样。<br>一些语言的代理支持“断线重连”。比如所连接的对象在某段时间里暂时断开了与总线的连接，代理会自动重连到相同的连接名并重新找到对象，程序甚至不会知道目标对象有段时间不可用。并不是所有的语言都支持这一特性，在GLib中的两种代理中的一种支持。<br>比如不用代理时的代码如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Message message = new Message(<span class="string">&quot;/remote/object/path&quot;</span>, <span class="string">&quot;MethodName&quot;</span>, arg1, arg2); </span><br><span class="line">Connection connection = getBusConnection();           </span><br><span class="line">connection.send(message);           </span><br><span class="line">Message reply = connection.waitForReply(message);           </span><br><span class="line"><span class="keyword">if</span> (reply.isError()) &#123;                         </span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;              </span><br><span class="line">     Object returnValue = reply.getReturnValue();           </span><br><span class="line"> &#125; </span><br></pre></td></tr></table></figure><p>采用代理时对应的代码则是：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Proxy proxy = new Proxy(getBusConnection(), <span class="string">&quot;/remote/object/path&quot;</span>);      </span><br><span class="line">Object returnValue = proxy.MethodName(arg1, arg2);</span><br></pre></td></tr></table></figure><h2 id="10、服务"><a href="#10、服务" class="headerlink" title="10、服务"></a>10、服务</h2><p>服务是 D-BUS 的最高层次抽象，服务的实现当前还在不断发展变化。应用程序可以通过一个总线来注册一个服务，如果成功，则应用程序就已经获得了服务。其他应用程序可以检查在总线上是否已经存在一个特定的服务，如果没有可以要求总线启动它。<br>当通过总线进行通信时，应用程序会获取服务名称。服务名称是应用程序如何选择同一总线上的其他应用程序的依据。服务名称由总线守护进程进行代理，用于将消息从一个应用程序路由到另一个应用程序。服务名称的类似概念是IP地址和主机名：计算机通常具有一个IP地址，并且根据其向网络提供的服务，可以具有与之相关联的一个或多个主机名。<br>另一方面，如果不使用总线，服务名称也不会使用。如果再将它与计算机网络进行比较，这将等同于点到点网络：因为对等方是已知的，所以不需要使用主机名来查找它或它的IP地址。<br>总线服务名称的格式实际上与主机名非常相似：它是字母和数字的点分隔序列。常见的做法是根据服务定义的组织的域名来命名自己的服务名称。例如，D-Bus服务由freedesktop.org定义，可以使用org.freedesktop.DBus服务名称在总线上找到它。</p><h1 id="四、消息和消息总线"><a href="#四、消息和消息总线" class="headerlink" title="四、消息和消息总线"></a>四、消息和消息总线</h1><h2 id="1、消息简介"><a href="#1、消息简介" class="headerlink" title="1、消息简介"></a>1、消息简介</h2><p>D-Bus通信机制是通过进程间发送消息实现的，最基本的D-Bus协议是一对一的通信协议。与socket通信不同，D-Bus是面向消息的协议。但如果使用高层的绑定接口，不会直接接触到D-Bus的消息。<br><strong>D-Bus 有四种类型的消息：</strong></p><blockquote><p>A、method_call方法调用<br>B、method_return方法返回<br>C、error错误<br>D、signal信号</p></blockquote><p>代理中的远程对象调用涉及到了消息总线以及method_call和method_return两类消息。<br>消息有消息头(header)和消息体(body)。消息头包含消息体的路由信息，消息体是净荷，通常包含的是参数。消息头通常包含发送进程的连接名(Bus Name)、方法或者信号名等等，其中有一字段是用于描述消息体中的参数的类型的，例如“i”标识32位整数，“ii”表示2个32位整数。</p><h2 id="2、调用method的流程"><a href="#2、调用method的流程" class="headerlink" title="2、调用method的流程"></a>2、调用method的流程</h2><p>进程A要调用进程B的一个method，进程A发送method_call消息到进程B，进程B回复method_return消息。在发送消息时，发送方会在消息中添加不同的序列号，同样，回复消息中也会含有序列号，以便对应。</p><p><strong>调用method的流程如下：</strong></p><blockquote><p>A、在发送method_call消息时，如果使用了代理，进程A要调用进程B的某方法，不用构造method_call消息，只需调用代理的本地方法，代理会自动生成method_call消息发送到消息总线上。<br>B、如果使用底层API，进程A需要构造一个method_call消息。method_call消息包含对应进程B的连接名、方法名、方法所需参数、进程B中的对象路径和进程B中声明此方法的接口。<br>C、将method_call消息发送到消息总线上。<br>D、信息总线检查消息头中的目的连接名，当找到一个进程与此连接名对应时发送消息到该进程。当找不到一个进程与此连接名对应时，返回给进程A一个error消息。<br>E、进程B解析消息，如果是采用底层API方式，则直接调用方法，然后发宋应答消息到消息总线。如果是D-BUs高级API接口，会先检测对象路径、接口、方法名称，然后把消息转换成对应的本地对象（如GObject，QT中的QObject等）的方法，调用本地对象方法后再将应答结果转换成应答消息发给消息总线。<br>F、消息总线接收到method_return消息，将把method_return消息直接发给发出调用消息的进程。<br>消息总线不会对总线上的消息进行重排序。如果发送了两条消息到同一个进程，将按照发送顺序接收到。接收进程不需要按照顺序发出应答消息，例如在多线程中处理这些消息，应答消息的发出是没有顺序的。消息都有一个序列号可以与应答消息进行配对。</p></blockquote><h2 id="3、发送signal的流程"><a href="#3、发送signal的流程" class="headerlink" title="3、发送signal的流程"></a>3、发送signal的流程</h2><p>发送信号是单向广播的，信号的发送者不知道对信号作响应的有哪些进程，所以信号发送是没有返回值的。信号接收者通过向消息总线注册匹配规则来表示对某信号感兴趣，而匹配规则通常包含信号的发出者和信号名。<br><strong>信号发送的流程如下：</strong></p><blockquote><p>A、当使用dbus底层接口时，信号需要应用进程自己创建和发送到消息总线；使用dbus高层API接口时，可以使用相关对象进行发送。信号消息包含有声明信号的接口名、信号名、所在进程对应的连接名和相关参数。<br>B、连接到消息总线上的进程如果对某个信号感兴趣，则注册相应的匹配规则。消息总线保持有匹配规则表。<br>C、消息总线根据匹配规则表，将信号发送到对信号感兴趣的进程。<br>D、每个进程收到信号后，如果使用dbus高级API接口，可以选择触发代理对象上的信号。如果使用dbus底层接口，需要检查发送者名称和信号名称，然后决定怎么做。</p></blockquote><h2 id="4、DBus工具"><a href="#4、DBus工具" class="headerlink" title="4、DBus工具"></a>4、DBus工具</h2><p>D-Bus提供了两个小工具：dbus-send 和dbus-monitor。可以用dbus-send发送消息，用dbus-monitor监视通道上流动的消息。</p><h3 id="dbus-send"><a href="#dbus-send" class="headerlink" title="dbus-send"></a>dbus-send</h3><p>用于发送一个消息到消息通道上，使用格式如下：</p><blockquote><p>dbus-send [–system | –session] –type&#x3D;TYPE –print-reply –dest&#x3D;连接名对象路径接口名.方法名参数类型:参数值参数类型:参数值<br>dbus-send –session –type&#x3D;method_call –print-reply –dest&#x3D;连接名对象路径接口名.方法名 参数类型:参数值 参数类型:参数值</p></blockquote><p>dbus-send支持的参数类型包括：string, int32, uint32, double, byte, boolean。</p><h3 id="dbus-monitor"><a href="#dbus-monitor" class="headerlink" title="dbus-monitor"></a>dbus-monitor</h3><p>用于打印消息通道上的消息，使用格式如下：</p><blockquote><p>dbus-monitor [–system | –session | –address ADDRESS] [–profile | –monitor] [watch expressions]<br>dbus-monitor “type&#x3D;’signal’, sender&#x3D;’org.gnome.TypingMonitor’, interface&#x3D;’org.gnome.TypingMonitor’”</p></blockquote><h2 id="5、消息总线上的方法和信号"><a href="#5、消息总线上的方法和信号" class="headerlink" title="5、消息总线上的方法和信号"></a>5、消息总线上的方法和信号</h2><p>消息总线是一个特殊的应用，主要关于消息总线上的方法和信号。</p><h3 id="A、Introspection"><a href="#A、Introspection" class="headerlink" title="A、Introspection"></a>A、Introspection</h3><blockquote><p>消息总线上有一个接口org.freedesktop.DBus.Introspectable，接口中声明了一个方法Introspect，不带参数，将返回一个XML string，XML字符串描述接口、方法、信号。</p></blockquote><h3 id="B、消息总线上的方法和信号"><a href="#B、消息总线上的方法和信号" class="headerlink" title="B、消息总线上的方法和信号"></a>B、消息总线上的方法和信号</h3><p>可以通过向名称为“org.freedesktop.DBus”的连接上的对象“&#x2F;”发送消息来调用消息总线提供的方法。消息总线对象支持标准接口”org.freedesktop.DBus.Introspectable”，可以调用org.freedesktop.DBus.Introspectable.Introspect方法查看消息总线对象支持的接口。</p><blockquote><p>dbus-send –session –type&#x3D;method_call –print-reply –dest&#x3D;org.freedesktop.DBus &#x2F; org.freedesktop.DBus.Introspectable.Introspect</p></blockquote><p>用户总线对象支持标准接口“org.freedesktop.DBus.Introspectable”和接口“org.freedesktop.DBus”。<br>接口“org.freedesktop.DBus”有18个方法和3个信号。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><span class="line">&lt;interface name=<span class="string">&quot;org.freedesktop.DBus&quot;</span>&gt;</span><br><span class="line">  &lt;method name=<span class="string">&quot;Hello&quot;</span>&gt;</span><br><span class="line">    &lt;arg direction=<span class="string">&quot;out&quot;</span> type=<span class="string">&quot;s&quot;</span>/&gt;</span><br><span class="line">  &lt;/method&gt;</span><br><span class="line">  &lt;method name=<span class="string">&quot;RequestName&quot;</span>&gt;</span><br><span class="line">    &lt;arg direction=<span class="string">&quot;in&quot;</span> type=<span class="string">&quot;s&quot;</span>/&gt;</span><br><span class="line">    &lt;arg direction=<span class="string">&quot;in&quot;</span> type=<span class="string">&quot;u&quot;</span>/&gt;</span><br><span class="line">    &lt;arg direction=<span class="string">&quot;out&quot;</span> type=<span class="string">&quot;u&quot;</span>/&gt;</span><br><span class="line">  &lt;/method&gt;</span><br><span class="line">  &lt;method name=<span class="string">&quot;ReleaseName&quot;</span>&gt;</span><br><span class="line">    &lt;arg direction=<span class="string">&quot;in&quot;</span> type=<span class="string">&quot;s&quot;</span>/&gt;</span><br><span class="line">    &lt;arg direction=<span class="string">&quot;out&quot;</span> type=<span class="string">&quot;u&quot;</span>/&gt;</span><br><span class="line">  &lt;/method&gt;</span><br><span class="line">  &lt;method name=<span class="string">&quot;StartServiceByName&quot;</span>&gt;</span><br><span class="line">    &lt;arg direction=<span class="string">&quot;in&quot;</span> type=<span class="string">&quot;s&quot;</span>/&gt;</span><br><span class="line">    &lt;arg direction=<span class="string">&quot;in&quot;</span> type=<span class="string">&quot;u&quot;</span>/&gt;</span><br><span class="line">    &lt;arg direction=<span class="string">&quot;out&quot;</span> type=<span class="string">&quot;u&quot;</span>/&gt;</span><br><span class="line">  &lt;/method&gt;</span><br><span class="line">  &lt;method name=<span class="string">&quot;UpdateActivationEnvironment&quot;</span>&gt;</span><br><span class="line">    &lt;arg direction=<span class="string">&quot;in&quot;</span> type=<span class="string">&quot;a&#123;ss&#125;&quot;</span>/&gt;</span><br><span class="line">  &lt;/method&gt;</span><br><span class="line">  &lt;method name=<span class="string">&quot;NameHasOwner&quot;</span>&gt;</span><br><span class="line">    &lt;arg direction=<span class="string">&quot;in&quot;</span> type=<span class="string">&quot;s&quot;</span>/&gt;</span><br><span class="line">    &lt;arg direction=<span class="string">&quot;out&quot;</span> type=<span class="string">&quot;b&quot;</span>/&gt;</span><br><span class="line">  &lt;/method&gt;</span><br><span class="line">  &lt;method name=<span class="string">&quot;ListNames&quot;</span>&gt;</span><br><span class="line">    &lt;arg direction=<span class="string">&quot;out&quot;</span> type=<span class="string">&quot;as&quot;</span>/&gt;</span><br><span class="line">  &lt;/method&gt;</span><br><span class="line">  &lt;method name=<span class="string">&quot;ListActivatableNames&quot;</span>&gt;</span><br><span class="line">    &lt;arg direction=<span class="string">&quot;out&quot;</span> type=<span class="string">&quot;as&quot;</span>/&gt;</span><br><span class="line">  &lt;/method&gt;</span><br><span class="line">  &lt;method name=<span class="string">&quot;AddMatch&quot;</span>&gt;</span><br><span class="line">    &lt;arg direction=<span class="string">&quot;in&quot;</span> type=<span class="string">&quot;s&quot;</span>/&gt;</span><br><span class="line">  &lt;/method&gt;</span><br><span class="line">  &lt;method name=<span class="string">&quot;RemoveMatch&quot;</span>&gt;</span><br><span class="line">    &lt;arg direction=<span class="string">&quot;in&quot;</span> type=<span class="string">&quot;s&quot;</span>/&gt;</span><br><span class="line">  &lt;/method&gt;</span><br><span class="line">  &lt;method name=<span class="string">&quot;GetNameOwner&quot;</span>&gt;</span><br><span class="line">    &lt;arg direction=<span class="string">&quot;in&quot;</span> type=<span class="string">&quot;s&quot;</span>/&gt;</span><br><span class="line">    &lt;arg direction=<span class="string">&quot;out&quot;</span> type=<span class="string">&quot;s&quot;</span>/&gt;</span><br><span class="line">  &lt;/method&gt;</span><br><span class="line">  &lt;method name=<span class="string">&quot;ListQueuedOwners&quot;</span>&gt;</span><br><span class="line">    &lt;arg direction=<span class="string">&quot;in&quot;</span> type=<span class="string">&quot;s&quot;</span>/&gt;</span><br><span class="line">    &lt;arg direction=<span class="string">&quot;out&quot;</span> type=<span class="string">&quot;as&quot;</span>/&gt;</span><br><span class="line">  &lt;/method&gt;</span><br><span class="line">  &lt;method name=<span class="string">&quot;GetConnectionUnixUser&quot;</span>&gt;</span><br><span class="line">    &lt;arg direction=<span class="string">&quot;in&quot;</span> type=<span class="string">&quot;s&quot;</span>/&gt;</span><br><span class="line">    &lt;arg direction=<span class="string">&quot;out&quot;</span> type=<span class="string">&quot;u&quot;</span>/&gt;</span><br><span class="line">  &lt;/method&gt;</span><br><span class="line">  &lt;method name=<span class="string">&quot;GetConnectionUnixProcessID&quot;</span>&gt;</span><br><span class="line">    &lt;arg direction=<span class="string">&quot;in&quot;</span> type=<span class="string">&quot;s&quot;</span>/&gt;</span><br><span class="line">    &lt;arg direction=<span class="string">&quot;out&quot;</span> type=<span class="string">&quot;u&quot;</span>/&gt;</span><br><span class="line">  &lt;/method&gt;</span><br><span class="line">  &lt;method name=<span class="string">&quot;GetAdtAuditSessionData&quot;</span>&gt;</span><br><span class="line">    &lt;arg direction=<span class="string">&quot;in&quot;</span> type=<span class="string">&quot;s&quot;</span>/&gt;</span><br><span class="line">    &lt;arg direction=<span class="string">&quot;out&quot;</span> type=<span class="string">&quot;ay&quot;</span>/&gt;</span><br><span class="line">  &lt;/method&gt;</span><br><span class="line">  &lt;method name=<span class="string">&quot;GetConnectionSELinuxSecurityContext&quot;</span>&gt;</span><br><span class="line">    &lt;arg direction=<span class="string">&quot;in&quot;</span> type=<span class="string">&quot;s&quot;</span>/&gt;</span><br><span class="line">    &lt;arg direction=<span class="string">&quot;out&quot;</span> type=<span class="string">&quot;ay&quot;</span>/&gt;</span><br><span class="line">  &lt;/method&gt;</span><br><span class="line">  &lt;method name=<span class="string">&quot;ReloadConfig&quot;</span>&gt;</span><br><span class="line">  &lt;/method&gt;</span><br><span class="line">  &lt;method name=<span class="string">&quot;GetId&quot;</span>&gt;</span><br><span class="line">    &lt;arg direction=<span class="string">&quot;out&quot;</span> type=<span class="string">&quot;s&quot;</span>/&gt;</span><br><span class="line">  &lt;/method&gt;</span><br><span class="line">  &lt;signal name=<span class="string">&quot;NameOwnerChanged&quot;</span>&gt;</span><br><span class="line">    &lt;arg type=<span class="string">&quot;s&quot;</span>/&gt;</span><br><span class="line">    &lt;arg type=<span class="string">&quot;s&quot;</span>/&gt;</span><br><span class="line">    &lt;arg type=<span class="string">&quot;s&quot;</span>/&gt;</span><br><span class="line">  &lt;/signal&gt;</span><br><span class="line">  &lt;signal name=<span class="string">&quot;NameLost&quot;</span>&gt;</span><br><span class="line">    &lt;arg type=<span class="string">&quot;s&quot;</span>/&gt;</span><br><span class="line">  &lt;/signal&gt;</span><br><span class="line">  &lt;signal name=<span class="string">&quot;NameAcquired&quot;</span>&gt;</span><br><span class="line">    &lt;arg type=<span class="string">&quot;s&quot;</span>/&gt;</span><br><span class="line">  &lt;/signal&gt;</span><br><span class="line">&lt;/interface&gt;</span><br><span class="line">&lt;interface name=<span class="string">&quot;org.freedesktop.DBus.Introspectable&quot;</span>&gt;</span><br><span class="line">  &lt;method name=<span class="string">&quot;Introspect&quot;</span>&gt;</span><br><span class="line">    &lt;arg direction=<span class="string">&quot;out&quot;</span> type=<span class="string">&quot;s&quot;</span>/&gt;</span><br><span class="line">  &lt;/method&gt;</span><br><span class="line">&lt;/interface&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;DBUS，数据总线，是一个低延迟，低开销，高可用性的ipc机制。&lt;br&gt;在D-Bus中，“bus”是核心的概念，它是一个通道：不同的程序可以通过这个通道做些操作，比如方法调用、发送信号和监听特定的信号。在一台机器上总线守护有多个实例(instance)。这些总线之间都是相互独立的。&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    <category term="开发工具" scheme="http://example.com/categories/%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7/"/>
    
    
  </entry>
  
  <entry>
    <title>Android Property参数简介</title>
    <link href="http://example.com/2023/11/30/ANDROID%20property%20%E5%8F%82%E6%95%B0%E7%AE%80%E4%BB%8B/"/>
    <id>http://example.com/2023/11/30/ANDROID%20property%20%E5%8F%82%E6%95%B0%E7%AE%80%E4%BB%8B/</id>
    <published>2023-11-30T09:27:44.013Z</published>
    <updated>2023-11-30T09:27:44.013Z</updated>
    
    <content type="html"><![CDATA[<p><a name="3060-1621846615933"></a>在系统初始化时，Android将分配一块共享内存来存储property。这是在“init”守护进程中完成的，其源代码位于：device&#x2F;system&#x2F;init。“init”守护进程将启动PropertyService。</p><p><a name="qpdj-1679278003424"></a>属性服务正在“init”守护进程中运行。每个想要设置属性的客户端都需要连接到属性服务并向属性服务发送消息。属性服务将在共享内存中更新&#x2F;创建属性。任何想要获取属性的客户端都可以直接从共享内存中读取属性。这提高了读取性能。</p><span id="more"></span><p><a name="bjnd-1679278020126"></a><a name="t53l-1679278020702"></a>属性服务启动后会从系统文件中读取默认的属性，并写入共享内存中，以下4个文件为按顺序读取：</p><p><a name="k6us-1679278038355"></a>&#x2F;default.prop</p><p><a name="4ogz-1679278038357"></a>&#x2F;system&#x2F;build.prop</p><p><a name="udfl-1679278038359"></a>&#x2F;system&#x2F;default.prop</p><p><a name="4xes-1679278038361"></a>&#x2F;data&#x2F;local.prop</p><p><a name="4uvm-1679278038363"></a>后读入的属性将覆盖前面读取的相同的属性。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> PROP\_PATH\_RAMDISK\_DEFAULT  <span class="string">&quot;/default.prop&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PROP\_PATH\_SYSTEM\_BUILD     <span class="string">&quot;/system/build.prop&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PROP\_PATH\_SYSTEM\_DEFAULT   <span class="string">&quot;/system/default.prop&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PROP\_PATH\_LOCAL\_OVERRIDE   <span class="string">&quot;/data/local.prop&quot;</span></span></span><br></pre></td></tr></table></figure><p><strong>设置属性，ro.开头的属性将不能被更改属性值，persist.开头的属性会被永久纪录，其他属性值在重新开机后均将被丢弃</strong></p><p><strong>加载永久属性时，会读入在目录&#x2F;data&#x2F;property下所有名字以persist.开头的文件内容，作为该名字对应的属性值。</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">property_set</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *name, <span class="type">const</span> <span class="type">char</span> *value)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(namelen &lt; <span class="number">1</span>) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"> </span><br><span class="line">    pi = (prop_info*) __system_property_find(name);</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">if</span>(pi != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">/* ro.* properties may NEVER be modified once set */</span></span><br><span class="line">        <span class="keyword">if</span>(!<span class="built_in">strncmp</span>(name, <span class="string">&quot;ro.&quot;</span>, <span class="number">3</span>)) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"> </span><br><span class="line">        pa = __system_property_area__;</span><br><span class="line">        update_prop_info(pi, value, valuelen);</span><br><span class="line">        pa-&gt;serial++;</span><br><span class="line">        __futex_wake(&amp;pa-&gt;serial, INT32_MAX);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        pa = __system_property_area__;</span><br><span class="line">        <span class="keyword">if</span>(pa-&gt;count == PA_COUNT_MAX) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"> </span><br><span class="line">        pi = pa_info_array + pa-&gt;count;</span><br><span class="line">        pi-&gt;serial = (valuelen &lt;&lt; <span class="number">24</span>);</span><br><span class="line">        <span class="built_in">memcpy</span>(pi-&gt;name, name, namelen + <span class="number">1</span>);</span><br><span class="line">        <span class="built_in">memcpy</span>(pi-&gt;value, value, valuelen + <span class="number">1</span>);</span><br><span class="line"> </span><br><span class="line">        pa-&gt;toc[pa-&gt;count] =</span><br><span class="line">            (namelen &lt;&lt; <span class="number">24</span>) | (((<span class="type">unsigned</span>) pi) - ((<span class="type">unsigned</span>) pa));</span><br><span class="line"> </span><br><span class="line">        pa-&gt;count++;</span><br><span class="line">        pa-&gt;serial++;</span><br><span class="line">        __futex_wake(&amp;pa-&gt;serial, INT32_MAX);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/* If name starts with &quot;net.&quot; treat as a DNS property. */</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">strncmp</span>(<span class="string">&quot;net.&quot;</span>, name, <span class="built_in">strlen</span>(<span class="string">&quot;net.&quot;</span>)) == <span class="number">0</span>)  &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">strcmp</span>(<span class="string">&quot;net.change&quot;</span>, name) == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">       <span class="comment">/*</span></span><br><span class="line"><span class="comment">        * The &#x27;net.change&#x27; property is a special property used track when any</span></span><br><span class="line"><span class="comment">        * &#x27;net.*&#x27; property name is updated. It is _ONLY_ updated here. Its value</span></span><br><span class="line"><span class="comment">        * contains the last updated &#x27;net.*&#x27; property.</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        property_set(<span class="string">&quot;net.change&quot;</span>, name);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (persistent_properties_loaded &amp;&amp;</span><br><span class="line">            <span class="built_in">strncmp</span>(<span class="string">&quot;persist.&quot;</span>, name, <span class="built_in">strlen</span>(<span class="string">&quot;persist.&quot;</span>)) == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * Don&#x27;t write properties to disk until after we have read all default properties</span></span><br><span class="line"><span class="comment">         * to prevent them from being overwritten by default values.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        write_persistent_property(name, value);</span><br><span class="line">    &#125;</span><br><span class="line">    property_changed(name, value);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;a name=&quot;3060-1621846615933&quot;&gt;&lt;/a&gt;在系统初始化时，Android将分配一块共享内存来存储property。这是在“init”守护进程中完成的，其源代码位于：device&amp;#x2F;system&amp;#x2F;init。“init”守护进程将启动PropertyService。&lt;/p&gt;
&lt;p&gt;&lt;a name=&quot;qpdj-1679278003424&quot;&gt;&lt;/a&gt;属性服务正在“init”守护进程中运行。每个想要设置属性的客户端都需要连接到属性服务并向属性服务发送消息。属性服务将在共享内存中更新&amp;#x2F;创建属性。任何想要获取属性的客户端都可以直接从共享内存中读取属性。这提高了读取性能。&lt;/p&gt;</summary>
    
    
    
    <category term="Android技术" scheme="http://example.com/categories/Android%E6%8A%80%E6%9C%AF/"/>
    
    
  </entry>
  
  <entry>
    <title>Makefile基本语法</title>
    <link href="http://example.com/2023/11/30/Makefile%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95/"/>
    <id>http://example.com/2023/11/30/Makefile%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95/</id>
    <published>2023-11-30T09:27:44.013Z</published>
    <updated>2023-11-30T09:27:44.013Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Makefile-通过-文件生成时间-来判断文件是否有被修改过-，-进而判断文件是否需要重新编译"><a href="#Makefile-通过-文件生成时间-来判断文件是否有被修改过-，-进而判断文件是否需要重新编译" class="headerlink" title="Makefile 通过 文件生成时间 来判断文件是否有被修改过 ， 进而判断文件是否需要重新编译"></a>Makefile 通过 文件生成时间 来判断文件是否有被修改过 ， 进而判断文件是否需要重新编译</h2><ol><li>如果工程没有被编译过，则所有C文件编译并被链接</li><li>若工程中某几个文件被修改，则单独编译这几个文件，并重新链接</li><li>若头文件.h 被修改</li></ol><span id="more"></span><p><img src="/images/Makefile%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95/1.png"></p><h1 id="Make-命令-执行流程："><a href="#Make-命令-执行流程：" class="headerlink" title="Make 命令 执行流程："></a>Make 命令 执行流程：</h1><ol><li>Make 会在当前目录下按顺序寻找GNUmakefile , makefile , Makefile</li><li>若未找到则报错，若找到 则把第一个目标作为最终目标</li><li>按照堆栈顺序，以此找到每一个目标文件，判断新旧，必要时重新生成目标文件，直到生成最终目标（可执行文件）</li><li>寻找过程中，若某个依赖不存在，则直接退出，报错</li><li>标号不会被关联到，必须通过命令行参数才能执行（如 clean）</li><li>若改变了源文件或头文件，相关联的目标文件都需要重新编译，直接输入make即可</li></ol><h1 id=""><a href="#" class="headerlink" title=""></a></h1><p>.PHONY:<br>表示伪目标，如clean,用.PHONY声明后，以后有了真的clean编译命令，也不会发生错误。（伪目标clean是清空，make clean ，需要命令行输入命令执行; 编译命令clean 是如main.c 一样的）</p><h2 id="Makefile-书写简化："><a href="#Makefile-书写简化：" class="headerlink" title="Makefile 书写简化："></a>Makefile 书写简化：</h2><ol><li>相同部分用引用代替<br><img src="/images/Makefile%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95/2.png"></li><li>所有文件共同依赖的文件单独列出<br><img src="/images/Makefile%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95/3.png"></li><li>其他目标文件只列出个性依赖<br><img src="/images/Makefile%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95/4.png"></li></ol><h2 id="Makefile-设计方法"><a href="#Makefile-设计方法" class="headerlink" title="Makefile  设计方法"></a>Makefile  设计方法</h2><ol><li>隐含规则<br>2.生成多个文件</li><li>Makefile嵌套</li><li>使用变量</li><li>使用函数</li></ol><h4 id="1-隐含规则（当-make-r-则禁止使用任何隐含规则）"><a href="#1-隐含规则（当-make-r-则禁止使用任何隐含规则）" class="headerlink" title="1. 隐含规则（当 make -r 则禁止使用任何隐含规则）"></a>1. 隐含规则（当 make -r 则禁止使用任何隐含规则）</h4><p><img src="/images/Makefile%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95/5.png"><br>（例）自动扩展<br>如<br>main. : main.o  foo.o<br>cc -o foo foo.o bar.o<br>main依赖于foo.o,但是我们没有写foo.c生成foo.o  此时make会自动利用语法帮我们生成foo.o</p><h4 id="2-同时生成多个可执行文件"><a href="#2-同时生成多个可执行文件" class="headerlink" title="2. 同时生成多个可执行文件"></a>2. 同时生成多个可执行文件</h4><p><img src="/images/Makefile%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95/6.png"><br>这样可同时生成 P1 P2 P3三个可执行程序<br>（ 当makefile 命令出错时，make 会直接中断返回，在命令前加上- ，则当这条命令报错时，可以让make忽略，继续执行下面的命令）</p><h4 id="3-Makefile-嵌套执行"><a href="#3-Makefile-嵌套执行" class="headerlink" title="3.    Makefile 嵌套执行"></a>3.    Makefile 嵌套执行</h4><p><img src="/images/Makefile%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95/7.png"><br><img src="/images/Makefile%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95/8.png"><br>@代表执行时“静悄悄”，不输出执行信息</p><h4 id="4-使用变量"><a href="#4-使用变量" class="headerlink" title="4. 使用变量"></a>4. 使用变量</h4><p>Makefile中可以使用变量，类似于C语言中的宏，但值可以修改<br>变量大小写敏感<br>变量名 不应包含 ：# &#x3D; 或者空格<br>使用变量时用$(var)的形式</p><h3 id="变量的两种方式："><a href="#变量的两种方式：" class="headerlink" title="变量的两种方式："></a>变量的两种方式：</h3><h4 id="（1）-递归展开变量"><a href="#（1）-递归展开变量" class="headerlink" title="（1） 递归展开变量"></a>（1） 递归展开变量</h4><p>使用“&#x3D;”表示，可先使用，后定义<br>（弊病：有可能递归定义，造成无限展开）</p><h4 id="（2）-简单展开变量"><a href="#（2）-简单展开变量" class="headerlink" title="（2） 简单展开变量"></a>（2） 简单展开变量</h4><p>使用“：&#x3D;”表示，须先定义，再使用<br>（：&#x3D; 作用为 取当前赋值的上一个如：<br>a &#x3D; 3<br>b &#x3D; a<br>a &#x3D; 4<br>则输出b的值为3<br>）</p><h4 id="（3）系统环境变量"><a href="#（3）系统环境变量" class="headerlink" title="（3）系统环境变量"></a>（3）系统环境变量</h4><p><img src="/images/Makefile%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95/9.png"></p><h4 id="（4）-自动化变量"><a href="#（4）-自动化变量" class="headerlink" title="（4） 自动化变量"></a>（4） 自动化变量</h4><p><img src="/images/Makefile%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95/10.png"></p><h4 id="（5）-预定义变量"><a href="#（5）-预定义变量" class="headerlink" title="（5） 预定义变量"></a>（5） 预定义变量</h4><p><img src="/images/Makefile%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95/11.png"></p><h4 id="（6）函数"><a href="#（6）函数" class="headerlink" title="（6）函数"></a>（6）函数</h4><p><img src="/images/Makefile%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95/12.png"></p>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;Makefile-通过-文件生成时间-来判断文件是否有被修改过-，-进而判断文件是否需要重新编译&quot;&gt;&lt;a href=&quot;#Makefile-通过-文件生成时间-来判断文件是否有被修改过-，-进而判断文件是否需要重新编译&quot; class=&quot;headerlink&quot; title=&quot;Makefile 通过 文件生成时间 来判断文件是否有被修改过 ， 进而判断文件是否需要重新编译&quot;&gt;&lt;/a&gt;Makefile 通过 文件生成时间 来判断文件是否有被修改过 ， 进而判断文件是否需要重新编译&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;如果工程没有被编译过，则所有C文件编译并被链接&lt;/li&gt;
&lt;li&gt;若工程中某几个文件被修改，则单独编译这几个文件，并重新链接&lt;/li&gt;
&lt;li&gt;若头文件.h 被修改&lt;/li&gt;
&lt;/ol&gt;</summary>
    
    
    
    <category term="Android技术" scheme="http://example.com/categories/Android%E6%8A%80%E6%9C%AF/"/>
    
    
  </entry>
  
  <entry>
    <title>AudioTrack概述</title>
    <link href="http://example.com/2023/11/30/AudioTrack%E6%A6%82%E8%BF%B0/"/>
    <id>http://example.com/2023/11/30/AudioTrack%E6%A6%82%E8%BF%B0/</id>
    <published>2023-11-30T07:53:37.844Z</published>
    <updated>2023-11-30T07:53:37.844Z</updated>
    
    <content type="html"><![CDATA[<p> AudioTrack类用来管理、播放单个音频资源，它只能播放PCM数据，其他音频格式（aac、amr、opus、flac等）需要经过解码成PCM才能使用。</p><h2 id="运行模式"><a href="#运行模式" class="headerlink" title="运行模式"></a>运行模式</h2><p>AudioTrack可以运行两种模式：</p><blockquote><p>流模式<br>静态模式</p></blockquote><span id="more"></span><h3 id="流模式"><a href="#流模式" class="headerlink" title="流模式"></a>流模式</h3><p> 可以将连续的数据流写入AudioTrack,进行播放。播放音频数据块时，这种模式最有用。<br>如：</p><ul><li>声音持续的时间太长，无法容纳在内存中;</li><li>由于音频数据的特性（太大的采样率，每个采样的比特数…）而太大而无法容纳在内存中；</li><li>在播放先前排队的音频时收到或生成的声音。</li></ul><h3 id="静态模式"><a href="#静态模式" class="headerlink" title="静态模式"></a>静态模式</h3><p> 当处理很短的音频并且需要以最小延迟播放时，应该选择静态模式。对于经常播放的UI和游戏声音而言，静态模式将是首选方式，并且可能会产生最小的开销。</p><h2 id="缓冲区"><a href="#缓冲区" class="headerlink" title="缓冲区"></a>缓冲区</h2><p> 当创建AudioTrack时，AudioTrack将初始化其关联的音频缓冲区。在构造期间指定的此缓冲区大小决定了AudioTrack在数据用尽之前可以播放多长时间。<br> 对于静态模式，此大小是可以从中播放的最大音频数据大小。<br> 对于流模式，数据将以小于等于此缓冲区大小的块的形式写入音频接收器。</p><p>AudioTrack播放<br>这里主要说一下AudioTrack的流模式使用。<br>基本步骤</p><blockquote><p>获取最小缓冲区大小（创建AudioTrack对象所需）；<br>创建AudioTrack对象；<br>调用AudioTrack play方法，开始播放。<br>写入音频数据；<br>停止播放<br>释放对象。</p></blockquote><h3 id="1-获取最小缓冲区大小"><a href="#1-获取最小缓冲区大小" class="headerlink" title="1 获取最小缓冲区大小"></a>1 获取最小缓冲区大小</h3><p>:::tips<br>int minSize &#x3D; AudioTrack.getMinBufferSize(sampleRate,<br>        outChannelConfig, AudioFormat.ENCODING_PCM_16BIT);<br>:::</p><p>sampleRate：采样频率<br>outChannelConfig：声道配置，CHANNEL_OUT_MONO、CHANNEL_OUT_STEREO。<br>audioFormat：音频编码，AudioFormat.ENCODING_PCM_16BIT、ENCODING_PCM_8BIT.</p><h3 id="2-初始化"><a href="#2-初始化" class="headerlink" title="2 初始化"></a>2 初始化</h3><p>AudioTrack构造器已经过时，推荐使用AudioTrack.Builder进行创建AudioTrack对象。</p><p>:::tips<br>mTrack &#x3D; new AudioTrack.Builder()<br>        .setAudioAttributes(new AudioAttributes.Builder()<br>                .setUsage(AudioAttributes.USAGE_MEDIA)<br>                .setContentType(AudioAttributes.CONTENT_TYPE_MUSIC)<br>                .build())<br>        .setAudioFormat(new AudioFormat.Builder()<br>                .setEncoding(AudioFormat.ENCODING_PCM_16BIT)<br>                .setSampleRate(sampleRate)<br>                .setChannelMask(outChannelConfig)<br>                .build())<br>        .setBufferSizeInBytes(minSize)<br>        .build();<br>:::<br>创建AudioTrack对象，同时设置采样率、声道数、音频格式，缓冲区大小。</p><h3 id="3-开始播放"><a href="#3-开始播放" class="headerlink" title="3 开始播放"></a>3 开始播放</h3><p>调用play前，可以先向缓冲区写入音频数据。也可以后写。<br>:::tips<br>mTrack.play();<br>:::<br>如果不限调用write,或者write数量不足，则调用play处于欠载状态，这种情况下不会播放。只有后续将数据写入，播放才会真正开始播放。</p><h3 id="4-写入数据"><a href="#4-写入数据" class="headerlink" title="4 写入数据"></a>4 写入数据</h3><p>:::tips<br>mTrack.write(audioData.data, 0, size);<br>:::</p><p>将音频数据写入音频接收器以进行播放。<br>该方法默认情况是阻塞模式，直到所有数据都排入队列进行播放为止，并且将返回完整的传输计数。 但是，如果轨道在进入时停止或暂停，或者另一个线程通过调用停止或暂停来中断写入，或者在写入过程中发生I &#x2F; O错误，则写入可能会返回较短的传输计数。</p><blockquote><p>WRITE_BLOCKING：阻塞模式，写入将被阻塞，直到所有数据都已写入音频接收器为止。<br>WRITE_NON_BLOCKING：非阻塞模式，在排队尽可能多的音频数据以进行播放而不会阻塞，写入将立即返回。</p></blockquote><h3 id="5-停止"><a href="#5-停止" class="headerlink" title="5 停止"></a>5 停止</h3><p>调用以下两种方法都可以停止播放，并且都可以恢复播放，停止时机略有不同。</p><p>1 停止播放音频数据，调用此方法后，音频将在播放了最后写入的缓冲区后停止播放。<br>:::tips<br>mTrack.stop();<br>:::</p><p>2 暂停音频数据的播放。 未播放的数据将不会被丢弃。 随后调用play将播放此数据。<br>:::tips<br>mTrack.pause();<br>:::</p><h3 id="6-释放内存"><a href="#6-释放内存" class="headerlink" title="6 释放内存"></a>6 释放内存</h3><p>释放本地AudioRecord资源。<br>调用release（）之后，将无法再使用该对象，并且应将引用设置为null。<br>:::tips<br>mTrack.release();<br>mTrack&#x3D;null;<br>:::</p>]]></content>
    
    
    <summary type="html">&lt;p&gt; AudioTrack类用来管理、播放单个音频资源，它只能播放PCM数据，其他音频格式（aac、amr、opus、flac等）需要经过解码成PCM才能使用。&lt;/p&gt;
&lt;h2 id=&quot;运行模式&quot;&gt;&lt;a href=&quot;#运行模式&quot; class=&quot;headerlink&quot; title=&quot;运行模式&quot;&gt;&lt;/a&gt;运行模式&lt;/h2&gt;&lt;p&gt;AudioTrack可以运行两种模式：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;流模式&lt;br&gt;静态模式&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    <category term="Android技术" scheme="http://example.com/categories/Android%E6%8A%80%E6%9C%AF/"/>
    
    
  </entry>
  
  <entry>
    <title>LEETCODE 1. 两数之和</title>
    <link href="http://example.com/2023/11/30/LEETCODE-1.%20%E4%B8%A4%E6%95%B0%E4%B9%8B%E5%92%8C/"/>
    <id>http://example.com/2023/11/30/LEETCODE-1.%20%E4%B8%A4%E6%95%B0%E4%B9%8B%E5%92%8C/</id>
    <published>2023-11-30T07:53:37.844Z</published>
    <updated>2023-11-30T07:53:37.844Z</updated>
    
    <content type="html"><![CDATA[<h2 id="LEETCODE-1-两数之和"><a href="#LEETCODE-1-两数之和" class="headerlink" title="LEETCODE 1.  两数之和"></a>LEETCODE 1.  两数之和</h2><p>给定一个整数数组 <code>nums</code> 和一个整数目标值 <code>target</code>，请你在该数组中找出 和为目标值 <em><code>target</code></em> 的那两个整数，并返回它们的数组下标。<br>你可以假设每种输入只会对应一个答案。但是，数组中同一个元素在答案里不能重复出现。<br>你可以按任意顺序返回答案</p><span id="more"></span><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">e.g.</span><br><span class="line">输入：nums = [2,7,11,15], target = 9</span><br><span class="line">输出：[0,1]</span><br><span class="line">解释：因为 nums[0] + nums[1] == 9 ，返回 [0, 1] </span><br></pre></td></tr></table></figure><p>该题主要调查最简单的哈希表的概念和使用，或者两个for暴力枚举</p><p>哈希表如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">twoSum</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> target)</span> </span>&#123;</span><br><span class="line">        unordered_map&lt;<span class="type">int</span>,<span class="type">int</span>&gt;hashtable;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span> ; i&lt;nums.<span class="built_in">size</span>();++i)&#123;</span><br><span class="line">            <span class="keyword">auto</span> it = hashtable.<span class="built_in">find</span>(target-nums[i]);</span><br><span class="line">            <span class="keyword">if</span>(it != hashtable.<span class="built_in">end</span>())&#123;</span><br><span class="line">                <span class="keyword">return</span> &#123;it-&gt;second,i&#125;;</span><br><span class="line">            &#125;</span><br><span class="line">            hashtable[nums[i]] = i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span>&#123;&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;LEETCODE-1-两数之和&quot;&gt;&lt;a href=&quot;#LEETCODE-1-两数之和&quot; class=&quot;headerlink&quot; title=&quot;LEETCODE 1.  两数之和&quot;&gt;&lt;/a&gt;LEETCODE 1.  两数之和&lt;/h2&gt;&lt;p&gt;给定一个整数数组 &lt;code&gt;nums&lt;/code&gt; 和一个整数目标值 &lt;code&gt;target&lt;/code&gt;，请你在该数组中找出 和为目标值 &lt;em&gt;&lt;code&gt;target&lt;/code&gt;&lt;/em&gt; 的那两个整数，并返回它们的数组下标。&lt;br&gt;你可以假设每种输入只会对应一个答案。但是，数组中同一个元素在答案里不能重复出现。&lt;br&gt;你可以按任意顺序返回答案&lt;/p&gt;</summary>
    
    
    
    <category term="LeetCode" scheme="http://example.com/categories/LeetCode/"/>
    
    
  </entry>
  
  <entry>
    <title>LEETCODE 2. 两数相加</title>
    <link href="http://example.com/2023/11/30/LEETCODE-2.%E4%B8%A4%E6%95%B0%E7%9B%B8%E5%8A%A0/"/>
    <id>http://example.com/2023/11/30/LEETCODE-2.%E4%B8%A4%E6%95%B0%E7%9B%B8%E5%8A%A0/</id>
    <published>2023-11-30T07:53:37.844Z</published>
    <updated>2023-11-30T07:53:37.844Z</updated>
    
    <content type="html"><![CDATA[<h2 id="LEETCODE-2-两数相加"><a href="#LEETCODE-2-两数相加" class="headerlink" title="LEETCODE 2.  两数相加"></a>LEETCODE 2.  两数相加</h2><p>给你两个 <strong>非空</strong> 的链表，表示两个非负的整数。它们每位数字都是按照 <strong>逆序</strong> 的方式存储的，并且每个节点只能存储 <strong>一位</strong> 数字。</p><p>请你将两个数相加，并以相同形式返回一个表示和的链表。</p><p>你可以假设除了数字 0 之外，这两个数都不会以 0 开头。</p><span id="more"></span><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">e.g.</span><br><span class="line">输入l1 : <span class="number">2</span>-&gt;<span class="number">4</span>-&gt;<span class="number">3</span></span><br><span class="line">l2 : <span class="number">5</span>-&gt;<span class="number">6</span>-&gt;<span class="number">4</span></span><br><span class="line">输出l3 : <span class="number">7</span>-&gt;<span class="number">0</span>-&gt;<span class="number">8</span></span><br><span class="line">解释   ：<span class="number">342</span> + <span class="number">465</span> = <span class="number">807</span></span><br></pre></td></tr></table></figure><hr><p>该题逐步分析</p><p>1、由于两个链表都是逆序存储，所以对应位置的数可以直接相加</p><p>2、对于目标 链表，需要设定头指针和尾指针来进行元素位移</p><p>3、两个给定列表位数不一定相同，所以每次相加时需要判断 tail 指针所指是否非空，若为空，则要在该位赋值为0</p><p>4、注意进位carry</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode() : val(0), next(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">addTwoNumbers</span><span class="params">(ListNode* l1, ListNode* l2)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span>  carry = <span class="number">0</span>;</span><br><span class="line">        ListNode *head = <span class="literal">nullptr</span>;</span><br><span class="line">        ListNode *tail = <span class="literal">nullptr</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(l1 || l2)&#123;</span><br><span class="line">            <span class="type">int</span> n1 = l1? l1-&gt;val:<span class="number">0</span>;</span><br><span class="line">            <span class="type">int</span> n2 = l2? l2-&gt;val:<span class="number">0</span>;</span><br><span class="line">            <span class="type">int</span> sum = n1 + n2 + carry;</span><br><span class="line">            carry  = sum /<span class="number">10</span>;</span><br><span class="line">            <span class="keyword">if</span>(!head)</span><br><span class="line">                head = tail = <span class="keyword">new</span> <span class="built_in">ListNode</span>(sum % <span class="number">10</span>);</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                tail-&gt;next = <span class="keyword">new</span> <span class="built_in">ListNode</span>(sum % <span class="number">10</span>);</span><br><span class="line">                tail = tail-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(l1)  l1 = l1-&gt;next;</span><br><span class="line">            <span class="keyword">if</span>(l2)  l2 = l2-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(carry &gt; <span class="number">0</span>)</span><br><span class="line">            tail-&gt;next = <span class="keyword">new</span> <span class="built_in">ListNode</span>(<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;LEETCODE-2-两数相加&quot;&gt;&lt;a href=&quot;#LEETCODE-2-两数相加&quot; class=&quot;headerlink&quot; title=&quot;LEETCODE 2.  两数相加&quot;&gt;&lt;/a&gt;LEETCODE 2.  两数相加&lt;/h2&gt;&lt;p&gt;给你两个 &lt;strong&gt;非空&lt;/strong&gt; 的链表，表示两个非负的整数。它们每位数字都是按照 &lt;strong&gt;逆序&lt;/strong&gt; 的方式存储的，并且每个节点只能存储 &lt;strong&gt;一位&lt;/strong&gt; 数字。&lt;/p&gt;
&lt;p&gt;请你将两个数相加，并以相同形式返回一个表示和的链表。&lt;/p&gt;
&lt;p&gt;你可以假设除了数字 0 之外，这两个数都不会以 0 开头。&lt;/p&gt;</summary>
    
    
    
    <category term="LeetCode" scheme="http://example.com/categories/LeetCode/"/>
    
    
  </entry>
  
  <entry>
    <title>LEETCODE 3. 无重复字符的最长字串</title>
    <link href="http://example.com/2023/11/30/LEETCODE-3.%E6%97%A0%E9%87%8D%E5%A4%8D%E5%AD%97%E7%AC%A6%E7%9A%84%E6%9C%80%E9%95%BF%E5%AD%97%E4%B8%B2/"/>
    <id>http://example.com/2023/11/30/LEETCODE-3.%E6%97%A0%E9%87%8D%E5%A4%8D%E5%AD%97%E7%AC%A6%E7%9A%84%E6%9C%80%E9%95%BF%E5%AD%97%E4%B8%B2/</id>
    <published>2023-11-30T07:53:37.844Z</published>
    <updated>2023-11-30T07:53:37.844Z</updated>
    
    <content type="html"><![CDATA[<h2 id="LEETCODE-3-无重复字符的最长字串"><a href="#LEETCODE-3-无重复字符的最长字串" class="headerlink" title="LEETCODE 3.  无重复字符的最长字串"></a>LEETCODE 3.  无重复字符的最长字串</h2><p>给定一个字符串 <code>s</code> ，请你找出其中不含有重复字符的 <strong>最长子串</strong> 的长度。</p><span id="more"></span><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">e.g.</span><br><span class="line">输入: s = <span class="string">&quot;abcabcbb&quot;</span></span><br><span class="line">输出: <span class="number">3</span> </span><br><span class="line">解释: 因为无重复字符的最长子串是 <span class="string">&quot;abc&quot;</span>，所以其长度为 <span class="number">3</span>。</span><br><span class="line">    </span><br><span class="line">输入: s = <span class="string">&quot;bbbbb&quot;</span></span><br><span class="line">输出: <span class="number">1</span></span><br><span class="line">解释: 因为无重复字符的最长子串是 <span class="string">&quot;b&quot;</span>，所以其长度为 <span class="number">1</span>。</span><br><span class="line">    </span><br><span class="line">输入: s = <span class="string">&quot;pwwkew&quot;</span></span><br><span class="line">输出: <span class="number">3</span></span><br><span class="line">解释: 因为无重复字符的最长子串是 <span class="string">&quot;wke&quot;</span>，所以其长度为 <span class="number">3</span>。</span><br><span class="line">     请注意，你的答案必须是 子串 的长度，<span class="string">&quot;pwke&quot;</span> 是一个子序列，不是子串。</span><br></pre></td></tr></table></figure><hr><p>该题逐步分析</p><p>解决思路：滑动窗口</p><p>1、依次递增地枚举子串的起始位置，那么子串的结束位置也是递增的</p><p>2、可以指定双指针来定位字串的左右边界</p><p>3、无重复：右边界+1     有重复：左边界+1</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">lengthOfLongestSubstring</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = s.<span class="built_in">size</span>();</span><br><span class="line">        <span class="type">int</span> head=<span class="number">0</span>, tail=<span class="number">0</span>,cur_length=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(tail &lt; n)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i=head;i&lt;tail;i++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(s[i] == s[tail])&#123;</span><br><span class="line">                     head=i+<span class="number">1</span>;</span><br><span class="line">                     <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            cur_length=<span class="built_in">max</span>(cur_length,tail-head+<span class="number">1</span>);</span><br><span class="line">            tail++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> cur_length;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;LEETCODE-3-无重复字符的最长字串&quot;&gt;&lt;a href=&quot;#LEETCODE-3-无重复字符的最长字串&quot; class=&quot;headerlink&quot; title=&quot;LEETCODE 3.  无重复字符的最长字串&quot;&gt;&lt;/a&gt;LEETCODE 3.  无重复字符的最长字串&lt;/h2&gt;&lt;p&gt;给定一个字符串 &lt;code&gt;s&lt;/code&gt; ，请你找出其中不含有重复字符的 &lt;strong&gt;最长子串&lt;/strong&gt; 的长度。&lt;/p&gt;</summary>
    
    
    
    <category term="LeetCode" scheme="http://example.com/categories/LeetCode/"/>
    
    
  </entry>
  
  <entry>
    <title>MMU (个人化理解)</title>
    <link href="http://example.com/2023/11/30/MMU/"/>
    <id>http://example.com/2023/11/30/MMU/</id>
    <published>2023-11-30T07:53:37.844Z</published>
    <updated>2023-11-30T07:53:37.844Z</updated>
    
    <content type="html"><![CDATA[<h2 id="MMU-–memory-managment-unit-内存管理单元"><a href="#MMU-–memory-managment-unit-内存管理单元" class="headerlink" title="MMU –memory managment unit  内存管理单元"></a>MMU –memory managment unit  内存管理单元</h2><h2 id="三点作用："><a href="#三点作用：" class="headerlink" title="三点作用："></a>三点作用：</h2><blockquote><p>1、提供虚拟地址和物理地址的转换<br>2、对内存中各个段的访问、读写权限管理<br>3、虚拟内存，允许程序使用比物理内存更大的内存空间</p></blockquote><span id="more"></span><h3 id="Q1-为什么要引入虚拟内存？"><a href="#Q1-为什么要引入虚拟内存？" class="headerlink" title="Q1:为什么要引入虚拟内存？"></a>Q1:为什么要引入虚拟内存？</h3><blockquote><p>1、未引入虚拟内存时，所有进程直接访问物理地址，数据很容易被修改，不安全。引入虚拟内存后，实现了虚拟内存和物理内存的隔离，保障了安全性，隔离了程序，保护数据。<br>2、系统的理论最大内存容量和CPU的位数有关。32位计算机理论上最高支持4GB内存。但实际生产中有时候用不到这么大的内存，比如只用了2GB内存，这时候浪费了2GB的寻址能力。使用虚拟内存后，在CPU的视角来看模拟出了一个更大的内存，从而提高了系统可用内存的大小。 </p></blockquote><h3 id="Q2：如何实现对内存的权限管理"><a href="#Q2：如何实现对内存的权限管理" class="headerlink" title="Q2：如何实现对内存的权限管理"></a>Q2：如何实现对内存的权限管理</h3><blockquote><p>内存管理分用户层和kernel层<br>kernel层，ARM11允许控制16个域，每个域可以设定不同的权限，（读，写，可执行）<br>内存的访问权限受控于：域的权限+用户是否特权</p></blockquote><blockquote><p>域是节、大页和小页的集合。ARM结构支持16个域。对域的访问由域访问控制寄存器的两个位字段控制。因为每个字段对访问对应的域的使能非常迅速，所以整个存储器区间能很快地交换进出虚拟存储器。这里支持 2种域访问方式：  </p><p><code>客户域</code>的用户（执行程序，访问数据），被形成这个域的节或页来监督访问权限。<br><code>管理者</code>控制域的行为（域中的当前节和页，对域的访问），不被形成这个域的节或页来监督访问权限。<br>一个程序可以是一些域的客户，也是另外一些域的管理者，同时没有对其它域的访问权限。这允许对程序访问不同存储器资源的非常灵活的存储器保护  </p></blockquote><h3 id="Q3：MMU的使用"><a href="#Q3：MMU的使用" class="headerlink" title="Q3：MMU的使用"></a>Q3：MMU的使用</h3><blockquote><p>在kernel中进行make menuconfig ARCH&#x3D;arm 进行配置  </p></blockquote><blockquote><p>&#x2F;***    打开mmu功能    ***&#x2F;<br>CONFIG_MMU&#x3D;y  </p></blockquote><blockquote><p>&#x2F;***    打开内存权限管理    **&#x2F;<br>STRICT_KERNEL_RWX &#x3D;y<br>ARCH_HAS_STRICT_KERNEL_RWX&#x3D;y  </p></blockquote><h3 id="Q4：页表转换"><a href="#Q4：页表转换" class="headerlink" title="Q4：页表转换"></a>Q4：页表转换</h3><blockquote><p>LINUX OS支持三层页表，但是ARM11 只支持两层页表，故在arm架构中，二级页表 &#x3D;&#x3D; 三级页表</p></blockquote>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;MMU-–memory-managment-unit-内存管理单元&quot;&gt;&lt;a href=&quot;#MMU-–memory-managment-unit-内存管理单元&quot; class=&quot;headerlink&quot; title=&quot;MMU –memory managment unit  内存管理单元&quot;&gt;&lt;/a&gt;MMU –memory managment unit  内存管理单元&lt;/h2&gt;&lt;h2 id=&quot;三点作用：&quot;&gt;&lt;a href=&quot;#三点作用：&quot; class=&quot;headerlink&quot; title=&quot;三点作用：&quot;&gt;&lt;/a&gt;三点作用：&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;1、提供虚拟地址和物理地址的转换&lt;br&gt;2、对内存中各个段的访问、读写权限管理&lt;br&gt;3、虚拟内存，允许程序使用比物理内存更大的内存空间&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    <category term="Linux" scheme="http://example.com/categories/Linux/"/>
    
    
  </entry>
  
  <entry>
    <title>莫言-《鳄鱼》</title>
    <link href="http://example.com/2023/11/30/%E8%8E%AB%E8%A8%80-%E3%80%8A%E9%B3%84%E9%B1%BC%E3%80%8B/"/>
    <id>http://example.com/2023/11/30/%E8%8E%AB%E8%A8%80-%E3%80%8A%E9%B3%84%E9%B1%BC%E3%80%8B/</id>
    <published>2023-11-30T07:53:37.844Z</published>
    <updated>2023-11-30T07:53:37.844Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>《鳄鱼》分为四幕九场，讲述的是一位逃亡国外的腐败官员的故事。情节围绕腐败官员单无惮及其在生日派对上收到的贺礼“鳄鱼”展开：2005年无惮五十五岁生日时，做观赏鱼生意的商人老黑送他一条三十厘米长的小鳄鱼作为寿礼。了解到鳄鱼的生长取决于环境限制程度的特性，心事重重的无惮对鳄鱼产生了浓厚的兴趣。十年间，无惮身边各色人等粉墨登场，前妻巧玲欲与情人瘦马争夺无惮所居别墅的所有权；“外甥”牛布与行为艺术表演者灯罩一边从无惮身上榨取“艺术素材”，一边劝诱无惮加入他们的行列……无惮与鳄鱼越发亲近，觉得只有鳄鱼才能了解他的心声。他不断为鳄鱼更换更大的鱼缸，纵容着鳄鱼不断长大，直至成为长达四米的庞然巨兽。</p></blockquote><span id="more"></span>  <p>故事内容和寓意没有太多的感触，情节的冲突性很少，个人感觉一般。但是对其之外的一个文章细节有所感悟。主人公无惮作为一个在逃贪官，在书中展现出的形象相比身边人反而是更爱国的，并且个人也是具有人格魅力的。这种矛盾感却能让人觉得很合理。无惮在短短的四幕话剧中，无数次提到了自己对故土的想念，以及自我嘲弄，一口一个愧对人民，不配当人。 他难道是真心的呢？ 无惮此刻身在美国，身边又都是同流之辈，完全没必要再去装给别人看，所以我倾向于他的这种情绪不是装的，但也不是真的，他不是真心觉得自己做错了，愧对人民和国家，如果让他再来一次，我相信他依然会选择当一个贪官。</p><p>无惮的这种行为，我的理解是 借用自嘲和自我贬低来企图减轻一点自己的罪恶感，同时又能获得道德精神上的崇高感。所有知道 “ 好 ” 而选择 “ 坏 ” 的人或多或少都如此。他用 “ 造桥让你们贪了，但是质量必须要好 ”这种故事来标榜自己是一个复杂的好官，用现在流行的形容词来说，他是一个表演型人格，但是他不演给其他人，而是演给自己。这是坏的不那么纯粹的人惯用的伎俩。他没有办法打心底里说出“人不为己，天诛地灭”，“我只管我自己舒服，他人与我何干”这种话，因为他知道对的东西长什么样，更清楚他就是不对。无惮是有内心世界的，他随时都在和自己对话，这种对话时刻折磨着他，也就是老话说的，良心的谴责。但也仅仅是自我满足一类的谴责罢了。没错，谴责也可以自我满足，你让他真回国接受审判，他是万万不肯的。这种性格的人，批评与谴责远比赞美更加来的让他心安。</p><p>这种人是很可悲的，他清楚知道自己的问题在哪，清楚知道自己想要什么，但是他永远也到不了。他被自己的表演型人格束缚住了，他甚至永远以为自己走在更加复杂，无奈却又正确的路上，他再也找不到 “ 真 ”了，对于他而言这远比其他事情来得更可悲。读过书，受过教育的人，思想上容易变得 “ 精致 ”，这种精致来源于读过书，又没读过很多书。他们的 “ 精致 ”更像是一种自以为是，口感好像劣质酒精夹杂着热塑料味儿， 尖锐又刺鼻。更可怕的是，这种三观一旦形成，是根深蒂固的。动人观念如刨人祖坟。他们自以为是，再听不见只言片语。</p><p>光提出问题不解决多少有点耍流氓的嫌疑。我的办法是，“ 真 ”一点，逼着自己纯粹一点，用他人之言来骂醒自己，让自己变成一个纯粹的人，不管好的还是坏的，都纯粹一点，不要把自己放在火堆上慢烤，拷上八十载，把生活过成人间炼狱。</p>]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;《鳄鱼》分为四幕九场，讲述的是一位逃亡国外的腐败官员的故事。情节围绕腐败官员单无惮及其在生日派对上收到的贺礼“鳄鱼”展开：2005年无惮五十五岁生日时，做观赏鱼生意的商人老黑送他一条三十厘米长的小鳄鱼作为寿礼。了解到鳄鱼的生长取决于环境限制程度的特性，心事重重的无惮对鳄鱼产生了浓厚的兴趣。十年间，无惮身边各色人等粉墨登场，前妻巧玲欲与情人瘦马争夺无惮所居别墅的所有权；“外甥”牛布与行为艺术表演者灯罩一边从无惮身上榨取“艺术素材”，一边劝诱无惮加入他们的行列……无惮与鳄鱼越发亲近，觉得只有鳄鱼才能了解他的心声。他不断为鳄鱼更换更大的鱼缸，纵容着鳄鱼不断长大，直至成为长达四米的庞然巨兽。&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    <category term="读书" scheme="http://example.com/categories/%E8%AF%BB%E4%B9%A6/"/>
    
    
  </entry>
  
</feed>
