<div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2023-12-08T09:46:02.251Z" title="12/8/2023, 5:46:02 PM">2023-12-08</time>发表</span><span class="level-item"><time dateTime="2023-12-08T09:46:02.251Z" title="12/8/2023, 5:46:02 PM">2023-12-08</time>更新</span><span class="level-item"><a class="link-muted" href="/categories/C/">C++</a></span><span class="level-item" id="busuanzi_container_page_pv"><span id="busuanzi_value_page_pv">0</span>次访问</span></div></div><h1 class="title is-3 is-size-4-mobile">C++的参数传递</h1><div class="content"><blockquote>
<p>C++的参数传递</p>
<ul>
<li>值传递</li>
<li>指针传递</li>
<li>引用传递</li>
</ul>
</blockquote>
<span id="more"></span>

<h2 id="值传递"><a href="#值传递" class="headerlink" title="值传递"></a>值传递</h2><p>​	当初始化一个非引用类型的变量时，初始值被<strong>拷贝</strong>给变量，对此变量的操作不会影响初始值。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a = <span class="number">0</span>;  <span class="comment">// a为初始变量</span></span><br><span class="line"><span class="type">int</span> b = a;  <span class="comment">// b是a的值的副本</span></span><br><span class="line">b = <span class="number">10</span>;   <span class="comment">// b值的修改不会改变a的初始值</span></span><br></pre></td></tr></table></figure>
<h2 id="指针形参"><a href="#指针形参" class="headerlink" title="指针形参"></a>指针形参</h2><p>​	当执行指针拷贝时，行为和普通值传递一样，拷贝的是指针的值，拷贝之后，两个指针是不同的指针</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">change</span><span class="params">(<span class="type">int</span> *ptr)</span></span>&#123;</span><br><span class="line">    *ptr = <span class="number">100</span>;		<span class="comment">//改变了ptr所指的对象的值</span></span><br><span class="line">      ptr = <span class="number">100</span>;	<span class="comment">//只改变了ptr的局部拷贝，实参的值未改变</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> num = <span class="number">40</span>;</span><br><span class="line"><span class="built_in">change</span>(&amp;num); <span class="comment">//改变了num的值而非地址</span></span><br><span class="line"><span class="built_in">print</span>(num);  <span class="comment">// 伪代码，输出 num = 100</span></span><br></pre></td></tr></table></figure>

<p><strong>C中常常使用指针类型的形参访问函数外部的对象，在C++中建议用引用类型替代指针类型</strong></p>
<h2 id="引用传递"><a href="#引用传递" class="headerlink" title="引用传递"></a>引用传递</h2><p>​		<strong>引用</strong>可以等价看作为对象起了一个别名，声明符号为**&amp;a**</p>
<blockquote>
<p>​	int num &#x3D; 100;<br>​	int &amp;ref &#x3D; num; &#x2F;&#x2F; ref 指向 num, 是 num 的另一个名字<br>​	int &mmm;     &#x2F;&#x2F; <strong>报错，引用必须被初始化</strong></p>
</blockquote>
<p>一般在初始化变量时，初始值会被拷贝到新建对象中。而在定义引用时，程序把引用和初始值进行了<strong>绑定</strong>，而非拷贝初始值，所以引用必须被初始化。</p>
<p><strong>牢记：引用即别名</strong></p>
<p>引用本身不是一个对象，所以不能定义引用的引用，即：</p>
<blockquote>
<p>int a &#x3D; 1;<br>int &amp;ref_1 &#x3D; a;   &#x2F;&#x2F; 正确初始化引用<br>int &amp;ref_2 &#x3D; ref_1 &#x2F;&#x2F; <strong>错误：不能定义引用的引用</strong> </p>
</blockquote>
<p>在函数中使用引用传递：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">change</span><span class="params">(<span class="type">int</span> &amp;i)</span></span>&#123;	<span class="comment">//此处的 int &amp;i 意思是接收一个int对象的引用，而非取地址</span></span><br><span class="line">    i = <span class="number">100</span>;				<span class="comment">// 可理解为 &amp;i = j;标准的初始化引用,i仅仅是j的一个别称</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> j = <span class="number">5</span>;</span><br><span class="line"><span class="built_in">change</span>(j);	<span class="comment">// j 采用传引用方式，值将被改变</span></span><br><span class="line"><span class="built_in">print</span>(j);   <span class="comment">// j = 100</span></span><br></pre></td></tr></table></figure>

<p>使用引用传递的好处：</p>
<ol>
<li><p>避免拷贝<br>当对象比较大时，直接拷贝对象比较低效，有些类型(如IO)根本不支持拷贝操作，此时只能引用</p>
</li>
<li><p>返回额外信息<br>C++中一个函数只能返回一个值，引用形参可以为我们返回多个值提供途径</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">test_a</span><span class="params">(<span class="type">int</span> a)</span></span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">return</span> x;   <span class="comment">//不使用引用时，只能返回一个x   </span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test_b</span><span class="params">(<span class="type">int</span> &amp;a)</span></span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">return</span> x;  <span class="comment">//使用引用时，除了x， 改变引用a的值同时会改变实参，相当于返回了另一个值</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<h2 id="引用与指针的区别"><a href="#引用与指针的区别" class="headerlink" title="引用与指针的区别"></a>引用与指针的区别</h2><ol>
<li><p>形式上：</p>
<ul>
<li><p>指针本质上是一个存放地址的变量，是逻辑上独立的对象，可以被改变；</p>
</li>
<li><p>引用逻辑上不独立，只是一个别名，初始化后不可被改变，只能依附于同一个变量</p>
</li>
</ul>
</li>
<li><p>传递方式上：</p>
<ul>
<li>指针传递参数本质上还是<strong>值传递</strong>，它所传递的是个地址，在传递过程中会在栈上开辟空间，存放由主函数放进来的实参的值，从而成为实参的一个副本。值传递的特点是对任何形参做的任何操作都作为局部变量进行，不会印象实参。</li>
<li>引用传递过程中，形参虽然也作为局部变量在栈上开辟空间，但此时存放的是实参的地址，对形参做的操作都可以看做间接寻址。</li>
</ul>
</li>
<li><p>编译角度：<br>程序在编译时分别将指针和引用添加到符号表上，符号表上记录的是变量名及变量所对应地址。指针变量在符号表上对应的地址值为指针变量的地址值，而引用在符号表上对应的地址值为引用对象的地址值。符号表生成后就不会再改，因此指针可以改变其指向的对象（指针变量中的值可以改），而引用对象则不能修改。</p>
</li>
</ol>
</div><div class="article-licensing box"><div class="licensing-title"><p>C++的参数传递</p><p><a href="http://example.com/2023/12/08/C++的参数传递/">http://example.com/2023/12/08/C++的参数传递/</a></p></div><div class="licensing-meta level is-mobile"><div class="level-left"><div class="level-item is-narrow"><div><h6>作者</h6><p>lx</p></div></div><div class="level-item is-narrow"><div><h6>发布于</h6><p>2023-12-08</p></div></div><div class="level-item is-narrow"><div><h6>更新于</h6><p>2023-12-08</p></div></div><div class="level-item is-narrow"><div><h6>许可协议</h6><p><a class="icons" rel="noopener" target="_blank" title="Creative Commons" href="https://creativecommons.org/"><i class="icon fab fa-creative-commons"></i></a><a class="icons" rel="noopener" target="_blank" title="Attribution" href="https://creativecommons.org/licenses/by/4.0/"><i class="icon fab fa-creative-commons-by"></i></a><a class="icons" rel="noopener" target="_blank" title="Noncommercial" href="https://creativecommons.org/licenses/by-nc/4.0/"><i class="icon fab fa-creative-commons-nc"></i></a></p></div></div></div></div></div><!--!--></article></div><!--!--><nav class="post-navigation mt-4 level is-mobile"><div class="level-start"><a class="article-nav-prev level level-item link-muted" href="/2024/01/02/VINTF/"><i class="level-item fas fa-chevron-left"></i><span class="level-item">Android-vintf</span></a></div><div class="level-end"><a class="article-nav-next level level-item link-muted" href="/2023/12/08/LEETCODE-7.%E6%95%B4%E6%95%B0%E5%8F%8D%E8%BD%AC/"><span class="level-item">LEETCODE 7. 整数反转</span><i class="level-item fas fa-chevron-right"></i></a></div></nav><div class="card"><div class="card-content"><h3 class="title is-5">评论</h3><div class="content" id="valine-thread"></div><script src="//cdn.jsdelivr.net/npm/leancloud-storage@3/dist/av-min.js"></script><script src="https://cdnjs.loli.net/ajax/libs/valine/1.4.16/Valine.min.js"></script><script>new Valine({
            el: '#valine-thread',
            appId: "dB8Dj4QSAc3XtpuM6sS4fCKR-gzGzoHsz",
            appKey: "xrxrySOXhneb2IHjGP1lHSx3",
            
            avatar: "mm",
            avatarForce: false,
            meta: ["nick","mail","link"],
            pageSize: 10,
            lang: "zh-CN",
            visitor: false,
            highlight: true,
            recordIP: false,
            
            
            
            enableQQ: false,
            requiredFields: [],
        });</script></div></div>